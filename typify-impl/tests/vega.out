#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<AggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<AggregateTransformCross>,
    #[serde(default = "defaults::aggregate_transform_drop")]
    pub drop: AggregateTransformDrop,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<AggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<AggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<AggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<AggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: AggregateTransformType,
}
impl From<&AggregateTransform> for AggregateTransform {
    fn from(value: &AggregateTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformAs {
    Variant0(Vec<AggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&AggregateTransformAs> for AggregateTransformAs {
    fn from(value: &AggregateTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&AggregateTransformAsVariant0Item> for AggregateTransformAsVariant0Item {
    fn from(value: &AggregateTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformCross {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&AggregateTransformCross> for AggregateTransformCross {
    fn from(value: &AggregateTransformCross) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformDrop {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&AggregateTransformDrop> for AggregateTransformDrop {
    fn from(value: &AggregateTransformDrop) -> Self {
        value.clone()
    }
}
impl Default for AggregateTransformDrop {
    fn default() -> Self {
        AggregateTransformDrop::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformFields {
    Variant0(Vec<AggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&AggregateTransformFields> for AggregateTransformFields {
    fn from(value: &AggregateTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&AggregateTransformFieldsVariant0Item> for AggregateTransformFieldsVariant0Item {
    fn from(value: &AggregateTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformGroupby {
    Variant0(Vec<AggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&AggregateTransformGroupby> for AggregateTransformGroupby {
    fn from(value: &AggregateTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&AggregateTransformGroupbyVariant0Item> for AggregateTransformGroupbyVariant0Item {
    fn from(value: &AggregateTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&AggregateTransformKey> for AggregateTransformKey {
    fn from(value: &AggregateTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformOps {
    Variant0(Vec<AggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&AggregateTransformOps> for AggregateTransformOps {
    fn from(value: &AggregateTransformOps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformOpsVariant0Item {
    Variant0(AggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&AggregateTransformOpsVariant0Item> for AggregateTransformOpsVariant0Item {
    fn from(value: &AggregateTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&AggregateTransformOpsVariant0ItemVariant0>
    for AggregateTransformOpsVariant0ItemVariant0
{
    fn from(value: &AggregateTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AggregateTransformType {
    #[serde(rename = "aggregate")]
    Aggregate,
}
impl From<&AggregateTransformType> for AggregateTransformType {
    fn from(value: &AggregateTransformType) -> Self {
        value.clone()
    }
}
impl ToString for AggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Aggregate => "aggregate".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "aggregate" => Ok(Self::Aggregate),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AggregateTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValue {
    Variant0(Vec<AlignValueVariant0Item>),
    Variant1(AlignValueVariant1),
}
impl From<&AlignValue> for AlignValue {
    fn from(value: &AlignValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant0ItemSubtype1,
}
impl From<&AlignValueVariant0Item> for AlignValueVariant0Item {
    fn from(value: &AlignValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant0ItemSubtype1Subtype1,
}
impl From<&AlignValueVariant0ItemSubtype1> for AlignValueVariant0ItemSubtype1 {
    fn from(value: &AlignValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AlignValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&AlignValueVariant0ItemSubtype1Subtype1> for AlignValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype0>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AlignValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype1>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype2>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&AlignValueVariant0ItemSubtype1Subtype1Subtype3>
    for AlignValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &AlignValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AlignValueVariant1Subtype1,
}
impl From<&AlignValueVariant1> for AlignValueVariant1 {
    fn from(value: &AlignValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AlignValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AlignValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AlignValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AlignValueVariant1Subtype1Subtype3>,
}
impl From<&AlignValueVariant1Subtype1> for AlignValueVariant1Subtype1 {
    fn from(value: &AlignValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: AlignValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AlignValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AlignValueVariant1Subtype1Subtype0> for AlignValueVariant1Subtype1Subtype0 {
    fn from(value: &AlignValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlignValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&AlignValueVariant1Subtype1Subtype0Variant1Value>
    for AlignValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &AlignValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for AlignValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AlignValueVariant1Subtype1Subtype0Variant3Range>
    for AlignValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &AlignValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AlignValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AlignValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype1 {}
impl From<&AlignValueVariant1Subtype1Subtype1> for AlignValueVariant1Subtype1Subtype1 {
    fn from(value: &AlignValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype2 {}
impl From<&AlignValueVariant1Subtype1Subtype2> for AlignValueVariant1Subtype1Subtype2 {
    fn from(value: &AlignValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AlignValueVariant1Subtype1Subtype3 {}
impl From<&AlignValueVariant1Subtype1Subtype3> for AlignValueVariant1Subtype1Subtype3 {
    fn from(value: &AlignValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValue {
    Variant0(Vec<AnchorValueVariant0Item>),
    Variant1(AnchorValueVariant1),
}
impl From<&AnchorValue> for AnchorValue {
    fn from(value: &AnchorValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant0ItemSubtype1,
}
impl From<&AnchorValueVariant0Item> for AnchorValueVariant0Item {
    fn from(value: &AnchorValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant0ItemSubtype1Subtype1,
}
impl From<&AnchorValueVariant0ItemSubtype1> for AnchorValueVariant0ItemSubtype1 {
    fn from(value: &AnchorValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnchorValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1> for AnchorValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype0>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AnchorValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype1>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype2>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&AnchorValueVariant0ItemSubtype1Subtype1Subtype3>
    for AnchorValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &AnchorValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnchorValueVariant1Subtype1,
}
impl From<&AnchorValueVariant1> for AnchorValueVariant1 {
    fn from(value: &AnchorValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnchorValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnchorValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnchorValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnchorValueVariant1Subtype1Subtype3>,
}
impl From<&AnchorValueVariant1Subtype1> for AnchorValueVariant1Subtype1 {
    fn from(value: &AnchorValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: AnchorValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnchorValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AnchorValueVariant1Subtype1Subtype0> for AnchorValueVariant1Subtype1Subtype0 {
    fn from(value: &AnchorValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AnchorValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&AnchorValueVariant1Subtype1Subtype0Variant1Value>
    for AnchorValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &AnchorValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AnchorValueVariant1Subtype1Subtype0Variant3Range>
    for AnchorValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &AnchorValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnchorValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AnchorValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype1 {}
impl From<&AnchorValueVariant1Subtype1Subtype1> for AnchorValueVariant1Subtype1Subtype1 {
    fn from(value: &AnchorValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype2 {}
impl From<&AnchorValueVariant1Subtype1Subtype2> for AnchorValueVariant1Subtype1Subtype2 {
    fn from(value: &AnchorValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnchorValueVariant1Subtype1Subtype3 {}
impl From<&AnchorValueVariant1Subtype1Subtype3> for AnchorValueVariant1Subtype1Subtype3 {
    fn from(value: &AnchorValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValue {
    Variant0(Vec<AnyValueVariant0Item>),
    Variant1(AnyValueVariant1),
}
impl From<&AnyValue> for AnyValue {
    fn from(value: &AnyValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant0ItemSubtype1,
}
impl From<&AnyValueVariant0Item> for AnyValueVariant0Item {
    fn from(value: &AnyValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant0ItemSubtype1Subtype1,
}
impl From<&AnyValueVariant0ItemSubtype1> for AnyValueVariant0ItemSubtype1 {
    fn from(value: &AnyValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnyValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&AnyValueVariant0ItemSubtype1Subtype1> for AnyValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AnyValueVariant0ItemSubtype1Subtype1Subtype0>
    for AnyValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AnyValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&AnyValueVariant0ItemSubtype1Subtype1Subtype1>
    for AnyValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&AnyValueVariant0ItemSubtype1Subtype1Subtype2>
    for AnyValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&AnyValueVariant0ItemSubtype1Subtype1Subtype3>
    for AnyValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &AnyValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: AnyValueVariant1Subtype1,
}
impl From<&AnyValueVariant1> for AnyValueVariant1 {
    fn from(value: &AnyValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<AnyValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<AnyValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<AnyValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<AnyValueVariant1Subtype1Subtype3>,
}
impl From<&AnyValueVariant1Subtype1> for AnyValueVariant1Subtype1 {
    fn from(value: &AnyValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: AnyValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&AnyValueVariant1Subtype1Subtype0> for AnyValueVariant1Subtype1Subtype0 {
    fn from(value: &AnyValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&AnyValueVariant1Subtype1Subtype0Variant3Range>
    for AnyValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &AnyValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnyValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for AnyValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnyValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnyValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for AnyValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype1 {}
impl From<&AnyValueVariant1Subtype1Subtype1> for AnyValueVariant1Subtype1Subtype1 {
    fn from(value: &AnyValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype2 {}
impl From<&AnyValueVariant1Subtype1Subtype2> for AnyValueVariant1Subtype1Subtype2 {
    fn from(value: &AnyValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnyValueVariant1Subtype1Subtype3 {}
impl From<&AnyValueVariant1Subtype1Subtype3> for AnyValueVariant1Subtype1Subtype3 {
    fn from(value: &AnyValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayOrSignal {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&ArrayOrSignal> for ArrayOrSignal {
    fn from(value: &ArrayOrSignal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValue {
    Variant0(Vec<ArrayValueVariant0Item>),
    Variant1(ArrayValueVariant1),
}
impl From<&ArrayValue> for ArrayValue {
    fn from(value: &ArrayValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant0ItemSubtype1,
}
impl From<&ArrayValueVariant0Item> for ArrayValueVariant0Item {
    fn from(value: &ArrayValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant0ItemSubtype1Subtype1,
}
impl From<&ArrayValueVariant0ItemSubtype1> for ArrayValueVariant0ItemSubtype1 {
    fn from(value: &ArrayValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<ArrayValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1> for ArrayValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1Subtype0>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for ArrayValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1Subtype1>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1Subtype2>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&ArrayValueVariant0ItemSubtype1Subtype1Subtype3>
    for ArrayValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &ArrayValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: ArrayValueVariant1Subtype1,
}
impl From<&ArrayValueVariant1> for ArrayValueVariant1 {
    fn from(value: &ArrayValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<ArrayValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<ArrayValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<ArrayValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<ArrayValueVariant1Subtype1Subtype3>,
}
impl From<&ArrayValueVariant1Subtype1> for ArrayValueVariant1Subtype1 {
    fn from(value: &ArrayValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: ArrayValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&ArrayValueVariant1Subtype1Subtype0> for ArrayValueVariant1Subtype1Subtype0 {
    fn from(value: &ArrayValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&ArrayValueVariant1Subtype1Subtype0Variant3Range>
    for ArrayValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &ArrayValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ArrayValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for ArrayValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ArrayValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ArrayValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for ArrayValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype1 {}
impl From<&ArrayValueVariant1Subtype1Subtype1> for ArrayValueVariant1Subtype1Subtype1 {
    fn from(value: &ArrayValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype2 {}
impl From<&ArrayValueVariant1Subtype1Subtype2> for ArrayValueVariant1Subtype1Subtype2 {
    fn from(value: &ArrayValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ArrayValueVariant1Subtype1Subtype3 {}
impl From<&ArrayValueVariant1Subtype1Subtype3> for ArrayValueVariant1Subtype1Subtype3 {
    fn from(value: &ArrayValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Autosize {
    Variant0(AutosizeVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        contains: Option<AutosizeVariant1Contains>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        resize: Option<bool>,
        #[serde(rename = "type")]
        type_: AutosizeVariant1Type,
    },
    Variant2(SignalRef),
}
impl From<&Autosize> for Autosize {
    fn from(value: &Autosize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant0 {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl From<&AutosizeVariant0> for AutosizeVariant0 {
    fn from(value: &AutosizeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl Default for AutosizeVariant0 {
    fn default() -> Self {
        AutosizeVariant0::Pad
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant1Contains {
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "padding")]
    Padding,
}
impl From<&AutosizeVariant1Contains> for AutosizeVariant1Contains {
    fn from(value: &AutosizeVariant1Contains) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant1Contains {
    fn to_string(&self) -> String {
        match *self {
            Self::Content => "content".to_string(),
            Self::Padding => "padding".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Contains {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "content" => Ok(Self::Content),
            "padding" => Ok(Self::Padding),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Contains {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Contains {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant1Contains {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant1Type {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl From<&AutosizeVariant1Type> for AutosizeVariant1Type {
    fn from(value: &AutosizeVariant1Type) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl Default for AutosizeVariant1Type {
    fn default() -> Self {
        AutosizeVariant1Type::Pad
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Axis {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(
        rename = "bandPosition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub band_position: Option<AxisBandPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<bool>,
    #[serde(rename = "domainCap", default, skip_serializing_if = "Option::is_none")]
    pub domain_cap: Option<AxisDomainCap>,
    #[serde(
        rename = "domainColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_color: Option<AxisDomainColor>,
    #[serde(
        rename = "domainDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash: Option<AxisDomainDash>,
    #[serde(
        rename = "domainDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash_offset: Option<AxisDomainDashOffset>,
    #[serde(
        rename = "domainOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_opacity: Option<AxisDomainOpacity>,
    #[serde(
        rename = "domainWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_width: Option<AxisDomainWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<AxisEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<AxisFormat>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub format_type: Option<AxisFormatType>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<bool>,
    #[serde(rename = "gridCap", default, skip_serializing_if = "Option::is_none")]
    pub grid_cap: Option<AxisGridCap>,
    #[serde(rename = "gridColor", default, skip_serializing_if = "Option::is_none")]
    pub grid_color: Option<AxisGridColor>,
    #[serde(rename = "gridDash", default, skip_serializing_if = "Option::is_none")]
    pub grid_dash: Option<AxisGridDash>,
    #[serde(
        rename = "gridDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_dash_offset: Option<AxisGridDashOffset>,
    #[serde(
        rename = "gridOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_opacity: Option<AxisGridOpacity>,
    #[serde(rename = "gridScale", default, skip_serializing_if = "Option::is_none")]
    pub grid_scale: Option<String>,
    #[serde(rename = "gridWidth", default, skip_serializing_if = "Option::is_none")]
    pub grid_width: Option<AxisGridWidth>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_align: Option<AxisLabelAlign>,
    #[serde(
        rename = "labelAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_angle: Option<AxisLabelAngle>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_baseline: Option<AxisLabelBaseline>,
    #[serde(
        rename = "labelBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_bound: Option<AxisLabelBound>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_color: Option<AxisLabelColor>,
    #[serde(
        rename = "labelFlush",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush: Option<AxisLabelFlush>,
    #[serde(
        rename = "labelFlushOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush_offset: Option<NumberOrSignal>,
    #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
    pub label_font: Option<AxisLabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_size: Option<AxisLabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_style: Option<AxisLabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_weight: Option<AxisLabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_limit: Option<AxisLabelLimit>,
    #[serde(
        rename = "labelLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_line_height: Option<AxisLabelLineHeight>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_offset: Option<AxisLabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_opacity: Option<AxisLabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_overlap: Option<LabelOverlap>,
    #[serde(
        rename = "labelPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_padding: Option<AxisLabelPadding>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_separation: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<bool>,
    #[serde(rename = "maxExtent", default, skip_serializing_if = "Option::is_none")]
    pub max_extent: Option<AxisMaxExtent>,
    #[serde(rename = "minExtent", default, skip_serializing_if = "Option::is_none")]
    pub min_extent: Option<AxisMinExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<AxisOffset>,
    pub orient: AxisOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<AxisPosition>,
    pub scale: String,
    #[serde(rename = "tickBand", default, skip_serializing_if = "Option::is_none")]
    pub tick_band: Option<TickBand>,
    #[serde(rename = "tickCap", default, skip_serializing_if = "Option::is_none")]
    pub tick_cap: Option<AxisTickCap>,
    #[serde(rename = "tickColor", default, skip_serializing_if = "Option::is_none")]
    pub tick_color: Option<AxisTickColor>,
    #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
    pub tick_count: Option<TickCount>,
    #[serde(rename = "tickDash", default, skip_serializing_if = "Option::is_none")]
    pub tick_dash: Option<AxisTickDash>,
    #[serde(
        rename = "tickDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_dash_offset: Option<AxisTickDashOffset>,
    #[serde(rename = "tickExtra", default, skip_serializing_if = "Option::is_none")]
    pub tick_extra: Option<BooleanOrSignal>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_min_step: Option<NumberOrSignal>,
    #[serde(
        rename = "tickOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_offset: Option<AxisTickOffset>,
    #[serde(
        rename = "tickOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_opacity: Option<AxisTickOpacity>,
    #[serde(rename = "tickRound", default, skip_serializing_if = "Option::is_none")]
    pub tick_round: Option<AxisTickRound>,
    #[serde(rename = "tickSize", default, skip_serializing_if = "Option::is_none")]
    pub tick_size: Option<AxisTickSize>,
    #[serde(rename = "tickWidth", default, skip_serializing_if = "Option::is_none")]
    pub tick_width: Option<AxisTickWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_align: Option<AxisTitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_anchor: Option<AxisTitleAnchor>,
    #[serde(
        rename = "titleAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_angle: Option<AxisTitleAngle>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_baseline: Option<AxisTitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_color: Option<AxisTitleColor>,
    #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
    pub title_font: Option<AxisTitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_size: Option<AxisTitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_style: Option<AxisTitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_weight: Option<AxisTitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_limit: Option<AxisTitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_line_height: Option<AxisTitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_opacity: Option<AxisTitleOpacity>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_padding: Option<AxisTitlePadding>,
    #[serde(rename = "titleX", default, skip_serializing_if = "Option::is_none")]
    pub title_x: Option<AxisTitleX>,
    #[serde(rename = "titleY", default, skip_serializing_if = "Option::is_none")]
    pub title_y: Option<AxisTitleY>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<AxisTranslate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<f64>,
}
impl From<&Axis> for Axis {
    fn from(value: &Axis) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisBandPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisBandPosition> for AxisBandPosition {
    fn from(value: &AxisBandPosition) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisDomainCap> for AxisDomainCap {
    fn from(value: &AxisDomainCap) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&AxisDomainColor> for AxisDomainColor {
    fn from(value: &AxisDomainColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&AxisDomainDash> for AxisDomainDash {
    fn from(value: &AxisDomainDash) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisDomainDashOffset> for AxisDomainDashOffset {
    fn from(value: &AxisDomainDashOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisDomainOpacity> for AxisDomainOpacity {
    fn from(value: &AxisDomainOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisDomainWidth> for AxisDomainWidth {
    fn from(value: &AxisDomainWidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AxisEncode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub axis: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&AxisEncode> for AxisEncode {
    fn from(value: &AxisEncode) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum AxisFormat {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&AxisFormat> for AxisFormat {
    fn from(value: &AxisFormat) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisFormatType {
    Variant0(AxisFormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&AxisFormatType> for AxisFormatType {
    fn from(value: &AxisFormatType) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisFormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&AxisFormatTypeVariant0> for AxisFormatTypeVariant0 {
    fn from(value: &AxisFormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisFormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for AxisFormatTypeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisFormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisFormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisFormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisGridCap> for AxisGridCap {
    fn from(value: &AxisGridCap) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&AxisGridColor> for AxisGridColor {
    fn from(value: &AxisGridColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&AxisGridDash> for AxisGridDash {
    fn from(value: &AxisGridDash) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisGridDashOffset> for AxisGridDashOffset {
    fn from(value: &AxisGridDashOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisGridOpacity> for AxisGridOpacity {
    fn from(value: &AxisGridOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisGridWidth> for AxisGridWidth {
    fn from(value: &AxisGridWidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelAlign {
    Variant0(AxisLabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&AxisLabelAlign> for AxisLabelAlign {
    fn from(value: &AxisLabelAlign) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisLabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&AxisLabelAlignVariant0> for AxisLabelAlignVariant0 {
    fn from(value: &AxisLabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisLabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisLabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelAngle> for AxisLabelAngle {
    fn from(value: &AxisLabelAngle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelBaseline {
    Variant0(AxisLabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&AxisLabelBaseline> for AxisLabelBaseline {
    fn from(value: &AxisLabelBaseline) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisLabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&AxisLabelBaselineVariant0> for AxisLabelBaselineVariant0 {
    fn from(value: &AxisLabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisLabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisLabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelBound {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&AxisLabelBound> for AxisLabelBound {
    fn from(value: &AxisLabelBound) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&AxisLabelColor> for AxisLabelColor {
    fn from(value: &AxisLabelColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFlush {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&AxisLabelFlush> for AxisLabelFlush {
    fn from(value: &AxisLabelFlush) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisLabelFont> for AxisLabelFont {
    fn from(value: &AxisLabelFont) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelFontSize> for AxisLabelFontSize {
    fn from(value: &AxisLabelFontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisLabelFontStyle> for AxisLabelFontStyle {
    fn from(value: &AxisLabelFontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&AxisLabelFontWeight> for AxisLabelFontWeight {
    fn from(value: &AxisLabelFontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelLimit> for AxisLabelLimit {
    fn from(value: &AxisLabelLimit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelLineHeight> for AxisLabelLineHeight {
    fn from(value: &AxisLabelLineHeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelOffset> for AxisLabelOffset {
    fn from(value: &AxisLabelOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelOpacity> for AxisLabelOpacity {
    fn from(value: &AxisLabelOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelPadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisLabelPadding> for AxisLabelPadding {
    fn from(value: &AxisLabelPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisMaxExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisMaxExtent> for AxisMaxExtent {
    fn from(value: &AxisMaxExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisMinExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisMinExtent> for AxisMinExtent {
    fn from(value: &AxisMinExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisOffset> for AxisOffset {
    fn from(value: &AxisOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisOrient {
    Variant0(AxisOrientVariant0),
    Variant1(SignalRef),
}
impl From<&AxisOrient> for AxisOrient {
    fn from(value: &AxisOrient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisOrientVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
}
impl From<&AxisOrientVariant0> for AxisOrientVariant0 {
    fn from(value: &AxisOrientVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
        }
    }
}
impl std::str::FromStr for AxisOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisPosition> for AxisPosition {
    fn from(value: &AxisPosition) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisTickCap> for AxisTickCap {
    fn from(value: &AxisTickCap) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&AxisTickColor> for AxisTickColor {
    fn from(value: &AxisTickColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&AxisTickDash> for AxisTickDash {
    fn from(value: &AxisTickDash) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTickDashOffset> for AxisTickDashOffset {
    fn from(value: &AxisTickDashOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTickOffset> for AxisTickOffset {
    fn from(value: &AxisTickOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTickOpacity> for AxisTickOpacity {
    fn from(value: &AxisTickOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickRound {
    Variant0(bool),
    Variant1(BooleanValue),
}
impl From<&AxisTickRound> for AxisTickRound {
    fn from(value: &AxisTickRound) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTickSize> for AxisTickSize {
    fn from(value: &AxisTickSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTickWidth> for AxisTickWidth {
    fn from(value: &AxisTickWidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAlign {
    Variant0(AxisTitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&AxisTitleAlign> for AxisTitleAlign {
    fn from(value: &AxisTitleAlign) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&AxisTitleAlignVariant0> for AxisTitleAlignVariant0 {
    fn from(value: &AxisTitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAnchor {
    Variant0(Option<AxisTitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&AxisTitleAnchor> for AxisTitleAnchor {
    fn from(value: &AxisTitleAnchor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&AxisTitleAnchorVariant0> for AxisTitleAnchorVariant0 {
    fn from(value: &AxisTitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleAngle> for AxisTitleAngle {
    fn from(value: &AxisTitleAngle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleBaseline {
    Variant0(AxisTitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&AxisTitleBaseline> for AxisTitleBaseline {
    fn from(value: &AxisTitleBaseline) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&AxisTitleBaselineVariant0> for AxisTitleBaselineVariant0 {
    fn from(value: &AxisTitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&AxisTitleColor> for AxisTitleColor {
    fn from(value: &AxisTitleColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisTitleFont> for AxisTitleFont {
    fn from(value: &AxisTitleFont) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleFontSize> for AxisTitleFontSize {
    fn from(value: &AxisTitleFontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&AxisTitleFontStyle> for AxisTitleFontStyle {
    fn from(value: &AxisTitleFontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&AxisTitleFontWeight> for AxisTitleFontWeight {
    fn from(value: &AxisTitleFontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleLimit> for AxisTitleLimit {
    fn from(value: &AxisTitleLimit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleLineHeight> for AxisTitleLineHeight {
    fn from(value: &AxisTitleLineHeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleOpacity> for AxisTitleOpacity {
    fn from(value: &AxisTitleOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitlePadding> for AxisTitlePadding {
    fn from(value: &AxisTitlePadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleX> for AxisTitleX {
    fn from(value: &AxisTitleX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTitleY> for AxisTitleY {
    fn from(value: &AxisTitleY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTranslate {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&AxisTranslate> for AxisTranslate {
    fn from(value: &AxisTranslate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Background(pub StringOrSignal);
impl std::ops::Deref for Background {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl From<Background> for StringOrSignal {
    fn from(value: Background) -> Self {
        value.0
    }
}
impl From<&Background> for Background {
    fn from(value: &Background) -> Self {
        value.clone()
    }
}
impl From<StringOrSignal> for Background {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum BaseColorValue {
    Variant0(BaseColorValueVariant0),
    Variant1 {
        value: LinearGradient,
    },
    Variant2 {
        value: RadialGradient,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<f64>,
        gradient: Field,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        start: Vec<f64>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        stop: Vec<f64>,
    },
    Variant4 {
        color: BaseColorValueVariant4Color,
    },
}
impl From<&BaseColorValue> for BaseColorValue {
    fn from(value: &BaseColorValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaseColorValueVariant0 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaseColorValueVariant0Subtype1,
}
impl From<&BaseColorValueVariant0> for BaseColorValueVariant0 {
    fn from(value: &BaseColorValueVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaseColorValueVariant0Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaseColorValueVariant0Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaseColorValueVariant0Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaseColorValueVariant0Subtype1Subtype3>,
}
impl From<&BaseColorValueVariant0Subtype1> for BaseColorValueVariant0Subtype1 {
    fn from(value: &BaseColorValueVariant0Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: Option<String>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaseColorValueVariant0Subtype1Subtype0Variant3Range,
    },
}
impl From<&BaseColorValueVariant0Subtype1Subtype0> for BaseColorValueVariant0Subtype1Subtype0 {
    fn from(value: &BaseColorValueVariant0Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BaseColorValueVariant0Subtype1Subtype0Variant3Range>
    for BaseColorValueVariant0Subtype1Subtype0Variant3Range
{
    fn from(value: &BaseColorValueVariant0Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BaseColorValueVariant0Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype1 {}
impl From<&BaseColorValueVariant0Subtype1Subtype1> for BaseColorValueVariant0Subtype1Subtype1 {
    fn from(value: &BaseColorValueVariant0Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype2 {}
impl From<&BaseColorValueVariant0Subtype1Subtype2> for BaseColorValueVariant0Subtype1Subtype2 {
    fn from(value: &BaseColorValueVariant0Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaseColorValueVariant0Subtype1Subtype3 {}
impl From<&BaseColorValueVariant0Subtype1Subtype3> for BaseColorValueVariant0Subtype1Subtype3 {
    fn from(value: &BaseColorValueVariant0Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant4Color {
    Rgb(ColorRgb),
    Hsl(ColorHsl),
    Lab(ColorLab),
    Hcl(ColorHcl),
}
impl From<&BaseColorValueVariant4Color> for BaseColorValueVariant4Color {
    fn from(value: &BaseColorValueVariant4Color) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValue {
    Variant0(Vec<BaselineValueVariant0Item>),
    Variant1(BaselineValueVariant1),
}
impl From<&BaselineValue> for BaselineValue {
    fn from(value: &BaselineValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant0ItemSubtype1,
}
impl From<&BaselineValueVariant0Item> for BaselineValueVariant0Item {
    fn from(value: &BaselineValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant0ItemSubtype1Subtype1,
}
impl From<&BaselineValueVariant0ItemSubtype1> for BaselineValueVariant0ItemSubtype1 {
    fn from(value: &BaselineValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaselineValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1>
    for BaselineValueVariant0ItemSubtype1Subtype1
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype0>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BaselineValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype1>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype2>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&BaselineValueVariant0ItemSubtype1Subtype1Subtype3>
    for BaselineValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &BaselineValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BaselineValueVariant1Subtype1,
}
impl From<&BaselineValueVariant1> for BaselineValueVariant1 {
    fn from(value: &BaselineValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BaselineValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BaselineValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BaselineValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BaselineValueVariant1Subtype1Subtype3>,
}
impl From<&BaselineValueVariant1Subtype1> for BaselineValueVariant1Subtype1 {
    fn from(value: &BaselineValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: BaselineValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BaselineValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BaselineValueVariant1Subtype1Subtype0> for BaselineValueVariant1Subtype1Subtype0 {
    fn from(value: &BaselineValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BaselineValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl From<&BaselineValueVariant1Subtype1Subtype0Variant1Value>
    for BaselineValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &BaselineValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BaselineValueVariant1Subtype1Subtype0Variant3Range>
    for BaselineValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &BaselineValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaselineValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BaselineValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype1 {}
impl From<&BaselineValueVariant1Subtype1Subtype1> for BaselineValueVariant1Subtype1Subtype1 {
    fn from(value: &BaselineValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype2 {}
impl From<&BaselineValueVariant1Subtype1Subtype2> for BaselineValueVariant1Subtype1Subtype2 {
    fn from(value: &BaselineValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BaselineValueVariant1Subtype1Subtype3 {}
impl From<&BaselineValueVariant1Subtype1Subtype3> for BaselineValueVariant1Subtype1Subtype3 {
    fn from(value: &BaselineValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BinTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anchor: Option<BinTransformAnchor>,
    #[serde(rename = "as", default = "defaults::bin_transform_as")]
    pub as_: BinTransformAs,
    #[serde(default = "defaults::bin_transform_base")]
    pub base: BinTransformBase,
    #[serde(default = "defaults::bin_transform_divide")]
    pub divide: BinTransformDivide,
    pub extent: BinTransformExtent,
    pub field: BinTransformField,
    #[serde(default = "defaults::bin_transform_interval")]
    pub interval: BinTransformInterval,
    #[serde(default = "defaults::bin_transform_maxbins")]
    pub maxbins: BinTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minstep: Option<BinTransformMinstep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<BinTransformName>,
    #[serde(default = "defaults::bin_transform_nice")]
    pub nice: BinTransformNice,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub span: Option<BinTransformSpan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<BinTransformStep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<BinTransformSteps>,
    #[serde(rename = "type")]
    pub type_: BinTransformType,
}
impl From<&BinTransform> for BinTransform {
    fn from(value: &BinTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAnchor {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformAnchor> for BinTransformAnchor {
    fn from(value: &BinTransformAnchor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAs {
    Variant0(BinTransformAsVariant0, BinTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&BinTransformAs> for BinTransformAs {
    fn from(value: &BinTransformAs) -> Self {
        value.clone()
    }
}
impl Default for BinTransformAs {
    fn default() -> Self {
        BinTransformAs::Variant0(
            BinTransformAsVariant0::Variant0("bin0".to_string()),
            BinTransformAsVariant0::Variant0("bin1".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&BinTransformAsVariant0> for BinTransformAsVariant0 {
    fn from(value: &BinTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformBase {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformBase> for BinTransformBase {
    fn from(value: &BinTransformBase) -> Self {
        value.clone()
    }
}
impl Default for BinTransformBase {
    fn default() -> Self {
        BinTransformBase::Variant0(10_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformDivide {
    Variant0(Vec<BinTransformDivideVariant0Item>),
    Variant1(SignalRef),
}
impl From<&BinTransformDivide> for BinTransformDivide {
    fn from(value: &BinTransformDivide) -> Self {
        value.clone()
    }
}
impl Default for BinTransformDivide {
    fn default() -> Self {
        BinTransformDivide::Variant0(vec![
            BinTransformDivideVariant0Item::Variant0(5_f64),
            BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformDivideVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformDivideVariant0Item> for BinTransformDivideVariant0Item {
    fn from(value: &BinTransformDivideVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformExtent {
    Variant0(BinTransformExtentVariant0, BinTransformExtentVariant0),
    Variant1(SignalRef),
}
impl From<&BinTransformExtent> for BinTransformExtent {
    fn from(value: &BinTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformExtentVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformExtentVariant0> for BinTransformExtentVariant0 {
    fn from(value: &BinTransformExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&BinTransformField> for BinTransformField {
    fn from(value: &BinTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&BinTransformInterval> for BinTransformInterval {
    fn from(value: &BinTransformInterval) -> Self {
        value.clone()
    }
}
impl Default for BinTransformInterval {
    fn default() -> Self {
        BinTransformInterval::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformMaxbins> for BinTransformMaxbins {
    fn from(value: &BinTransformMaxbins) -> Self {
        value.clone()
    }
}
impl Default for BinTransformMaxbins {
    fn default() -> Self {
        BinTransformMaxbins::Variant0(20_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformMinstep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformMinstep> for BinTransformMinstep {
    fn from(value: &BinTransformMinstep) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformName {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&BinTransformName> for BinTransformName {
    fn from(value: &BinTransformName) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&BinTransformNice> for BinTransformNice {
    fn from(value: &BinTransformNice) -> Self {
        value.clone()
    }
}
impl Default for BinTransformNice {
    fn default() -> Self {
        BinTransformNice::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformSpan {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformSpan> for BinTransformSpan {
    fn from(value: &BinTransformSpan) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformStep> for BinTransformStep {
    fn from(value: &BinTransformStep) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformSteps {
    Variant0(Vec<BinTransformStepsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&BinTransformSteps> for BinTransformSteps {
    fn from(value: &BinTransformSteps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformStepsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&BinTransformStepsVariant0Item> for BinTransformStepsVariant0Item {
    fn from(value: &BinTransformStepsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BinTransformType {
    #[serde(rename = "bin")]
    Bin,
}
impl From<&BinTransformType> for BinTransformType {
    fn from(value: &BinTransformType) -> Self {
        value.clone()
    }
}
impl ToString for BinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bin => "bin".to_string(),
        }
    }
}
impl std::str::FromStr for BinTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "bin" => Ok(Self::Bin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BinTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BinTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BinTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Bind {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant0Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant1Input,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        labels: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        options: Vec<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant2Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        max: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant3Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        element: Element,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        event: Option<String>,
    },
}
impl From<&Bind> for Bind {
    fn from(value: &Bind) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant0Input {
    #[serde(rename = "checkbox")]
    Checkbox,
}
impl From<&BindVariant0Input> for BindVariant0Input {
    fn from(value: &BindVariant0Input) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant0Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Checkbox => "checkbox".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant0Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "checkbox" => Ok(Self::Checkbox),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant0Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant0Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant0Input {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant1Input {
    #[serde(rename = "radio")]
    Radio,
    #[serde(rename = "select")]
    Select,
}
impl From<&BindVariant1Input> for BindVariant1Input {
    fn from(value: &BindVariant1Input) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant1Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Radio => "radio".to_string(),
            Self::Select => "select".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant1Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "radio" => Ok(Self::Radio),
            "select" => Ok(Self::Select),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant1Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant1Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant1Input {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant2Input {
    #[serde(rename = "range")]
    Range,
}
impl From<&BindVariant2Input> for BindVariant2Input {
    fn from(value: &BindVariant2Input) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant2Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Range => "range".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant2Input {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "range" => Ok(Self::Range),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant2Input {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant2Input {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant2Input {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct BindVariant3Input(String);
impl std::ops::Deref for BindVariant3Input {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<BindVariant3Input> for String {
    fn from(value: BindVariant3Input) -> Self {
        value.0
    }
}
impl From<&BindVariant3Input> for BindVariant3Input {
    fn from(value: &BindVariant3Input) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<String> for BindVariant3Input {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if [
            "checkbox".to_string(),
            "radio".to_string(),
            "range".to_string(),
            "select".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for BindVariant3Input {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(String::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValue {
    Variant0(Vec<BlendValueVariant0Item>),
    Variant1(BlendValueVariant1),
}
impl From<&BlendValue> for BlendValue {
    fn from(value: &BlendValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant0ItemSubtype1,
}
impl From<&BlendValueVariant0Item> for BlendValueVariant0Item {
    fn from(value: &BlendValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant0ItemSubtype1Subtype1,
}
impl From<&BlendValueVariant0ItemSubtype1> for BlendValueVariant0ItemSubtype1 {
    fn from(value: &BlendValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&BlendValueVariant0ItemSubtype1Subtype1> for BlendValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: Option<BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype0>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BlendValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype1>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype2>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&BlendValueVariant0ItemSubtype1Subtype1Subtype3>
    for BlendValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &BlendValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BlendValueVariant1Subtype1,
}
impl From<&BlendValueVariant1> for BlendValueVariant1 {
    fn from(value: &BlendValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BlendValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BlendValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BlendValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BlendValueVariant1Subtype1Subtype3>,
}
impl From<&BlendValueVariant1Subtype1> for BlendValueVariant1Subtype1 {
    fn from(value: &BlendValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: Option<BlendValueVariant1Subtype1Subtype0Variant1Value>,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BlendValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BlendValueVariant1Subtype1Subtype0> for BlendValueVariant1Subtype1Subtype0 {
    fn from(value: &BlendValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BlendValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl From<&BlendValueVariant1Subtype1Subtype0Variant1Value>
    for BlendValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &BlendValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for BlendValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BlendValueVariant1Subtype1Subtype0Variant3Range>
    for BlendValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &BlendValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BlendValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BlendValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype1 {}
impl From<&BlendValueVariant1Subtype1Subtype1> for BlendValueVariant1Subtype1Subtype1 {
    fn from(value: &BlendValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype2 {}
impl From<&BlendValueVariant1Subtype1Subtype2> for BlendValueVariant1Subtype1Subtype2 {
    fn from(value: &BlendValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BlendValueVariant1Subtype1Subtype3 {}
impl From<&BlendValueVariant1Subtype1Subtype3> for BlendValueVariant1Subtype1Subtype3 {
    fn from(value: &BlendValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanOrSignal {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&BooleanOrSignal> for BooleanOrSignal {
    fn from(value: &BooleanOrSignal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValue {
    Variant0(Vec<BooleanValueVariant0Item>),
    Variant1(BooleanValueVariant1),
}
impl From<&BooleanValue> for BooleanValue {
    fn from(value: &BooleanValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant0ItemSubtype1,
}
impl From<&BooleanValueVariant0Item> for BooleanValueVariant0Item {
    fn from(value: &BooleanValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant0ItemSubtype1Subtype1,
}
impl From<&BooleanValueVariant0ItemSubtype1> for BooleanValueVariant0ItemSubtype1 {
    fn from(value: &BooleanValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BooleanValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1> for BooleanValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: bool,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1Subtype0>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BooleanValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1Subtype1>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1Subtype2>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&BooleanValueVariant0ItemSubtype1Subtype1Subtype3>
    for BooleanValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &BooleanValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: BooleanValueVariant1Subtype1,
}
impl From<&BooleanValueVariant1> for BooleanValueVariant1 {
    fn from(value: &BooleanValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<BooleanValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<BooleanValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<BooleanValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<BooleanValueVariant1Subtype1Subtype3>,
}
impl From<&BooleanValueVariant1Subtype1> for BooleanValueVariant1Subtype1 {
    fn from(value: &BooleanValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: bool,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: BooleanValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&BooleanValueVariant1Subtype1Subtype0> for BooleanValueVariant1Subtype1Subtype0 {
    fn from(value: &BooleanValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&BooleanValueVariant1Subtype1Subtype0Variant3Range>
    for BooleanValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &BooleanValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BooleanValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for BooleanValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BooleanValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BooleanValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for BooleanValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype1 {}
impl From<&BooleanValueVariant1Subtype1Subtype1> for BooleanValueVariant1Subtype1Subtype1 {
    fn from(value: &BooleanValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype2 {}
impl From<&BooleanValueVariant1Subtype1Subtype2> for BooleanValueVariant1Subtype1Subtype2 {
    fn from(value: &BooleanValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct BooleanValueVariant1Subtype1Subtype3 {}
impl From<&BooleanValueVariant1Subtype1Subtype3> for BooleanValueVariant1Subtype1Subtype3 {
    fn from(value: &BooleanValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CollectTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: CollectTransformType,
}
impl From<&CollectTransform> for CollectTransform {
    fn from(value: &CollectTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CollectTransformType {
    #[serde(rename = "collect")]
    Collect,
}
impl From<&CollectTransformType> for CollectTransformType {
    fn from(value: &CollectTransformType) -> Self {
        value.clone()
    }
}
impl ToString for CollectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Collect => "collect".to_string(),
        }
    }
}
impl std::str::FromStr for CollectTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "collect" => Ok(Self::Collect),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CollectTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CollectTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CollectTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorHcl {
    pub c: NumberValue,
    pub h: NumberValue,
    pub l: NumberValue,
}
impl From<&ColorHcl> for ColorHcl {
    fn from(value: &ColorHcl) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorHsl {
    pub h: NumberValue,
    pub l: NumberValue,
    pub s: NumberValue,
}
impl From<&ColorHsl> for ColorHsl {
    fn from(value: &ColorHsl) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorLab {
    pub a: NumberValue,
    pub b: NumberValue,
    pub l: NumberValue,
}
impl From<&ColorLab> for ColorLab {
    fn from(value: &ColorLab) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorRgb {
    pub b: NumberValue,
    pub g: NumberValue,
    pub r: NumberValue,
}
impl From<&ColorRgb> for ColorRgb {
    fn from(value: &ColorRgb) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ColorValue {
    Variant0(Vec<ColorValueVariant0Item>),
    Variant1(BaseColorValue),
}
impl From<&ColorValue> for ColorValue {
    fn from(value: &ColorValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: BaseColorValue,
}
impl From<&ColorValueVariant0Item> for ColorValueVariant0Item {
    fn from(value: &ColorValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Compare {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<CompareVariant0Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        field: Vec<CompareVariant1FieldItem>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        order: Vec<SortOrder>,
    },
}
impl From<&Compare> for Compare {
    fn from(value: &Compare) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CompareVariant0Field {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl From<&CompareVariant0Field> for CompareVariant0Field {
    fn from(value: &CompareVariant0Field) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CompareVariant1FieldItem {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl From<&CompareVariant1FieldItem> for CompareVariant1FieldItem {
    fn from(value: &CompareVariant1FieldItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContourTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<ContourTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<ContourTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<ContourTransformCount>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<ContourTransformNice>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: ContourTransformSize,
    #[serde(default = "defaults::contour_transform_smooth")]
    pub smooth: ContourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<ContourTransformThresholds>,
    #[serde(rename = "type")]
    pub type_: ContourTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ContourTransformValues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<ContourTransformWeight>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<ContourTransformX>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<ContourTransformY>,
}
impl From<&ContourTransform> for ContourTransform {
    fn from(value: &ContourTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformBandwidth> for ContourTransformBandwidth {
    fn from(value: &ContourTransformBandwidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformCellSize> for ContourTransformCellSize {
    fn from(value: &ContourTransformCellSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformCount {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformCount> for ContourTransformCount {
    fn from(value: &ContourTransformCount) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&ContourTransformNice> for ContourTransformNice {
    fn from(value: &ContourTransformNice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSize {
    Variant0(ContourTransformSizeVariant0, ContourTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&ContourTransformSize> for ContourTransformSize {
    fn from(value: &ContourTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformSizeVariant0> for ContourTransformSizeVariant0 {
    fn from(value: &ContourTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&ContourTransformSmooth> for ContourTransformSmooth {
    fn from(value: &ContourTransformSmooth) -> Self {
        value.clone()
    }
}
impl Default for ContourTransformSmooth {
    fn default() -> Self {
        ContourTransformSmooth::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformThresholds {
    Variant0(Vec<ContourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ContourTransformThresholds> for ContourTransformThresholds {
    fn from(value: &ContourTransformThresholds) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformThresholdsVariant0Item> for ContourTransformThresholdsVariant0Item {
    fn from(value: &ContourTransformThresholdsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ContourTransformType {
    #[serde(rename = "contour")]
    Contour,
}
impl From<&ContourTransformType> for ContourTransformType {
    fn from(value: &ContourTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ContourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Contour => "contour".to_string(),
        }
    }
}
impl std::str::FromStr for ContourTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "contour" => Ok(Self::Contour),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ContourTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContourTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ContourTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformValues {
    Variant0(Vec<ContourTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ContourTransformValues> for ContourTransformValues {
    fn from(value: &ContourTransformValues) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformValuesVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ContourTransformValuesVariant0Item> for ContourTransformValuesVariant0Item {
    fn from(value: &ContourTransformValuesVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ContourTransformWeight> for ContourTransformWeight {
    fn from(value: &ContourTransformWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ContourTransformX> for ContourTransformX {
    fn from(value: &ContourTransformX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ContourTransformY> for ContourTransformY {
    fn from(value: &ContourTransformY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CountpatternTransform {
    #[serde(rename = "as", default = "defaults::countpattern_transform_as")]
    pub as_: CountpatternTransformAs,
    #[serde(default = "defaults::countpattern_transform_case")]
    pub case: CountpatternTransformCase,
    pub field: CountpatternTransformField,
    #[serde(default = "defaults::countpattern_transform_pattern")]
    pub pattern: CountpatternTransformPattern,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stopwords: Option<CountpatternTransformStopwords>,
    #[serde(rename = "type")]
    pub type_: CountpatternTransformType,
}
impl From<&CountpatternTransform> for CountpatternTransform {
    fn from(value: &CountpatternTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformAs {
    Variant0(
        CountpatternTransformAsVariant0,
        CountpatternTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&CountpatternTransformAs> for CountpatternTransformAs {
    fn from(value: &CountpatternTransformAs) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformAs {
    fn default() -> Self {
        CountpatternTransformAs::Variant0(
            CountpatternTransformAsVariant0::Variant0("text".to_string()),
            CountpatternTransformAsVariant0::Variant0("count".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&CountpatternTransformAsVariant0> for CountpatternTransformAsVariant0 {
    fn from(value: &CountpatternTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformCase {
    Variant0(CountpatternTransformCaseVariant0),
    Variant1(SignalRef),
}
impl From<&CountpatternTransformCase> for CountpatternTransformCase {
    fn from(value: &CountpatternTransformCase) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformCase {
    fn default() -> Self {
        CountpatternTransformCase::Variant0(CountpatternTransformCaseVariant0::Mixed)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CountpatternTransformCaseVariant0 {
    #[serde(rename = "upper")]
    Upper,
    #[serde(rename = "lower")]
    Lower,
    #[serde(rename = "mixed")]
    Mixed,
}
impl From<&CountpatternTransformCaseVariant0> for CountpatternTransformCaseVariant0 {
    fn from(value: &CountpatternTransformCaseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for CountpatternTransformCaseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Upper => "upper".to_string(),
            Self::Lower => "lower".to_string(),
            Self::Mixed => "mixed".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformCaseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "upper" => Ok(Self::Upper),
            "lower" => Ok(Self::Lower),
            "mixed" => Ok(Self::Mixed),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformCaseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformCaseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CountpatternTransformCaseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&CountpatternTransformField> for CountpatternTransformField {
    fn from(value: &CountpatternTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformPattern {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&CountpatternTransformPattern> for CountpatternTransformPattern {
    fn from(value: &CountpatternTransformPattern) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformPattern {
    fn default() -> Self {
        CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformStopwords {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&CountpatternTransformStopwords> for CountpatternTransformStopwords {
    fn from(value: &CountpatternTransformStopwords) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CountpatternTransformType {
    #[serde(rename = "countpattern")]
    Countpattern,
}
impl From<&CountpatternTransformType> for CountpatternTransformType {
    fn from(value: &CountpatternTransformType) -> Self {
        value.clone()
    }
}
impl ToString for CountpatternTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Countpattern => "countpattern".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "countpattern" => Ok(Self::Countpattern),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CountpatternTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossTransform {
    #[serde(rename = "as", default = "defaults::cross_transform_as")]
    pub as_: CrossTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossTransformType,
}
impl From<&CrossTransform> for CrossTransform {
    fn from(value: &CrossTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossTransformAs {
    Variant0(CrossTransformAsVariant0, CrossTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&CrossTransformAs> for CrossTransformAs {
    fn from(value: &CrossTransformAs) -> Self {
        value.clone()
    }
}
impl Default for CrossTransformAs {
    fn default() -> Self {
        CrossTransformAs::Variant0(
            CrossTransformAsVariant0::Variant0("a".to_string()),
            CrossTransformAsVariant0::Variant0("b".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&CrossTransformAsVariant0> for CrossTransformAsVariant0 {
    fn from(value: &CrossTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CrossTransformType {
    #[serde(rename = "cross")]
    Cross,
}
impl From<&CrossTransformType> for CrossTransformType {
    fn from(value: &CrossTransformType) -> Self {
        value.clone()
    }
}
impl ToString for CrossTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Cross => "cross".to_string(),
        }
    }
}
impl std::str::FromStr for CrossTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "cross" => Ok(Self::Cross),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CrossTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossfilterTransform {
    pub fields: CrossfilterTransformFields,
    pub query: CrossfilterTransformQuery,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossfilterTransformType,
}
impl From<&CrossfilterTransform> for CrossfilterTransform {
    fn from(value: &CrossfilterTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformFields {
    Variant0(Vec<CrossfilterTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&CrossfilterTransformFields> for CrossfilterTransformFields {
    fn from(value: &CrossfilterTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&CrossfilterTransformFieldsVariant0Item> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: &CrossfilterTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformQuery {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&CrossfilterTransformQuery> for CrossfilterTransformQuery {
    fn from(value: &CrossfilterTransformQuery) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CrossfilterTransformType {
    #[serde(rename = "crossfilter")]
    Crossfilter,
}
impl From<&CrossfilterTransformType> for CrossfilterTransformType {
    fn from(value: &CrossfilterTransformType) -> Self {
        value.clone()
    }
}
impl ToString for CrossfilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Crossfilter => "crossfilter".to_string(),
        }
    }
}
impl std::str::FromStr for CrossfilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "crossfilter" => Ok(Self::Crossfilter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossfilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossfilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CrossfilterTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Data {
    Variant0 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant1 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        source: DataVariant1Source,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant2 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant2Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        url: StringOrSignal,
    },
    Variant3 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant3Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        values: DataVariant3Values,
    },
}
impl From<&Data> for Data {
    fn from(value: &Data) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant1Source {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&DataVariant1Source> for DataVariant1Source {
    fn from(value: &DataVariant1Source) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2Format {
    Variant0(DataVariant2FormatVariant0),
    Variant1(SignalRef),
}
impl From<&DataVariant2Format> for DataVariant2Format {
    fn from(value: &DataVariant2Format) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant2FormatVariant0 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DataVariant2FormatVariant0Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DataVariant2FormatVariant0Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DataVariant2FormatVariant0Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DataVariant2FormatVariant0Subtype3>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_4: Option<DataVariant2FormatVariant0Subtype4>,
}
impl From<&DataVariant2FormatVariant0> for DataVariant2FormatVariant0 {
    fn from(value: &DataVariant2FormatVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&DataVariant2FormatVariant0Subtype0> for DataVariant2FormatVariant0Subtype0 {
    fn from(value: &DataVariant2FormatVariant0Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype0Parse {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant2FormatVariant0Subtype0Parse> for DataVariant2FormatVariant0Subtype0Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype0Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant2FormatVariant0Subtype0ParseVariant0>
    for DataVariant2FormatVariant0Subtype0ParseVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant2FormatVariant0Subtype1Type>,
}
impl From<&DataVariant2FormatVariant0Subtype1> for DataVariant2FormatVariant0Subtype1 {
    fn from(value: &DataVariant2FormatVariant0Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype1Parse {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant2FormatVariant0Subtype1Parse> for DataVariant2FormatVariant0Subtype1Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype1Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant2FormatVariant0Subtype1ParseVariant0>
    for DataVariant2FormatVariant0Subtype1ParseVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl From<&DataVariant2FormatVariant0Subtype1Type> for DataVariant2FormatVariant0Subtype1Type {
    fn from(value: &DataVariant2FormatVariant0Subtype1Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype2Type,
}
impl From<&DataVariant2FormatVariant0Subtype2> for DataVariant2FormatVariant0Subtype2 {
    fn from(value: &DataVariant2FormatVariant0Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype2Parse {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant2FormatVariant0Subtype2Parse> for DataVariant2FormatVariant0Subtype2Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype2Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant2FormatVariant0Subtype2ParseVariant0>
    for DataVariant2FormatVariant0Subtype2ParseVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl From<&DataVariant2FormatVariant0Subtype2Type> for DataVariant2FormatVariant0Subtype2Type {
    fn from(value: &DataVariant2FormatVariant0Subtype2Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype3Type,
}
impl From<&DataVariant2FormatVariant0Subtype3> for DataVariant2FormatVariant0Subtype3 {
    fn from(value: &DataVariant2FormatVariant0Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype3Parse {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant2FormatVariant0Subtype3Parse> for DataVariant2FormatVariant0Subtype3Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype3Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant2FormatVariant0Subtype3ParseVariant0>
    for DataVariant2FormatVariant0Subtype3ParseVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl From<&DataVariant2FormatVariant0Subtype3Type> for DataVariant2FormatVariant0Subtype3Type {
    fn from(value: &DataVariant2FormatVariant0Subtype3Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant2FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant1Type,
    },
}
impl From<&DataVariant2FormatVariant0Subtype4> for DataVariant2FormatVariant0Subtype4 {
    fn from(value: &DataVariant2FormatVariant0Subtype4) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&DataVariant2FormatVariant0Subtype4Variant0Type>
    for DataVariant2FormatVariant0Subtype4Variant0Type
{
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant0Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl From<&DataVariant2FormatVariant0Subtype4Variant1Filter>
    for DataVariant2FormatVariant0Subtype4Variant1Filter
{
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant1Filter) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&DataVariant2FormatVariant0Subtype4Variant1Type>
    for DataVariant2FormatVariant0Subtype4Variant1Type
{
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant1Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3Format {
    Variant0(DataVariant3FormatVariant0),
    Variant1(SignalRef),
}
impl From<&DataVariant3Format> for DataVariant3Format {
    fn from(value: &DataVariant3Format) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant3FormatVariant0 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DataVariant3FormatVariant0Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DataVariant3FormatVariant0Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DataVariant3FormatVariant0Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DataVariant3FormatVariant0Subtype3>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_4: Option<DataVariant3FormatVariant0Subtype4>,
}
impl From<&DataVariant3FormatVariant0> for DataVariant3FormatVariant0 {
    fn from(value: &DataVariant3FormatVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&DataVariant3FormatVariant0Subtype0> for DataVariant3FormatVariant0Subtype0 {
    fn from(value: &DataVariant3FormatVariant0Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype0Parse {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant3FormatVariant0Subtype0Parse> for DataVariant3FormatVariant0Subtype0Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype0Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant3FormatVariant0Subtype0ParseVariant0>
    for DataVariant3FormatVariant0Subtype0ParseVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant3FormatVariant0Subtype1Type>,
}
impl From<&DataVariant3FormatVariant0Subtype1> for DataVariant3FormatVariant0Subtype1 {
    fn from(value: &DataVariant3FormatVariant0Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype1Parse {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant3FormatVariant0Subtype1Parse> for DataVariant3FormatVariant0Subtype1Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype1Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant3FormatVariant0Subtype1ParseVariant0>
    for DataVariant3FormatVariant0Subtype1ParseVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl From<&DataVariant3FormatVariant0Subtype1Type> for DataVariant3FormatVariant0Subtype1Type {
    fn from(value: &DataVariant3FormatVariant0Subtype1Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype2Type,
}
impl From<&DataVariant3FormatVariant0Subtype2> for DataVariant3FormatVariant0Subtype2 {
    fn from(value: &DataVariant3FormatVariant0Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype2Parse {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant3FormatVariant0Subtype2Parse> for DataVariant3FormatVariant0Subtype2Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype2Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant3FormatVariant0Subtype2ParseVariant0>
    for DataVariant3FormatVariant0Subtype2ParseVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl From<&DataVariant3FormatVariant0Subtype2Type> for DataVariant3FormatVariant0Subtype2Type {
    fn from(value: &DataVariant3FormatVariant0Subtype2Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype3Type,
}
impl From<&DataVariant3FormatVariant0Subtype3> for DataVariant3FormatVariant0Subtype3 {
    fn from(value: &DataVariant3FormatVariant0Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype3Parse {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant0),
    Variant1 {
        #[serde(flatten)]
        extra: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra,
        >,
    },
    Variant2(SignalRef),
}
impl From<&DataVariant3FormatVariant0Subtype3Parse> for DataVariant3FormatVariant0Subtype3Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype3Parse) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&DataVariant3FormatVariant0Subtype3ParseVariant0>
    for DataVariant3FormatVariant0Subtype3ParseVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0),
    Variant1(DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1),
}
impl From<&DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra
{
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtra {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant0
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1) -> Self {
        value.0
    }
}
impl From<&DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"");
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ExtraExtraVariant1
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl From<&DataVariant3FormatVariant0Subtype3Type> for DataVariant3FormatVariant0Subtype3Type {
    fn from(value: &DataVariant3FormatVariant0Subtype3Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant3FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant1Type,
    },
}
impl From<&DataVariant3FormatVariant0Subtype4> for DataVariant3FormatVariant0Subtype4 {
    fn from(value: &DataVariant3FormatVariant0Subtype4) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&DataVariant3FormatVariant0Subtype4Variant0Type>
    for DataVariant3FormatVariant0Subtype4Variant0Type
{
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant0Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl From<&DataVariant3FormatVariant0Subtype4Variant1Filter>
    for DataVariant3FormatVariant0Subtype4Variant1Filter
{
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant1Filter) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&DataVariant3FormatVariant0Subtype4Variant1Type>
    for DataVariant3FormatVariant0Subtype4Variant1Type
{
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant1Type) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3Values {
    Variant0(serde_json::Value),
    Variant1(SignalRef),
}
impl From<&DataVariant3Values> for DataVariant3Values {
    fn from(value: &DataVariant3Values) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DensityTransform {
    #[serde(rename = "as", default = "defaults::density_transform_as")]
    pub as_: DensityTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<DensityTransformDistribution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<DensityTransformExtent>,
    #[serde(default = "defaults::density_transform_maxsteps")]
    pub maxsteps: DensityTransformMaxsteps,
    #[serde(default = "defaults::density_transform_method")]
    pub method: DensityTransformMethod,
    #[serde(default = "defaults::density_transform_minsteps")]
    pub minsteps: DensityTransformMinsteps,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<DensityTransformSteps>,
    #[serde(rename = "type")]
    pub type_: DensityTransformType,
}
impl From<&DensityTransform> for DensityTransform {
    fn from(value: &DensityTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformAs {
    Variant0(Vec<DensityTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&DensityTransformAs> for DensityTransformAs {
    fn from(value: &DensityTransformAs) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformAs {
    fn default() -> Self {
        DensityTransformAs::Variant0(vec![
            DensityTransformAsVariant0Item::Variant0("value".to_string()),
            DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&DensityTransformAsVariant0Item> for DensityTransformAsVariant0Item {
    fn from(value: &DensityTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DensityTransformDistribution {
    Variant0 {
        function: DensityTransformDistributionVariant0Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionVariant0Mean>,
        #[serde(default = "defaults::density_transform_distribution_variant0_stdev")]
        stdev: DensityTransformDistributionVariant0Stdev,
    },
    Variant1 {
        function: DensityTransformDistributionVariant1Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionVariant1Mean>,
        #[serde(default = "defaults::density_transform_distribution_variant1_stdev")]
        stdev: DensityTransformDistributionVariant1Stdev,
    },
    Variant2 {
        function: DensityTransformDistributionVariant2Function,
        #[serde(default = "defaults::density_transform_distribution_variant2_max")]
        max: DensityTransformDistributionVariant2Max,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<DensityTransformDistributionVariant2Min>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bandwidth: Option<DensityTransformDistributionVariant3Bandwidth>,
        field: DensityTransformDistributionVariant3Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        from: Option<String>,
        function: DensityTransformDistributionVariant3Function,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        distributions: Option<DensityTransformDistributionVariant4Distributions>,
        function: DensityTransformDistributionVariant4Function,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        weights: Option<DensityTransformDistributionVariant4Weights>,
    },
}
impl From<&DensityTransformDistribution> for DensityTransformDistribution {
    fn from(value: &DensityTransformDistribution) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformDistributionVariant0Function {
    #[serde(rename = "normal")]
    Normal,
}
impl From<&DensityTransformDistributionVariant0Function>
    for DensityTransformDistributionVariant0Function
{
    fn from(value: &DensityTransformDistributionVariant0Function) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformDistributionVariant0Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Normal => "normal".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant0Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "normal" => Ok(Self::Normal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant0Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant0Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformDistributionVariant0Function {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant0Mean {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant0Mean> for DensityTransformDistributionVariant0Mean {
    fn from(value: &DensityTransformDistributionVariant0Mean) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant0Stdev {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant0Stdev>
    for DensityTransformDistributionVariant0Stdev
{
    fn from(value: &DensityTransformDistributionVariant0Stdev) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformDistributionVariant0Stdev {
    fn default() -> Self {
        DensityTransformDistributionVariant0Stdev::Variant0(1_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformDistributionVariant1Function {
    #[serde(rename = "lognormal")]
    Lognormal,
}
impl From<&DensityTransformDistributionVariant1Function>
    for DensityTransformDistributionVariant1Function
{
    fn from(value: &DensityTransformDistributionVariant1Function) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformDistributionVariant1Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Lognormal => "lognormal".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant1Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "lognormal" => Ok(Self::Lognormal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant1Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant1Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformDistributionVariant1Function {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant1Mean {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant1Mean> for DensityTransformDistributionVariant1Mean {
    fn from(value: &DensityTransformDistributionVariant1Mean) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant1Stdev {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant1Stdev>
    for DensityTransformDistributionVariant1Stdev
{
    fn from(value: &DensityTransformDistributionVariant1Stdev) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformDistributionVariant1Stdev {
    fn default() -> Self {
        DensityTransformDistributionVariant1Stdev::Variant0(1_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformDistributionVariant2Function {
    #[serde(rename = "uniform")]
    Uniform,
}
impl From<&DensityTransformDistributionVariant2Function>
    for DensityTransformDistributionVariant2Function
{
    fn from(value: &DensityTransformDistributionVariant2Function) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformDistributionVariant2Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Uniform => "uniform".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant2Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "uniform" => Ok(Self::Uniform),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant2Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant2Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformDistributionVariant2Function {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant2Max {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant2Max> for DensityTransformDistributionVariant2Max {
    fn from(value: &DensityTransformDistributionVariant2Max) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformDistributionVariant2Max {
    fn default() -> Self {
        DensityTransformDistributionVariant2Max::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant2Min {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant2Min> for DensityTransformDistributionVariant2Min {
    fn from(value: &DensityTransformDistributionVariant2Min) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant3Bandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant3Bandwidth>
    for DensityTransformDistributionVariant3Bandwidth
{
    fn from(value: &DensityTransformDistributionVariant3Bandwidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant3Field {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&DensityTransformDistributionVariant3Field>
    for DensityTransformDistributionVariant3Field
{
    fn from(value: &DensityTransformDistributionVariant3Field) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformDistributionVariant3Function {
    #[serde(rename = "kde")]
    Kde,
}
impl From<&DensityTransformDistributionVariant3Function>
    for DensityTransformDistributionVariant3Function
{
    fn from(value: &DensityTransformDistributionVariant3Function) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformDistributionVariant3Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde => "kde".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant3Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant3Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant3Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformDistributionVariant3Function {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4Distributions {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant4Distributions>
    for DensityTransformDistributionVariant4Distributions
{
    fn from(value: &DensityTransformDistributionVariant4Distributions) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformDistributionVariant4Function {
    #[serde(rename = "mixture")]
    Mixture,
}
impl From<&DensityTransformDistributionVariant4Function>
    for DensityTransformDistributionVariant4Function
{
    fn from(value: &DensityTransformDistributionVariant4Function) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformDistributionVariant4Function {
    fn to_string(&self) -> String {
        match *self {
            Self::Mixture => "mixture".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformDistributionVariant4Function {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "mixture" => Ok(Self::Mixture),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformDistributionVariant4Function {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformDistributionVariant4Function {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformDistributionVariant4Function {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4Weights {
    Variant0(Vec<DensityTransformDistributionVariant4WeightsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant4Weights>
    for DensityTransformDistributionVariant4Weights
{
    fn from(value: &DensityTransformDistributionVariant4Weights) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionVariant4WeightsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformDistributionVariant4WeightsVariant0Item>
    for DensityTransformDistributionVariant4WeightsVariant0Item
{
    fn from(value: &DensityTransformDistributionVariant4WeightsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformExtent {
    Variant0(
        DensityTransformExtentVariant0,
        DensityTransformExtentVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&DensityTransformExtent> for DensityTransformExtent {
    fn from(value: &DensityTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformExtentVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformExtentVariant0> for DensityTransformExtentVariant0 {
    fn from(value: &DensityTransformExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformMaxsteps> for DensityTransformMaxsteps {
    fn from(value: &DensityTransformMaxsteps) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMaxsteps {
    fn default() -> Self {
        DensityTransformMaxsteps::Variant0(200_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&DensityTransformMethod> for DensityTransformMethod {
    fn from(value: &DensityTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMethod {
    fn default() -> Self {
        DensityTransformMethod::Variant0("pdf".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformMinsteps> for DensityTransformMinsteps {
    fn from(value: &DensityTransformMinsteps) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMinsteps {
    fn default() -> Self {
        DensityTransformMinsteps::Variant0(25_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DensityTransformSteps> for DensityTransformSteps {
    fn from(value: &DensityTransformSteps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformType {
    #[serde(rename = "density")]
    Density,
}
impl From<&DensityTransformType> for DensityTransformType {
    fn from(value: &DensityTransformType) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Density => "density".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "density" => Ok(Self::Density),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValue {
    Variant0(Vec<DirectionValueVariant0Item>),
    Variant1(DirectionValueVariant1),
}
impl From<&DirectionValue> for DirectionValue {
    fn from(value: &DirectionValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant0ItemSubtype1,
}
impl From<&DirectionValueVariant0Item> for DirectionValueVariant0Item {
    fn from(value: &DirectionValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant0ItemSubtype1Subtype1,
}
impl From<&DirectionValueVariant0ItemSubtype1> for DirectionValueVariant0ItemSubtype1 {
    fn from(value: &DirectionValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DirectionValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1>
    for DirectionValueVariant0ItemSubtype1Subtype1
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype0>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DirectionValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype1>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype2>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&DirectionValueVariant0ItemSubtype1Subtype1Subtype3>
    for DirectionValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &DirectionValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: DirectionValueVariant1Subtype1,
}
impl From<&DirectionValueVariant1> for DirectionValueVariant1 {
    fn from(value: &DirectionValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<DirectionValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<DirectionValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<DirectionValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<DirectionValueVariant1Subtype1Subtype3>,
}
impl From<&DirectionValueVariant1Subtype1> for DirectionValueVariant1Subtype1 {
    fn from(value: &DirectionValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: DirectionValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: DirectionValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&DirectionValueVariant1Subtype1Subtype0> for DirectionValueVariant1Subtype1Subtype0 {
    fn from(value: &DirectionValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DirectionValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl From<&DirectionValueVariant1Subtype1Subtype0Variant1Value>
    for DirectionValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &DirectionValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&DirectionValueVariant1Subtype1Subtype0Variant3Range>
    for DirectionValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &DirectionValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DirectionValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for DirectionValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype1 {}
impl From<&DirectionValueVariant1Subtype1Subtype1> for DirectionValueVariant1Subtype1Subtype1 {
    fn from(value: &DirectionValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype2 {}
impl From<&DirectionValueVariant1Subtype1Subtype2> for DirectionValueVariant1Subtype1Subtype2 {
    fn from(value: &DirectionValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DirectionValueVariant1Subtype1Subtype3 {}
impl From<&DirectionValueVariant1Subtype1Subtype3> for DirectionValueVariant1Subtype1Subtype3 {
    fn from(value: &DirectionValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DotbinTransform {
    #[serde(rename = "as", default = "defaults::dotbin_transform_as")]
    pub as_: DotbinTransformAs,
    pub field: DotbinTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<DotbinTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<DotbinTransformSmooth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<DotbinTransformStep>,
    #[serde(rename = "type")]
    pub type_: DotbinTransformType,
}
impl From<&DotbinTransform> for DotbinTransform {
    fn from(value: &DotbinTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&DotbinTransformAs> for DotbinTransformAs {
    fn from(value: &DotbinTransformAs) -> Self {
        value.clone()
    }
}
impl Default for DotbinTransformAs {
    fn default() -> Self {
        DotbinTransformAs::Variant0("bin".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&DotbinTransformField> for DotbinTransformField {
    fn from(value: &DotbinTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformGroupby {
    Variant0(Vec<DotbinTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&DotbinTransformGroupby> for DotbinTransformGroupby {
    fn from(value: &DotbinTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&DotbinTransformGroupbyVariant0Item> for DotbinTransformGroupbyVariant0Item {
    fn from(value: &DotbinTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&DotbinTransformSmooth> for DotbinTransformSmooth {
    fn from(value: &DotbinTransformSmooth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&DotbinTransformStep> for DotbinTransformStep {
    fn from(value: &DotbinTransformStep) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DotbinTransformType {
    #[serde(rename = "dotbin")]
    Dotbin,
}
impl From<&DotbinTransformType> for DotbinTransformType {
    fn from(value: &DotbinTransformType) -> Self {
        value.clone()
    }
}
impl ToString for DotbinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Dotbin => "dotbin".to_string(),
        }
    }
}
impl std::str::FromStr for DotbinTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "dotbin" => Ok(Self::Dotbin),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for DotbinTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DotbinTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DotbinTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Element(pub String);
impl std::ops::Deref for Element {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Element> for String {
    fn from(value: Element) -> Self {
        value.0
    }
}
impl From<&Element> for Element {
    fn from(value: &Element) -> Self {
        value.clone()
    }
}
impl From<String> for Element {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Element {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Element {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Encode {}
impl From<&Encode> for Encode {
    fn from(value: &Encode) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct EncodeEntry {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub align: Option<AlignValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<BooleanValue>,
    #[serde(rename = "ariaRole", default, skip_serializing_if = "Option::is_none")]
    pub aria_role: Option<StringValue>,
    #[serde(
        rename = "ariaRoleDescription",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub aria_role_description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aspect: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub baseline: Option<BaselineValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blend: Option<BlendValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<BooleanValue>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_right: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_right: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cursor: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defined: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dir: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dx: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dy: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ellipsis: Option<StringValue>,
    #[serde(rename = "endAngle", default, skip_serializing_if = "Option::is_none")]
    pub end_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fill: Option<ColorValue>,
    #[serde(
        rename = "fillOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fill_opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub font: Option<StringValue>,
    #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
    pub font_size: Option<NumberValue>,
    #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
    pub font_style: Option<StringValue>,
    #[serde(
        rename = "fontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub font_weight: Option<FontWeightValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberValue>,
    #[serde(
        rename = "innerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub inner_radius: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpolate: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<NumberValue>,
    #[serde(rename = "lineBreak", default, skip_serializing_if = "Option::is_none")]
    pub line_break: Option<StringValue>,
    #[serde(
        rename = "lineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub line_height: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub orient: Option<DirectionValue>,
    #[serde(
        rename = "outerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub outer_radius: Option<NumberValue>,
    #[serde(rename = "padAngle", default, skip_serializing_if = "Option::is_none")]
    pub pad_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<NumberValue>,
    #[serde(rename = "scaleX", default, skip_serializing_if = "Option::is_none")]
    pub scale_x: Option<NumberValue>,
    #[serde(rename = "scaleY", default, skip_serializing_if = "Option::is_none")]
    pub scale_y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shape: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<BooleanValue>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stroke: Option<ColorValue>,
    #[serde(rename = "strokeCap", default, skip_serializing_if = "Option::is_none")]
    pub stroke_cap: Option<StrokeCapValue>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash: Option<ArrayValue>,
    #[serde(
        rename = "strokeDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeForeground",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_foreground: Option<BooleanValue>,
    #[serde(
        rename = "strokeJoin",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_join: Option<StrokeJoinValue>,
    #[serde(
        rename = "strokeMiterLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_miter_limit: Option<NumberValue>,
    #[serde(
        rename = "strokeOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_opacity: Option<NumberValue>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tension: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<TextValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub theta: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tooltip: Option<AnyValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<NumberValue>,
}
impl From<&EncodeEntry> for EncodeEntry {
    fn from(value: &EncodeEntry) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Everything {
    #[serde(flatten)]
    pub subtype_0: Scope,
    #[serde(flatten)]
    pub subtype_1: EverythingSubtype1,
}
impl From<&Everything> for Everything {
    fn from(value: &Everything) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct EverythingSubtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autosize: Option<Autosize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<Background>,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub config: serde_json::Map<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<Padding>,
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberOrSignal>,
}
impl From<&EverythingSubtype1> for EverythingSubtype1 {
    fn from(value: &EverythingSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Expr {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub expr: String,
}
impl From<&Expr> for Expr {
    fn from(value: &Expr) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExprString(pub String);
impl std::ops::Deref for ExprString {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<ExprString> for String {
    fn from(value: ExprString) -> Self {
        value.0
    }
}
impl From<&ExprString> for ExprString {
    fn from(value: &ExprString) -> Self {
        value.clone()
    }
}
impl From<String> for ExprString {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for ExprString {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for ExprString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ExtentTransform {
    pub field: ExtentTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ExtentTransformType,
}
impl From<&ExtentTransform> for ExtentTransform {
    fn from(value: &ExtentTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ExtentTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ExtentTransformField> for ExtentTransformField {
    fn from(value: &ExtentTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ExtentTransformType {
    #[serde(rename = "extent")]
    Extent,
}
impl From<&ExtentTransformType> for ExtentTransformType {
    fn from(value: &ExtentTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ExtentTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for ExtentTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ExtentTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ExtentTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ExtentTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Facet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    pub facet: FacetFacet,
}
impl From<&Facet> for Facet {
    fn from(value: &Facet) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum FacetFacet {
    Variant0 {
        data: String,
        field: String,
        name: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aggregate: Option<FacetFacetVariant1Aggregate>,
        data: String,
        groupby: FacetFacetVariant1Groupby,
        name: String,
    },
}
impl From<&FacetFacet> for FacetFacet {
    fn from(value: &FacetFacet) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FacetFacetVariant1Aggregate {
    #[serde(rename = "as", default, skip_serializing_if = "Vec::is_empty")]
    pub as_: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<bool>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub fields: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ops: Vec<String>,
}
impl From<&FacetFacetVariant1Aggregate> for FacetFacetVariant1Aggregate {
    fn from(value: &FacetFacetVariant1Aggregate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FacetFacetVariant1Groupby {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&FacetFacetVariant1Groupby> for FacetFacetVariant1Groupby {
    fn from(value: &FacetFacetVariant1Groupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Field {
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        datum: Box<Field>,
    },
    Variant3 {
        group: Box<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
        parent: Box<Field>,
    },
}
impl From<&Field> for Field {
    fn from(value: &Field) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FilterTransform {
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FilterTransformType,
}
impl From<&FilterTransform> for FilterTransform {
    fn from(value: &FilterTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FilterTransformType {
    #[serde(rename = "filter")]
    Filter,
}
impl From<&FilterTransformType> for FilterTransformType {
    fn from(value: &FilterTransformType) -> Self {
        value.clone()
    }
}
impl ToString for FilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Filter => "filter".to_string(),
        }
    }
}
impl std::str::FromStr for FilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "filter" => Ok(Self::Filter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FilterTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FlattenTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<FlattenTransformAs>,
    pub fields: FlattenTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<FlattenTransformIndex>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FlattenTransformType,
}
impl From<&FlattenTransform> for FlattenTransform {
    fn from(value: &FlattenTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformAs {
    Variant0(Vec<FlattenTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&FlattenTransformAs> for FlattenTransformAs {
    fn from(value: &FlattenTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&FlattenTransformAsVariant0Item> for FlattenTransformAsVariant0Item {
    fn from(value: &FlattenTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformFields {
    Variant0(Vec<FlattenTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&FlattenTransformFields> for FlattenTransformFields {
    fn from(value: &FlattenTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&FlattenTransformFieldsVariant0Item> for FlattenTransformFieldsVariant0Item {
    fn from(value: &FlattenTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformIndex {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&FlattenTransformIndex> for FlattenTransformIndex {
    fn from(value: &FlattenTransformIndex) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FlattenTransformType {
    #[serde(rename = "flatten")]
    Flatten,
}
impl From<&FlattenTransformType> for FlattenTransformType {
    fn from(value: &FlattenTransformType) -> Self {
        value.clone()
    }
}
impl ToString for FlattenTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Flatten => "flatten".to_string(),
        }
    }
}
impl std::str::FromStr for FlattenTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "flatten" => Ok(Self::Flatten),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FlattenTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FlattenTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FlattenTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FoldTransform {
    #[serde(rename = "as", default = "defaults::fold_transform_as")]
    pub as_: FoldTransformAs,
    pub fields: FoldTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FoldTransformType,
}
impl From<&FoldTransform> for FoldTransform {
    fn from(value: &FoldTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformAs {
    Variant0(FoldTransformAsVariant0, FoldTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&FoldTransformAs> for FoldTransformAs {
    fn from(value: &FoldTransformAs) -> Self {
        value.clone()
    }
}
impl Default for FoldTransformAs {
    fn default() -> Self {
        FoldTransformAs::Variant0(
            FoldTransformAsVariant0::Variant0("key".to_string()),
            FoldTransformAsVariant0::Variant0("value".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&FoldTransformAsVariant0> for FoldTransformAsVariant0 {
    fn from(value: &FoldTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformFields {
    Variant0(Vec<FoldTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&FoldTransformFields> for FoldTransformFields {
    fn from(value: &FoldTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&FoldTransformFieldsVariant0Item> for FoldTransformFieldsVariant0Item {
    fn from(value: &FoldTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FoldTransformType {
    #[serde(rename = "fold")]
    Fold,
}
impl From<&FoldTransformType> for FoldTransformType {
    fn from(value: &FoldTransformType) -> Self {
        value.clone()
    }
}
impl ToString for FoldTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Fold => "fold".to_string(),
        }
    }
}
impl std::str::FromStr for FoldTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "fold" => Ok(Self::Fold),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FoldTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FoldTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FoldTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValue {
    Variant0(Vec<FontWeightValueVariant0Item>),
    Variant1(FontWeightValueVariant1),
}
impl From<&FontWeightValue> for FontWeightValue {
    fn from(value: &FontWeightValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant0ItemSubtype1,
}
impl From<&FontWeightValueVariant0Item> for FontWeightValueVariant0Item {
    fn from(value: &FontWeightValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant0ItemSubtype1Subtype1,
}
impl From<&FontWeightValueVariant0ItemSubtype1> for FontWeightValueVariant0ItemSubtype1 {
    fn from(value: &FontWeightValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<FontWeightValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1>
    for FontWeightValueVariant0ItemSubtype1Subtype1
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: MyEnum,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1Subtype0>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for FontWeightValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1Subtype1>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1Subtype2>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&FontWeightValueVariant0ItemSubtype1Subtype1Subtype3>
    for FontWeightValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &FontWeightValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: FontWeightValueVariant1Subtype1,
}
impl From<&FontWeightValueVariant1> for FontWeightValueVariant1 {
    fn from(value: &FontWeightValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<FontWeightValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<FontWeightValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<FontWeightValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<FontWeightValueVariant1Subtype1Subtype3>,
}
impl From<&FontWeightValueVariant1Subtype1> for FontWeightValueVariant1Subtype1 {
    fn from(value: &FontWeightValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: MyEnum,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: FontWeightValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&FontWeightValueVariant1Subtype1Subtype0> for FontWeightValueVariant1Subtype1Subtype0 {
    fn from(value: &FontWeightValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&FontWeightValueVariant1Subtype1Subtype0Variant3Range>
    for FontWeightValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &FontWeightValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for FontWeightValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype1 {}
impl From<&FontWeightValueVariant1Subtype1Subtype1> for FontWeightValueVariant1Subtype1Subtype1 {
    fn from(value: &FontWeightValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype2 {}
impl From<&FontWeightValueVariant1Subtype1Subtype2> for FontWeightValueVariant1Subtype1Subtype2 {
    fn from(value: &FontWeightValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct FontWeightValueVariant1Subtype1Subtype3 {}
impl From<&FontWeightValueVariant1Subtype1Subtype3> for FontWeightValueVariant1Subtype1Subtype3 {
    fn from(value: &FontWeightValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForceTransform {
    #[serde(default = "defaults::force_transform_alpha")]
    pub alpha: ForceTransformAlpha,
    #[serde(rename = "alphaMin", default = "defaults::force_transform_alpha_min")]
    pub alpha_min: ForceTransformAlphaMin,
    #[serde(
        rename = "alphaTarget",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub alpha_target: Option<ForceTransformAlphaTarget>,
    #[serde(rename = "as", default = "defaults::force_transform_as")]
    pub as_: ForceTransformAs,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub forces: Vec<ForceTransformForcesItem>,
    #[serde(default = "defaults::force_transform_iterations")]
    pub iterations: ForceTransformIterations,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<ForceTransformRestart>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "static", default, skip_serializing_if = "Option::is_none")]
    pub static_: Option<ForceTransformStatic>,
    #[serde(rename = "type")]
    pub type_: ForceTransformType,
    #[serde(
        rename = "velocityDecay",
        default = "defaults::force_transform_velocity_decay"
    )]
    pub velocity_decay: ForceTransformVelocityDecay,
}
impl From<&ForceTransform> for ForceTransform {
    fn from(value: &ForceTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlpha {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformAlpha> for ForceTransformAlpha {
    fn from(value: &ForceTransformAlpha) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAlpha {
    fn default() -> Self {
        ForceTransformAlpha::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlphaMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformAlphaMin> for ForceTransformAlphaMin {
    fn from(value: &ForceTransformAlphaMin) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAlphaMin {
    fn default() -> Self {
        ForceTransformAlphaMin::Variant0(0.001_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlphaTarget {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformAlphaTarget> for ForceTransformAlphaTarget {
    fn from(value: &ForceTransformAlphaTarget) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAs {
    Variant0(Vec<ForceTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ForceTransformAs> for ForceTransformAs {
    fn from(value: &ForceTransformAs) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAs {
    fn default() -> Self {
        ForceTransformAs::Variant0(vec![
            ForceTransformAsVariant0Item::Variant0("x".to_string()),
            ForceTransformAsVariant0Item::Variant0("y".to_string()),
            ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ForceTransformAsVariant0Item> for ForceTransformAsVariant0Item {
    fn from(value: &ForceTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ForceTransformForcesItem {
    Variant0 {
        force: ForceTransformForcesItemVariant0Force,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemVariant0X>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemVariant0Y>,
    },
    Variant1 {
        force: ForceTransformForcesItemVariant1Force,
        #[serde(default = "defaults::force_transform_forces_item_variant1_iterations")]
        iterations: ForceTransformForcesItemVariant1Iterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        radius: Option<ForceTransformForcesItemVariant1Radius>,
        #[serde(default = "defaults::force_transform_forces_item_variant1_strength")]
        strength: ForceTransformForcesItemVariant1Strength,
    },
    Variant2 {
        #[serde(
            rename = "distanceMax",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        distance_max: Option<ForceTransformForcesItemVariant2DistanceMax>,
        #[serde(
            rename = "distanceMin",
            default = "defaults::force_transform_forces_item_variant2_distance_min"
        )]
        distance_min: ForceTransformForcesItemVariant2DistanceMin,
        force: ForceTransformForcesItemVariant2Force,
        #[serde(default = "defaults::force_transform_forces_item_variant2_strength")]
        strength: ForceTransformForcesItemVariant2Strength,
        #[serde(default = "defaults::force_transform_forces_item_variant2_theta")]
        theta: ForceTransformForcesItemVariant2Theta,
    },
    Variant3 {
        #[serde(default = "defaults::force_transform_forces_item_variant3_distance")]
        distance: ForceTransformForcesItemVariant3Distance,
        force: ForceTransformForcesItemVariant3Force,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        id: Option<ForceTransformForcesItemVariant3Id>,
        #[serde(default = "defaults::force_transform_forces_item_variant3_iterations")]
        iterations: ForceTransformForcesItemVariant3Iterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        links: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        strength: Option<ForceTransformForcesItemVariant3Strength>,
    },
    Variant4 {
        force: ForceTransformForcesItemVariant4Force,
        #[serde(default = "defaults::force_transform_forces_item_variant4_strength")]
        strength: ForceTransformForcesItemVariant4Strength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemVariant4X>,
    },
    Variant5 {
        force: ForceTransformForcesItemVariant5Force,
        #[serde(default = "defaults::force_transform_forces_item_variant5_strength")]
        strength: ForceTransformForcesItemVariant5Strength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemVariant5Y>,
    },
}
impl From<&ForceTransformForcesItem> for ForceTransformForcesItem {
    fn from(value: &ForceTransformForcesItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant0Force {
    #[serde(rename = "center")]
    Center,
}
impl From<&ForceTransformForcesItemVariant0Force> for ForceTransformForcesItemVariant0Force {
    fn from(value: &ForceTransformForcesItemVariant0Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant0Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant0Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant0Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant0Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant0Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant0X {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant0X> for ForceTransformForcesItemVariant0X {
    fn from(value: &ForceTransformForcesItemVariant0X) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant0Y {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant0Y> for ForceTransformForcesItemVariant0Y {
    fn from(value: &ForceTransformForcesItemVariant0Y) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant1Force {
    #[serde(rename = "collide")]
    Collide,
}
impl From<&ForceTransformForcesItemVariant1Force> for ForceTransformForcesItemVariant1Force {
    fn from(value: &ForceTransformForcesItemVariant1Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant1Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Collide => "collide".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant1Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "collide" => Ok(Self::Collide),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant1Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant1Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant1Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Iterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant1Iterations>
    for ForceTransformForcesItemVariant1Iterations
{
    fn from(value: &ForceTransformForcesItemVariant1Iterations) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant1Iterations {
    fn default() -> Self {
        ForceTransformForcesItemVariant1Iterations::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Radius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&ForceTransformForcesItemVariant1Radius> for ForceTransformForcesItemVariant1Radius {
    fn from(value: &ForceTransformForcesItemVariant1Radius) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant1Strength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant1Strength> for ForceTransformForcesItemVariant1Strength {
    fn from(value: &ForceTransformForcesItemVariant1Strength) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant1Strength {
    fn default() -> Self {
        ForceTransformForcesItemVariant1Strength::Variant0(0.7_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2DistanceMax {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant2DistanceMax>
    for ForceTransformForcesItemVariant2DistanceMax
{
    fn from(value: &ForceTransformForcesItemVariant2DistanceMax) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2DistanceMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant2DistanceMin>
    for ForceTransformForcesItemVariant2DistanceMin
{
    fn from(value: &ForceTransformForcesItemVariant2DistanceMin) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant2DistanceMin {
    fn default() -> Self {
        ForceTransformForcesItemVariant2DistanceMin::Variant0(1_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant2Force {
    #[serde(rename = "nbody")]
    Nbody,
}
impl From<&ForceTransformForcesItemVariant2Force> for ForceTransformForcesItemVariant2Force {
    fn from(value: &ForceTransformForcesItemVariant2Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant2Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Nbody => "nbody".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant2Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "nbody" => Ok(Self::Nbody),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant2Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant2Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant2Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2Strength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant2Strength> for ForceTransformForcesItemVariant2Strength {
    fn from(value: &ForceTransformForcesItemVariant2Strength) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant2Strength {
    fn default() -> Self {
        ForceTransformForcesItemVariant2Strength::Variant0(-30_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant2Theta {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant2Theta> for ForceTransformForcesItemVariant2Theta {
    fn from(value: &ForceTransformForcesItemVariant2Theta) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant2Theta {
    fn default() -> Self {
        ForceTransformForcesItemVariant2Theta::Variant0(0.9_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Distance {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&ForceTransformForcesItemVariant3Distance> for ForceTransformForcesItemVariant3Distance {
    fn from(value: &ForceTransformForcesItemVariant3Distance) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant3Distance {
    fn default() -> Self {
        ForceTransformForcesItemVariant3Distance::Variant0(30_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant3Force {
    #[serde(rename = "link")]
    Link,
}
impl From<&ForceTransformForcesItemVariant3Force> for ForceTransformForcesItemVariant3Force {
    fn from(value: &ForceTransformForcesItemVariant3Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant3Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Link => "link".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant3Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "link" => Ok(Self::Link),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant3Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant3Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant3Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Id {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ForceTransformForcesItemVariant3Id> for ForceTransformForcesItemVariant3Id {
    fn from(value: &ForceTransformForcesItemVariant3Id) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Iterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant3Iterations>
    for ForceTransformForcesItemVariant3Iterations
{
    fn from(value: &ForceTransformForcesItemVariant3Iterations) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant3Iterations {
    fn default() -> Self {
        ForceTransformForcesItemVariant3Iterations::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant3Strength {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&ForceTransformForcesItemVariant3Strength> for ForceTransformForcesItemVariant3Strength {
    fn from(value: &ForceTransformForcesItemVariant3Strength) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant4Force {
    #[serde(rename = "x")]
    X,
}
impl From<&ForceTransformForcesItemVariant4Force> for ForceTransformForcesItemVariant4Force {
    fn from(value: &ForceTransformForcesItemVariant4Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant4Force {
    fn to_string(&self) -> String {
        match *self {
            Self::X => "x".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant4Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "x" => Ok(Self::X),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant4Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant4Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant4Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant4Strength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant4Strength> for ForceTransformForcesItemVariant4Strength {
    fn from(value: &ForceTransformForcesItemVariant4Strength) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant4Strength {
    fn default() -> Self {
        ForceTransformForcesItemVariant4Strength::Variant0(0.1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant4X {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ForceTransformForcesItemVariant4X> for ForceTransformForcesItemVariant4X {
    fn from(value: &ForceTransformForcesItemVariant4X) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformForcesItemVariant5Force {
    #[serde(rename = "y")]
    Y,
}
impl From<&ForceTransformForcesItemVariant5Force> for ForceTransformForcesItemVariant5Force {
    fn from(value: &ForceTransformForcesItemVariant5Force) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformForcesItemVariant5Force {
    fn to_string(&self) -> String {
        match *self {
            Self::Y => "y".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformForcesItemVariant5Force {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "y" => Ok(Self::Y),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformForcesItemVariant5Force {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformForcesItemVariant5Force {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformForcesItemVariant5Force {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant5Strength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformForcesItemVariant5Strength> for ForceTransformForcesItemVariant5Strength {
    fn from(value: &ForceTransformForcesItemVariant5Strength) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemVariant5Strength {
    fn default() -> Self {
        ForceTransformForcesItemVariant5Strength::Variant0(0.1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemVariant5Y {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ForceTransformForcesItemVariant5Y> for ForceTransformForcesItemVariant5Y {
    fn from(value: &ForceTransformForcesItemVariant5Y) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformIterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformIterations> for ForceTransformIterations {
    fn from(value: &ForceTransformIterations) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformIterations {
    fn default() -> Self {
        ForceTransformIterations::Variant0(300_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformRestart {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&ForceTransformRestart> for ForceTransformRestart {
    fn from(value: &ForceTransformRestart) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformStatic {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&ForceTransformStatic> for ForceTransformStatic {
    fn from(value: &ForceTransformStatic) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformType {
    #[serde(rename = "force")]
    Force,
}
impl From<&ForceTransformType> for ForceTransformType {
    fn from(value: &ForceTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Force => "force".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "force" => Ok(Self::Force),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformVelocityDecay {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ForceTransformVelocityDecay> for ForceTransformVelocityDecay {
    fn from(value: &ForceTransformVelocityDecay) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformVelocityDecay {
    fn default() -> Self {
        ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FormulaTransform {
    #[serde(rename = "as")]
    pub as_: FormulaTransformAs,
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initonly: Option<FormulaTransformInitonly>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FormulaTransformType,
}
impl From<&FormulaTransform> for FormulaTransform {
    fn from(value: &FormulaTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FormulaTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&FormulaTransformAs> for FormulaTransformAs {
    fn from(value: &FormulaTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FormulaTransformInitonly {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&FormulaTransformInitonly> for FormulaTransformInitonly {
    fn from(value: &FormulaTransformInitonly) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FormulaTransformType {
    #[serde(rename = "formula")]
    Formula,
}
impl From<&FormulaTransformType> for FormulaTransformType {
    fn from(value: &FormulaTransformType) -> Self {
        value.clone()
    }
}
impl ToString for FormulaTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Formula => "formula".to_string(),
        }
    }
}
impl std::str::FromStr for FormulaTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "formula" => Ok(Self::Formula),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for FormulaTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FormulaTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FormulaTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct From {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
}
impl From<&From> for From {
    fn from(value: &From) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeojsonTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<GeojsonTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub geojson: Option<GeojsonTransformGeojson>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeojsonTransformType,
}
impl From<&GeojsonTransform> for GeojsonTransform {
    fn from(value: &GeojsonTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformFields {
    Variant0(
        GeojsonTransformFieldsVariant0,
        GeojsonTransformFieldsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&GeojsonTransformFields> for GeojsonTransformFields {
    fn from(value: &GeojsonTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformFieldsVariant0 {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&GeojsonTransformFieldsVariant0> for GeojsonTransformFieldsVariant0 {
    fn from(value: &GeojsonTransformFieldsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformGeojson {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&GeojsonTransformGeojson> for GeojsonTransformGeojson {
    fn from(value: &GeojsonTransformGeojson) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeojsonTransformType {
    #[serde(rename = "geojson")]
    Geojson,
}
impl From<&GeojsonTransformType> for GeojsonTransformType {
    fn from(value: &GeojsonTransformType) -> Self {
        value.clone()
    }
}
impl ToString for GeojsonTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geojson => "geojson".to_string(),
        }
    }
}
impl std::str::FromStr for GeojsonTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geojson" => Ok(Self::Geojson),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeojsonTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeojsonTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeojsonTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopathTransform {
    #[serde(rename = "as", default = "defaults::geopath_transform_as")]
    pub as_: GeopathTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<GeopathTransformField>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeopathTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopathTransformType,
}
impl From<&GeopathTransform> for GeopathTransform {
    fn from(value: &GeopathTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&GeopathTransformAs> for GeopathTransformAs {
    fn from(value: &GeopathTransformAs) -> Self {
        value.clone()
    }
}
impl Default for GeopathTransformAs {
    fn default() -> Self {
        GeopathTransformAs::Variant0("path".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&GeopathTransformField> for GeopathTransformField {
    fn from(value: &GeopathTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&GeopathTransformPointRadius> for GeopathTransformPointRadius {
    fn from(value: &GeopathTransformPointRadius) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeopathTransformType {
    #[serde(rename = "geopath")]
    Geopath,
}
impl From<&GeopathTransformType> for GeopathTransformType {
    fn from(value: &GeopathTransformType) -> Self {
        value.clone()
    }
}
impl ToString for GeopathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopath => "geopath".to_string(),
        }
    }
}
impl std::str::FromStr for GeopathTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geopath" => Ok(Self::Geopath),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopathTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopathTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeopathTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopointTransform {
    #[serde(rename = "as", default = "defaults::geopoint_transform_as")]
    pub as_: GeopointTransformAs,
    pub fields: GeopointTransformFields,
    pub projection: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopointTransformType,
}
impl From<&GeopointTransform> for GeopointTransform {
    fn from(value: &GeopointTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformAs {
    Variant0(GeopointTransformAsVariant0, GeopointTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&GeopointTransformAs> for GeopointTransformAs {
    fn from(value: &GeopointTransformAs) -> Self {
        value.clone()
    }
}
impl Default for GeopointTransformAs {
    fn default() -> Self {
        GeopointTransformAs::Variant0(
            GeopointTransformAsVariant0::Variant0("x".to_string()),
            GeopointTransformAsVariant0::Variant0("y".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&GeopointTransformAsVariant0> for GeopointTransformAsVariant0 {
    fn from(value: &GeopointTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformFields {
    Variant0(
        GeopointTransformFieldsVariant0,
        GeopointTransformFieldsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&GeopointTransformFields> for GeopointTransformFields {
    fn from(value: &GeopointTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformFieldsVariant0 {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&GeopointTransformFieldsVariant0> for GeopointTransformFieldsVariant0 {
    fn from(value: &GeopointTransformFieldsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeopointTransformType {
    #[serde(rename = "geopoint")]
    Geopoint,
}
impl From<&GeopointTransformType> for GeopointTransformType {
    fn from(value: &GeopointTransformType) -> Self {
        value.clone()
    }
}
impl ToString for GeopointTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopoint => "geopoint".to_string(),
        }
    }
}
impl std::str::FromStr for GeopointTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geopoint" => Ok(Self::Geopoint),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopointTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopointTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeopointTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeoshapeTransform {
    #[serde(rename = "as", default = "defaults::geoshape_transform_as")]
    pub as_: GeoshapeTransformAs,
    #[serde(default = "defaults::geoshape_transform_field")]
    pub field: GeoshapeTransformField,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeoshapeTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeoshapeTransformType,
}
impl From<&GeoshapeTransform> for GeoshapeTransform {
    fn from(value: &GeoshapeTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&GeoshapeTransformAs> for GeoshapeTransformAs {
    fn from(value: &GeoshapeTransformAs) -> Self {
        value.clone()
    }
}
impl Default for GeoshapeTransformAs {
    fn default() -> Self {
        GeoshapeTransformAs::Variant0("shape".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&GeoshapeTransformField> for GeoshapeTransformField {
    fn from(value: &GeoshapeTransformField) -> Self {
        value.clone()
    }
}
impl Default for GeoshapeTransformField {
    fn default() -> Self {
        GeoshapeTransformField::ScaleField(ScaleField(StringOrSignal::Variant0(
            "datum".to_string(),
        )))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&GeoshapeTransformPointRadius> for GeoshapeTransformPointRadius {
    fn from(value: &GeoshapeTransformPointRadius) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeoshapeTransformType {
    #[serde(rename = "geoshape")]
    Geoshape,
}
impl From<&GeoshapeTransformType> for GeoshapeTransformType {
    fn from(value: &GeoshapeTransformType) -> Self {
        value.clone()
    }
}
impl ToString for GeoshapeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geoshape => "geoshape".to_string(),
        }
    }
}
impl std::str::FromStr for GeoshapeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "geoshape" => Ok(Self::Geoshape),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GeoshapeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeoshapeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeoshapeTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GradientStops(pub Vec<GradientStopsItem>);
impl std::ops::Deref for GradientStops {
    type Target = Vec<GradientStopsItem>;
    fn deref(&self) -> &Vec<GradientStopsItem> {
        &self.0
    }
}
impl From<GradientStops> for Vec<GradientStopsItem> {
    fn from(value: GradientStops) -> Self {
        value.0
    }
}
impl From<&GradientStops> for GradientStops {
    fn from(value: &GradientStops) -> Self {
        value.clone()
    }
}
impl From<Vec<GradientStopsItem>> for GradientStops {
    fn from(value: Vec<GradientStopsItem>) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GradientStopsItem {
    pub color: String,
    pub offset: f64,
}
impl From<&GradientStopsItem> for GradientStopsItem {
    fn from(value: &GradientStopsItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GraticuleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<GraticuleTransformExtent>,
    #[serde(
        rename = "extentMajor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_major: Option<GraticuleTransformExtentMajor>,
    #[serde(
        rename = "extentMinor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_minor: Option<GraticuleTransformExtentMinor>,
    #[serde(default = "defaults::graticule_transform_precision")]
    pub precision: GraticuleTransformPrecision,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<GraticuleTransformStep>,
    #[serde(
        rename = "stepMajor",
        default = "defaults::graticule_transform_step_major"
    )]
    pub step_major: GraticuleTransformStepMajor,
    #[serde(
        rename = "stepMinor",
        default = "defaults::graticule_transform_step_minor"
    )]
    pub step_minor: GraticuleTransformStepMinor,
    #[serde(rename = "type")]
    pub type_: GraticuleTransformType,
}
impl From<&GraticuleTransform> for GraticuleTransform {
    fn from(value: &GraticuleTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtent {
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformExtent> for GraticuleTransformExtent {
    fn from(value: &GraticuleTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMajor {
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformExtentMajor> for GraticuleTransformExtentMajor {
    fn from(value: &GraticuleTransformExtentMajor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMinor {
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformExtentMinor> for GraticuleTransformExtentMinor {
    fn from(value: &GraticuleTransformExtentMinor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformPrecision {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformPrecision> for GraticuleTransformPrecision {
    fn from(value: &GraticuleTransformPrecision) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformPrecision {
    fn default() -> Self {
        GraticuleTransformPrecision::Variant0(2.5_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStep {
    Variant0(
        GraticuleTransformStepVariant0,
        GraticuleTransformStepVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStep> for GraticuleTransformStep {
    fn from(value: &GraticuleTransformStep) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajor {
    Variant0(
        GraticuleTransformStepMajorVariant0,
        GraticuleTransformStepMajorVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStepMajor> for GraticuleTransformStepMajor {
    fn from(value: &GraticuleTransformStepMajor) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformStepMajor {
    fn default() -> Self {
        GraticuleTransformStepMajor::Variant0(
            GraticuleTransformStepMajorVariant0::Variant0(90_f64),
            GraticuleTransformStepMajorVariant0::Variant0(360_f64),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajorVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStepMajorVariant0> for GraticuleTransformStepMajorVariant0 {
    fn from(value: &GraticuleTransformStepMajorVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinor {
    Variant0(
        GraticuleTransformStepMinorVariant0,
        GraticuleTransformStepMinorVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStepMinor> for GraticuleTransformStepMinor {
    fn from(value: &GraticuleTransformStepMinor) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformStepMinor {
    fn default() -> Self {
        GraticuleTransformStepMinor::Variant0(
            GraticuleTransformStepMinorVariant0::Variant0(10_f64),
            GraticuleTransformStepMinorVariant0::Variant0(10_f64),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinorVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStepMinorVariant0> for GraticuleTransformStepMinorVariant0 {
    fn from(value: &GraticuleTransformStepMinorVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&GraticuleTransformStepVariant0> for GraticuleTransformStepVariant0 {
    fn from(value: &GraticuleTransformStepVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GraticuleTransformType {
    #[serde(rename = "graticule")]
    Graticule,
}
impl From<&GraticuleTransformType> for GraticuleTransformType {
    fn from(value: &GraticuleTransformType) -> Self {
        value.clone()
    }
}
impl ToString for GraticuleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Graticule => "graticule".to_string(),
        }
    }
}
impl std::str::FromStr for GraticuleTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "graticule" => Ok(Self::Graticule),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for GraticuleTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GraticuleTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GraticuleTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GuideEncode {
    #[serde(default)]
    pub interactive: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
}
impl From<&GuideEncode> for GuideEncode {
    fn from(value: &GuideEncode) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct HeatmapTransform {
    #[serde(rename = "as", default = "defaults::heatmap_transform_as")]
    pub as_: HeatmapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<HeatmapTransformColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<HeatmapTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<HeatmapTransformOpacity>,
    #[serde(default = "defaults::heatmap_transform_resolve")]
    pub resolve: HeatmapTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: HeatmapTransformType,
}
impl From<&HeatmapTransform> for HeatmapTransform {
    fn from(value: &HeatmapTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&HeatmapTransformAs> for HeatmapTransformAs {
    fn from(value: &HeatmapTransformAs) -> Self {
        value.clone()
    }
}
impl Default for HeatmapTransformAs {
    fn default() -> Self {
        HeatmapTransformAs::Variant0("image".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformColor {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&HeatmapTransformColor> for HeatmapTransformColor {
    fn from(value: &HeatmapTransformColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&HeatmapTransformField> for HeatmapTransformField {
    fn from(value: &HeatmapTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformOpacity {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&HeatmapTransformOpacity> for HeatmapTransformOpacity {
    fn from(value: &HeatmapTransformOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformResolve {
    Variant0(HeatmapTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&HeatmapTransformResolve> for HeatmapTransformResolve {
    fn from(value: &HeatmapTransformResolve) -> Self {
        value.clone()
    }
}
impl Default for HeatmapTransformResolve {
    fn default() -> Self {
        HeatmapTransformResolve::Variant0(HeatmapTransformResolveVariant0::Independent)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum HeatmapTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&HeatmapTransformResolveVariant0> for HeatmapTransformResolveVariant0 {
    fn from(value: &HeatmapTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ToString for HeatmapTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for HeatmapTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum HeatmapTransformType {
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&HeatmapTransformType> for HeatmapTransformType {
    fn from(value: &HeatmapTransformType) -> Self {
        value.clone()
    }
}
impl ToString for HeatmapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for HeatmapTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentifierTransform {
    #[serde(rename = "as")]
    pub as_: IdentifierTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: IdentifierTransformType,
}
impl From<&IdentifierTransform> for IdentifierTransform {
    fn from(value: &IdentifierTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IdentifierTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&IdentifierTransformAs> for IdentifierTransformAs {
    fn from(value: &IdentifierTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IdentifierTransformType {
    #[serde(rename = "identifier")]
    Identifier,
}
impl From<&IdentifierTransformType> for IdentifierTransformType {
    fn from(value: &IdentifierTransformType) -> Self {
        value.clone()
    }
}
impl ToString for IdentifierTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Identifier => "identifier".to_string(),
        }
    }
}
impl std::str::FromStr for IdentifierTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "identifier" => Ok(Self::Identifier),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IdentifierTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IdentifierTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IdentifierTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ImputeTransform {
    pub field: ImputeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<ImputeTransformGroupby>,
    pub key: ImputeTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyvals: Option<ImputeTransformKeyvals>,
    #[serde(default = "defaults::impute_transform_method")]
    pub method: ImputeTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ImputeTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
impl From<&ImputeTransform> for ImputeTransform {
    fn from(value: &ImputeTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ImputeTransformField> for ImputeTransformField {
    fn from(value: &ImputeTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformGroupby {
    Variant0(Vec<ImputeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ImputeTransformGroupby> for ImputeTransformGroupby {
    fn from(value: &ImputeTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ImputeTransformGroupbyVariant0Item> for ImputeTransformGroupbyVariant0Item {
    fn from(value: &ImputeTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ImputeTransformKey> for ImputeTransformKey {
    fn from(value: &ImputeTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformKeyvals {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&ImputeTransformKeyvals> for ImputeTransformKeyvals {
    fn from(value: &ImputeTransformKeyvals) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformMethod {
    Variant0(ImputeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&ImputeTransformMethod> for ImputeTransformMethod {
    fn from(value: &ImputeTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for ImputeTransformMethod {
    fn default() -> Self {
        ImputeTransformMethod::Variant0(ImputeTransformMethodVariant0::Value)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ImputeTransformMethodVariant0 {
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "min")]
    Min,
}
impl From<&ImputeTransformMethodVariant0> for ImputeTransformMethodVariant0 {
    fn from(value: &ImputeTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ImputeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Value => "value".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Median => "median".to_string(),
            Self::Max => "max".to_string(),
            Self::Min => "min".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "value" => Ok(Self::Value),
            "mean" => Ok(Self::Mean),
            "median" => Ok(Self::Median),
            "max" => Ok(Self::Max),
            "min" => Ok(Self::Min),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ImputeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ImputeTransformType {
    #[serde(rename = "impute")]
    Impute,
}
impl From<&ImputeTransformType> for ImputeTransformType {
    fn from(value: &ImputeTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ImputeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Impute => "impute".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "impute" => Ok(Self::Impute),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ImputeTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IsocontourTransform {
    #[serde(rename = "as", default = "defaults::isocontour_transform_as")]
    pub as_: IsocontourTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<IsocontourTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub levels: Option<IsocontourTransformLevels>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<IsocontourTransformNice>,
    #[serde(default = "defaults::isocontour_transform_resolve")]
    pub resolve: IsocontourTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<IsocontourTransformScale>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::isocontour_transform_smooth")]
    pub smooth: IsocontourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<IsocontourTransformThresholds>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<IsocontourTransformTranslate>,
    #[serde(rename = "type")]
    pub type_: IsocontourTransformType,
    #[serde(default = "defaults::isocontour_transform_zero")]
    pub zero: IsocontourTransformZero,
}
impl From<&IsocontourTransform> for IsocontourTransform {
    fn from(value: &IsocontourTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformAs {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&IsocontourTransformAs> for IsocontourTransformAs {
    fn from(value: &IsocontourTransformAs) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformAs {
    fn default() -> Self {
        IsocontourTransformAs::Variant0("contour".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&IsocontourTransformField> for IsocontourTransformField {
    fn from(value: &IsocontourTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformLevels {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformLevels> for IsocontourTransformLevels {
    fn from(value: &IsocontourTransformLevels) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformNice> for IsocontourTransformNice {
    fn from(value: &IsocontourTransformNice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformResolve {
    Variant0(IsocontourTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformResolve> for IsocontourTransformResolve {
    fn from(value: &IsocontourTransformResolve) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformResolve {
    fn default() -> Self {
        IsocontourTransformResolve::Variant0(IsocontourTransformResolveVariant0::Independent)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IsocontourTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&IsocontourTransformResolveVariant0> for IsocontourTransformResolveVariant0 {
    fn from(value: &IsocontourTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ToString for IsocontourTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IsocontourTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformScale {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&IsocontourTransformScale> for IsocontourTransformScale {
    fn from(value: &IsocontourTransformScale) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformSmooth> for IsocontourTransformSmooth {
    fn from(value: &IsocontourTransformSmooth) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformSmooth {
    fn default() -> Self {
        IsocontourTransformSmooth::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformThresholds {
    Variant0(Vec<IsocontourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformThresholds> for IsocontourTransformThresholds {
    fn from(value: &IsocontourTransformThresholds) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformThresholdsVariant0Item>
    for IsocontourTransformThresholdsVariant0Item
{
    fn from(value: &IsocontourTransformThresholdsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformTranslate {
    Variant0(Vec<IsocontourTransformTranslateVariant0Item>),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformTranslate> for IsocontourTransformTranslate {
    fn from(value: &IsocontourTransformTranslate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformTranslateVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&IsocontourTransformTranslateVariant0Item> for IsocontourTransformTranslateVariant0Item {
    fn from(value: &IsocontourTransformTranslateVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IsocontourTransformType {
    #[serde(rename = "isocontour")]
    Isocontour,
}
impl From<&IsocontourTransformType> for IsocontourTransformType {
    fn from(value: &IsocontourTransformType) -> Self {
        value.clone()
    }
}
impl ToString for IsocontourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Isocontour => "isocontour".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "isocontour" => Ok(Self::Isocontour),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IsocontourTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformZero {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&IsocontourTransformZero> for IsocontourTransformZero {
    fn from(value: &IsocontourTransformZero) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformZero {
    fn default() -> Self {
        IsocontourTransformZero::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct JoinaggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<JoinaggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<JoinaggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<JoinaggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<JoinaggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<JoinaggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: JoinaggregateTransformType,
}
impl From<&JoinaggregateTransform> for JoinaggregateTransform {
    fn from(value: &JoinaggregateTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformAs {
    Variant0(Vec<JoinaggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&JoinaggregateTransformAs> for JoinaggregateTransformAs {
    fn from(value: &JoinaggregateTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&JoinaggregateTransformAsVariant0Item> for JoinaggregateTransformAsVariant0Item {
    fn from(value: &JoinaggregateTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformFields {
    Variant0(Vec<JoinaggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&JoinaggregateTransformFields> for JoinaggregateTransformFields {
    fn from(value: &JoinaggregateTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&JoinaggregateTransformFieldsVariant0Item> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: &JoinaggregateTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupby {
    Variant0(Vec<JoinaggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&JoinaggregateTransformGroupby> for JoinaggregateTransformGroupby {
    fn from(value: &JoinaggregateTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&JoinaggregateTransformGroupbyVariant0Item>
    for JoinaggregateTransformGroupbyVariant0Item
{
    fn from(value: &JoinaggregateTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&JoinaggregateTransformKey> for JoinaggregateTransformKey {
    fn from(value: &JoinaggregateTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformOps {
    Variant0(Vec<JoinaggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&JoinaggregateTransformOps> for JoinaggregateTransformOps {
    fn from(value: &JoinaggregateTransformOps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformOpsVariant0Item {
    Variant0(JoinaggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&JoinaggregateTransformOpsVariant0Item> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: &JoinaggregateTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum JoinaggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&JoinaggregateTransformOpsVariant0ItemVariant0>
    for JoinaggregateTransformOpsVariant0ItemVariant0
{
    fn from(value: &JoinaggregateTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ToString for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum JoinaggregateTransformType {
    #[serde(rename = "joinaggregate")]
    Joinaggregate,
}
impl From<&JoinaggregateTransformType> for JoinaggregateTransformType {
    fn from(value: &JoinaggregateTransformType) -> Self {
        value.clone()
    }
}
impl ToString for JoinaggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Joinaggregate => "joinaggregate".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "joinaggregate" => Ok(Self::Joinaggregate),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for JoinaggregateTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Kde2dTransform {
    #[serde(rename = "as", default = "defaults::kde2d_transform_as")]
    pub as_: Kde2dTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<Kde2dTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<Kde2dTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<Kde2dTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<Kde2dTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: Kde2dTransformSize,
    #[serde(rename = "type")]
    pub type_: Kde2dTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<Kde2dTransformWeight>,
    pub x: Kde2dTransformX,
    pub y: Kde2dTransformY,
}
impl From<&Kde2dTransform> for Kde2dTransform {
    fn from(value: &Kde2dTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformAs> for Kde2dTransformAs {
    fn from(value: &Kde2dTransformAs) -> Self {
        value.clone()
    }
}
impl Default for Kde2dTransformAs {
    fn default() -> Self {
        Kde2dTransformAs::Variant0("grid".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidth {
    Variant0(
        Kde2dTransformBandwidthVariant0,
        Kde2dTransformBandwidthVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformBandwidth> for Kde2dTransformBandwidth {
    fn from(value: &Kde2dTransformBandwidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidthVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformBandwidthVariant0> for Kde2dTransformBandwidthVariant0 {
    fn from(value: &Kde2dTransformBandwidthVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformCellSize> for Kde2dTransformCellSize {
    fn from(value: &Kde2dTransformCellSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformCounts> for Kde2dTransformCounts {
    fn from(value: &Kde2dTransformCounts) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformGroupby {
    Variant0(Vec<Kde2dTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformGroupby> for Kde2dTransformGroupby {
    fn from(value: &Kde2dTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Kde2dTransformGroupbyVariant0Item> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: &Kde2dTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformSize {
    Variant0(Kde2dTransformSizeVariant0, Kde2dTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformSize> for Kde2dTransformSize {
    fn from(value: &Kde2dTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Kde2dTransformSizeVariant0> for Kde2dTransformSizeVariant0 {
    fn from(value: &Kde2dTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum Kde2dTransformType {
    #[serde(rename = "kde2d")]
    Kde2d,
}
impl From<&Kde2dTransformType> for Kde2dTransformType {
    fn from(value: &Kde2dTransformType) -> Self {
        value.clone()
    }
}
impl ToString for Kde2dTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde2d => "kde2d".to_string(),
        }
    }
}
impl std::str::FromStr for Kde2dTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde2d" => Ok(Self::Kde2d),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for Kde2dTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Kde2dTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Kde2dTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Kde2dTransformWeight> for Kde2dTransformWeight {
    fn from(value: &Kde2dTransformWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Kde2dTransformX> for Kde2dTransformX {
    fn from(value: &Kde2dTransformX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Kde2dTransformY> for Kde2dTransformY {
    fn from(value: &Kde2dTransformY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct KdeTransform {
    #[serde(rename = "as", default = "defaults::kde_transform_as")]
    pub as_: KdeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<KdeTransformBandwidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<KdeTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cumulative: Option<KdeTransformCumulative>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<KdeTransformExtent>,
    pub field: KdeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<KdeTransformGroupby>,
    #[serde(default = "defaults::kde_transform_maxsteps")]
    pub maxsteps: KdeTransformMaxsteps,
    #[serde(default = "defaults::kde_transform_minsteps")]
    pub minsteps: KdeTransformMinsteps,
    #[serde(default = "defaults::kde_transform_resolve")]
    pub resolve: KdeTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<KdeTransformSteps>,
    #[serde(rename = "type")]
    pub type_: KdeTransformType,
}
impl From<&KdeTransform> for KdeTransform {
    fn from(value: &KdeTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformAs {
    Variant0(Vec<KdeTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&KdeTransformAs> for KdeTransformAs {
    fn from(value: &KdeTransformAs) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformAs {
    fn default() -> Self {
        KdeTransformAs::Variant0(vec![
            KdeTransformAsVariant0Item::Variant0("value".to_string()),
            KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&KdeTransformAsVariant0Item> for KdeTransformAsVariant0Item {
    fn from(value: &KdeTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&KdeTransformBandwidth> for KdeTransformBandwidth {
    fn from(value: &KdeTransformBandwidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&KdeTransformCounts> for KdeTransformCounts {
    fn from(value: &KdeTransformCounts) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformCumulative {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&KdeTransformCumulative> for KdeTransformCumulative {
    fn from(value: &KdeTransformCumulative) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformExtent {
    Variant0(KdeTransformExtentVariant0, KdeTransformExtentVariant0),
    Variant1(SignalRef),
}
impl From<&KdeTransformExtent> for KdeTransformExtent {
    fn from(value: &KdeTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformExtentVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&KdeTransformExtentVariant0> for KdeTransformExtentVariant0 {
    fn from(value: &KdeTransformExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&KdeTransformField> for KdeTransformField {
    fn from(value: &KdeTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformGroupby {
    Variant0(Vec<KdeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&KdeTransformGroupby> for KdeTransformGroupby {
    fn from(value: &KdeTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&KdeTransformGroupbyVariant0Item> for KdeTransformGroupbyVariant0Item {
    fn from(value: &KdeTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&KdeTransformMaxsteps> for KdeTransformMaxsteps {
    fn from(value: &KdeTransformMaxsteps) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformMaxsteps {
    fn default() -> Self {
        KdeTransformMaxsteps::Variant0(200_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&KdeTransformMinsteps> for KdeTransformMinsteps {
    fn from(value: &KdeTransformMinsteps) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformMinsteps {
    fn default() -> Self {
        KdeTransformMinsteps::Variant0(25_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformResolve {
    Variant0(KdeTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&KdeTransformResolve> for KdeTransformResolve {
    fn from(value: &KdeTransformResolve) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformResolve {
    fn default() -> Self {
        KdeTransformResolve::Variant0(KdeTransformResolveVariant0::Independent)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum KdeTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&KdeTransformResolveVariant0> for KdeTransformResolveVariant0 {
    fn from(value: &KdeTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ToString for KdeTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformResolveVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for KdeTransformResolveVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&KdeTransformSteps> for KdeTransformSteps {
    fn from(value: &KdeTransformSteps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum KdeTransformType {
    #[serde(rename = "kde")]
    Kde,
}
impl From<&KdeTransformType> for KdeTransformType {
    fn from(value: &KdeTransformType) -> Self {
        value.clone()
    }
}
impl ToString for KdeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde => "kde".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for KdeTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelOverlap {
    Variant0(bool),
    Variant1(LabelOverlapVariant1),
    Variant2(SignalRef),
}
impl From<&LabelOverlap> for LabelOverlap {
    fn from(value: &LabelOverlap) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelOverlapVariant1 {
    #[serde(rename = "parity")]
    Parity,
    #[serde(rename = "greedy")]
    Greedy,
}
impl From<&LabelOverlapVariant1> for LabelOverlapVariant1 {
    fn from(value: &LabelOverlapVariant1) -> Self {
        value.clone()
    }
}
impl ToString for LabelOverlapVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Parity => "parity".to_string(),
            Self::Greedy => "greedy".to_string(),
        }
    }
}
impl std::str::FromStr for LabelOverlapVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "parity" => Ok(Self::Parity),
            "greedy" => Ok(Self::Greedy),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelOverlapVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelOverlapVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelOverlapVariant1 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelTransform {
    #[serde(default = "defaults::label_transform_anchor")]
    pub anchor: LabelTransformAnchor,
    #[serde(rename = "as", default = "defaults::label_transform_as")]
    pub as_: LabelTransformAs,
    #[serde(
        rename = "avoidBaseMark",
        default = "defaults::label_transform_avoid_base_mark"
    )]
    pub avoid_base_mark: LabelTransformAvoidBaseMark,
    #[serde(
        rename = "avoidMarks",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub avoid_marks: Option<LabelTransformAvoidMarks>,
    #[serde(
        rename = "lineAnchor",
        default = "defaults::label_transform_line_anchor"
    )]
    pub line_anchor: LabelTransformLineAnchor,
    #[serde(rename = "markIndex", default, skip_serializing_if = "Option::is_none")]
    pub mark_index: Option<LabelTransformMarkIndex>,
    #[serde(default = "defaults::label_transform_method")]
    pub method: LabelTransformMethod,
    #[serde(default = "defaults::label_transform_offset")]
    pub offset: LabelTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<LabelTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: LabelTransformSize,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: LabelTransformType,
}
impl From<&LabelTransform> for LabelTransform {
    fn from(value: &LabelTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAnchor {
    Variant0(Vec<LabelTransformAnchorVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LabelTransformAnchor> for LabelTransformAnchor {
    fn from(value: &LabelTransformAnchor) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAnchor {
    fn default() -> Self {
        LabelTransformAnchor::Variant0(vec![
            LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAnchorVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LabelTransformAnchorVariant0Item> for LabelTransformAnchorVariant0Item {
    fn from(value: &LabelTransformAnchorVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAs {
    Variant0(
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
        LabelTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&LabelTransformAs> for LabelTransformAs {
    fn from(value: &LabelTransformAs) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAs {
    fn default() -> Self {
        LabelTransformAs::Variant0(
            LabelTransformAsVariant0::Variant0("x".to_string()),
            LabelTransformAsVariant0::Variant0("y".to_string()),
            LabelTransformAsVariant0::Variant0("opacity".to_string()),
            LabelTransformAsVariant0::Variant0("align".to_string()),
            LabelTransformAsVariant0::Variant0("baseline".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LabelTransformAsVariant0> for LabelTransformAsVariant0 {
    fn from(value: &LabelTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAvoidBaseMark {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&LabelTransformAvoidBaseMark> for LabelTransformAvoidBaseMark {
    fn from(value: &LabelTransformAvoidBaseMark) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAvoidBaseMark {
    fn default() -> Self {
        LabelTransformAvoidBaseMark::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAvoidMarks {
    Variant0(Vec<String>),
    Variant1(SignalRef),
}
impl From<&LabelTransformAvoidMarks> for LabelTransformAvoidMarks {
    fn from(value: &LabelTransformAvoidMarks) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformLineAnchor {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LabelTransformLineAnchor> for LabelTransformLineAnchor {
    fn from(value: &LabelTransformLineAnchor) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformLineAnchor {
    fn default() -> Self {
        LabelTransformLineAnchor::Variant0("end".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformMarkIndex {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&LabelTransformMarkIndex> for LabelTransformMarkIndex {
    fn from(value: &LabelTransformMarkIndex) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LabelTransformMethod> for LabelTransformMethod {
    fn from(value: &LabelTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformMethod {
    fn default() -> Self {
        LabelTransformMethod::Variant0("naive".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformOffset {
    Variant0(Vec<LabelTransformOffsetVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LabelTransformOffset> for LabelTransformOffset {
    fn from(value: &LabelTransformOffset) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformOffset {
    fn default() -> Self {
        LabelTransformOffset::Variant0(vec![LabelTransformOffsetVariant0Item::Variant0(1_f64)])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformOffsetVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&LabelTransformOffsetVariant0Item> for LabelTransformOffsetVariant0Item {
    fn from(value: &LabelTransformOffsetVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&LabelTransformPadding> for LabelTransformPadding {
    fn from(value: &LabelTransformPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformSize {
    Variant0(LabelTransformSizeVariant0, LabelTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&LabelTransformSize> for LabelTransformSize {
    fn from(value: &LabelTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&LabelTransformSizeVariant0> for LabelTransformSizeVariant0 {
    fn from(value: &LabelTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelTransformType {
    #[serde(rename = "label")]
    Label,
}
impl From<&LabelTransformType> for LabelTransformType {
    fn from(value: &LabelTransformType) -> Self {
        value.clone()
    }
}
impl ToString for LabelTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Label => "label".to_string(),
        }
    }
}
impl std::str::FromStr for LabelTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "label" => Ok(Self::Label),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Layout {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<LayoutVariant0Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bounds: Option<LayoutVariant0Bounds>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        center: Option<LayoutVariant0Center>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "footerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        footer_band: Option<LayoutVariant0FooterBand>,
        #[serde(
            rename = "headerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        header_band: Option<LayoutVariant0HeaderBand>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LayoutVariant0Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LayoutVariant0Padding>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LayoutVariant0TitleAnchor>,
        #[serde(rename = "titleBand", default, skip_serializing_if = "Option::is_none")]
        title_band: Option<LayoutVariant0TitleBand>,
    },
    Variant1(SignalRef),
}
impl From<&Layout> for Layout {
    fn from(value: &Layout) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Align {
    Variant0(LayoutVariant0AlignVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0AlignVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0AlignVariant1Row>,
    },
}
impl From<&LayoutVariant0Align> for LayoutVariant0Align {
    fn from(value: &LayoutVariant0Align) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant0 {
    Variant0(LayoutVariant0AlignVariant0Variant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0AlignVariant0> for LayoutVariant0AlignVariant0 {
    fn from(value: &LayoutVariant0AlignVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant0Variant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&LayoutVariant0AlignVariant0Variant0> for LayoutVariant0AlignVariant0Variant0 {
    fn from(value: &LayoutVariant0AlignVariant0Variant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant0Variant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Column {
    Variant0(LayoutVariant0AlignVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0AlignVariant1Column> for LayoutVariant0AlignVariant1Column {
    fn from(value: &LayoutVariant0AlignVariant1Column) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant1ColumnVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&LayoutVariant0AlignVariant1ColumnVariant0>
    for LayoutVariant0AlignVariant1ColumnVariant0
{
    fn from(value: &LayoutVariant0AlignVariant1ColumnVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Row {
    Variant0(LayoutVariant0AlignVariant1RowVariant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0AlignVariant1Row> for LayoutVariant0AlignVariant1Row {
    fn from(value: &LayoutVariant0AlignVariant1Row) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant1RowVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&LayoutVariant0AlignVariant1RowVariant0> for LayoutVariant0AlignVariant1RowVariant0 {
    fn from(value: &LayoutVariant0AlignVariant1RowVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1RowVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0Bounds {
    Variant0(LayoutVariant0BoundsVariant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0Bounds> for LayoutVariant0Bounds {
    fn from(value: &LayoutVariant0Bounds) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0BoundsVariant0 {
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "flush")]
    Flush,
}
impl From<&LayoutVariant0BoundsVariant0> for LayoutVariant0BoundsVariant0 {
    fn from(value: &LayoutVariant0BoundsVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0BoundsVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Full => "full".to_string(),
            Self::Flush => "flush".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0BoundsVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "full" => Ok(Self::Full),
            "flush" => Ok(Self::Flush),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0BoundsVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0BoundsVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0BoundsVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Center {
    Variant0(bool),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<BooleanOrSignal>,
    },
}
impl From<&LayoutVariant0Center> for LayoutVariant0Center {
    fn from(value: &LayoutVariant0Center) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0FooterBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&LayoutVariant0FooterBand> for LayoutVariant0FooterBand {
    fn from(value: &LayoutVariant0FooterBand) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0HeaderBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&LayoutVariant0HeaderBand> for LayoutVariant0HeaderBand {
    fn from(value: &LayoutVariant0HeaderBand) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Offset {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(
            rename = "columnFooter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_footer: Option<NumberOrSignal>,
        #[serde(
            rename = "columnHeader",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_header: Option<NumberOrSignal>,
        #[serde(
            rename = "columnTitle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_title: Option<NumberOrSignal>,
        #[serde(rename = "rowFooter", default, skip_serializing_if = "Option::is_none")]
        row_footer: Option<NumberOrSignal>,
        #[serde(rename = "rowHeader", default, skip_serializing_if = "Option::is_none")]
        row_header: Option<NumberOrSignal>,
        #[serde(rename = "rowTitle", default, skip_serializing_if = "Option::is_none")]
        row_title: Option<NumberOrSignal>,
    },
}
impl From<&LayoutVariant0Offset> for LayoutVariant0Offset {
    fn from(value: &LayoutVariant0Offset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Padding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&LayoutVariant0Padding> for LayoutVariant0Padding {
    fn from(value: &LayoutVariant0Padding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleAnchor {
    Variant0(LayoutVariant0TitleAnchorVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0TitleAnchorVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0TitleAnchorVariant1Row>,
    },
}
impl From<&LayoutVariant0TitleAnchor> for LayoutVariant0TitleAnchor {
    fn from(value: &LayoutVariant0TitleAnchor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant0 {
    Variant0(LayoutVariant0TitleAnchorVariant0Variant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0TitleAnchorVariant0> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: &LayoutVariant0TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant0Variant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&LayoutVariant0TitleAnchorVariant0Variant0>
    for LayoutVariant0TitleAnchorVariant0Variant0
{
    fn from(value: &LayoutVariant0TitleAnchorVariant0Variant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Column {
    Variant0(LayoutVariant0TitleAnchorVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0TitleAnchorVariant1Column> for LayoutVariant0TitleAnchorVariant1Column {
    fn from(value: &LayoutVariant0TitleAnchorVariant1Column) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&LayoutVariant0TitleAnchorVariant1ColumnVariant0>
    for LayoutVariant0TitleAnchorVariant1ColumnVariant0
{
    fn from(value: &LayoutVariant0TitleAnchorVariant1ColumnVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Row {
    Variant0(LayoutVariant0TitleAnchorVariant1RowVariant0),
    Variant1(SignalRef),
}
impl From<&LayoutVariant0TitleAnchorVariant1Row> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: &LayoutVariant0TitleAnchorVariant1Row) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant1RowVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&LayoutVariant0TitleAnchorVariant1RowVariant0>
    for LayoutVariant0TitleAnchorVariant1RowVariant0
{
    fn from(value: &LayoutVariant0TitleAnchorVariant1RowVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&LayoutVariant0TitleBand> for LayoutVariant0TitleBand {
    fn from(value: &LayoutVariant0TitleBand) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Legend {
    #[serde(flatten)]
    pub subtype_0: LegendSubtype0,
    #[serde(flatten)]
    pub subtype_1: LegendSubtype1,
}
impl From<&Legend> for Legend {
    fn from(value: &Legend) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendSubtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(
        rename = "clipHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub clip_height: Option<NumberOrSignal>,
    #[serde(
        rename = "columnPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub column_padding: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub columns: Option<NumberOrSignal>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius: Option<LegendSubtype0CornerRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub direction: Option<LegendSubtype0Direction>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<LegendSubtype0Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fill: Option<String>,
    #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
    pub fill_color: Option<LegendSubtype0FillColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<LegendSubtype0Format>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub format_type: Option<LegendSubtype0FormatType>,
    #[serde(
        rename = "gradientLength",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_length: Option<NumberOrSignal>,
    #[serde(
        rename = "gradientOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_opacity: Option<LegendSubtype0GradientOpacity>,
    #[serde(
        rename = "gradientStrokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_stroke_color: Option<LegendSubtype0GradientStrokeColor>,
    #[serde(
        rename = "gradientStrokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_stroke_width: Option<LegendSubtype0GradientStrokeWidth>,
    #[serde(
        rename = "gradientThickness",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub gradient_thickness: Option<NumberOrSignal>,
    #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
    pub grid_align: Option<LegendSubtype0GridAlign>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_align: Option<LegendSubtype0LabelAlign>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_baseline: Option<LegendSubtype0LabelBaseline>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_color: Option<LegendSubtype0LabelColor>,
    #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
    pub label_font: Option<LegendSubtype0LabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_size: Option<LegendSubtype0LabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_style: Option<LegendSubtype0LabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_weight: Option<LegendSubtype0LabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_limit: Option<LegendSubtype0LabelLimit>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_offset: Option<LegendSubtype0LabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_opacity: Option<LegendSubtype0LabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_overlap: Option<LabelOverlap>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_separation: Option<NumberOrSignal>,
    #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
    pub legend_x: Option<LegendSubtype0LegendX>,
    #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
    pub legend_y: Option<LegendSubtype0LegendY>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<LegendSubtype0Offset>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub orient: Option<LegendSubtype0Orient>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<LegendSubtype0Padding>,
    #[serde(
        rename = "rowPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub row_padding: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shape: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stroke: Option<String>,
    #[serde(
        rename = "strokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_color: Option<LegendSubtype0StrokeColor>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash: Option<String>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_width: Option<String>,
    #[serde(
        rename = "symbolDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_dash: Option<LegendSubtype0SymbolDash>,
    #[serde(
        rename = "symbolDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_dash_offset: Option<LegendSubtype0SymbolDashOffset>,
    #[serde(
        rename = "symbolFillColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_fill_color: Option<LegendSubtype0SymbolFillColor>,
    #[serde(
        rename = "symbolLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_limit: Option<NumberOrSignal>,
    #[serde(
        rename = "symbolOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_offset: Option<LegendSubtype0SymbolOffset>,
    #[serde(
        rename = "symbolOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_opacity: Option<LegendSubtype0SymbolOpacity>,
    #[serde(
        rename = "symbolSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_size: Option<LegendSubtype0SymbolSize>,
    #[serde(
        rename = "symbolStrokeColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_stroke_color: Option<LegendSubtype0SymbolStrokeColor>,
    #[serde(
        rename = "symbolStrokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_stroke_width: Option<LegendSubtype0SymbolStrokeWidth>,
    #[serde(
        rename = "symbolType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub symbol_type: Option<LegendSubtype0SymbolType>,
    #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
    pub tick_count: Option<TickCount>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_min_step: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_align: Option<LegendSubtype0TitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_anchor: Option<LegendSubtype0TitleAnchor>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_baseline: Option<LegendSubtype0TitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_color: Option<LegendSubtype0TitleColor>,
    #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
    pub title_font: Option<LegendSubtype0TitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_size: Option<LegendSubtype0TitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_style: Option<LegendSubtype0TitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_weight: Option<LegendSubtype0TitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_limit: Option<LegendSubtype0TitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_line_height: Option<LegendSubtype0TitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_opacity: Option<LegendSubtype0TitleOpacity>,
    #[serde(
        rename = "titleOrient",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_orient: Option<LegendSubtype0TitleOrient>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_padding: Option<LegendSubtype0TitlePadding>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<LegendSubtype0Type>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<f64>,
}
impl From<&LegendSubtype0> for LegendSubtype0 {
    fn from(value: &LegendSubtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0CornerRadius> for LegendSubtype0CornerRadius {
    fn from(value: &LegendSubtype0CornerRadius) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&LegendSubtype0Direction> for LegendSubtype0Direction {
    fn from(value: &LegendSubtype0Direction) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0Direction {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0Direction {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0Direction {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0Direction {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendSubtype0Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&LegendSubtype0Encode> for LegendSubtype0Encode {
    fn from(value: &LegendSubtype0Encode) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0FillColor> for LegendSubtype0FillColor {
    fn from(value: &LegendSubtype0FillColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendSubtype0Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&LegendSubtype0Format> for LegendSubtype0Format {
    fn from(value: &LegendSubtype0Format) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0FormatType {
    Variant0(LegendSubtype0FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&LegendSubtype0FormatType> for LegendSubtype0FormatType {
    fn from(value: &LegendSubtype0FormatType) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&LegendSubtype0FormatTypeVariant0> for LegendSubtype0FormatTypeVariant0 {
    fn from(value: &LegendSubtype0FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0FormatTypeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0FormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0FormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0FormatTypeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0GradientOpacity> for LegendSubtype0GradientOpacity {
    fn from(value: &LegendSubtype0GradientOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0GradientStrokeColor> for LegendSubtype0GradientStrokeColor {
    fn from(value: &LegendSubtype0GradientStrokeColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0GradientStrokeWidth> for LegendSubtype0GradientStrokeWidth {
    fn from(value: &LegendSubtype0GradientStrokeWidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0GridAlign {
    Variant0(LegendSubtype0GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&LegendSubtype0GridAlign> for LegendSubtype0GridAlign {
    fn from(value: &LegendSubtype0GridAlign) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&LegendSubtype0GridAlignVariant0> for LegendSubtype0GridAlignVariant0 {
    fn from(value: &LegendSubtype0GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0GridAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0GridAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0GridAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0GridAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelAlign {
    Variant0(LegendSubtype0LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&LegendSubtype0LabelAlign> for LegendSubtype0LabelAlign {
    fn from(value: &LegendSubtype0LabelAlign) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&LegendSubtype0LabelAlignVariant0> for LegendSubtype0LabelAlignVariant0 {
    fn from(value: &LegendSubtype0LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0LabelAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0LabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0LabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0LabelAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelBaseline {
    Variant0(LegendSubtype0LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&LegendSubtype0LabelBaseline> for LegendSubtype0LabelBaseline {
    fn from(value: &LegendSubtype0LabelBaseline) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&LegendSubtype0LabelBaselineVariant0> for LegendSubtype0LabelBaselineVariant0 {
    fn from(value: &LegendSubtype0LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0LabelBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0LabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0LabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0LabelBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0LabelColor> for LegendSubtype0LabelColor {
    fn from(value: &LegendSubtype0LabelColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&LegendSubtype0LabelFont> for LegendSubtype0LabelFont {
    fn from(value: &LegendSubtype0LabelFont) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LabelFontSize> for LegendSubtype0LabelFontSize {
    fn from(value: &LegendSubtype0LabelFontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&LegendSubtype0LabelFontStyle> for LegendSubtype0LabelFontStyle {
    fn from(value: &LegendSubtype0LabelFontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&LegendSubtype0LabelFontWeight> for LegendSubtype0LabelFontWeight {
    fn from(value: &LegendSubtype0LabelFontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LabelLimit> for LegendSubtype0LabelLimit {
    fn from(value: &LegendSubtype0LabelLimit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LabelOffset> for LegendSubtype0LabelOffset {
    fn from(value: &LegendSubtype0LabelOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LabelOpacity> for LegendSubtype0LabelOpacity {
    fn from(value: &LegendSubtype0LabelOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LegendX> for LegendSubtype0LegendX {
    fn from(value: &LegendSubtype0LegendX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0LegendY> for LegendSubtype0LegendY {
    fn from(value: &LegendSubtype0LegendY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0Offset> for LegendSubtype0Offset {
    fn from(value: &LegendSubtype0Offset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0Orient {
    Variant0(LegendSubtype0OrientVariant0),
    Variant1(SignalRef),
}
impl From<&LegendSubtype0Orient> for LegendSubtype0Orient {
    fn from(value: &LegendSubtype0Orient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&LegendSubtype0OrientVariant0> for LegendSubtype0OrientVariant0 {
    fn from(value: &LegendSubtype0OrientVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0OrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl Default for LegendSubtype0OrientVariant0 {
    fn default() -> Self {
        LegendSubtype0OrientVariant0::Right
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0Padding> for LegendSubtype0Padding {
    fn from(value: &LegendSubtype0Padding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0StrokeColor> for LegendSubtype0StrokeColor {
    fn from(value: &LegendSubtype0StrokeColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&LegendSubtype0SymbolDash> for LegendSubtype0SymbolDash {
    fn from(value: &LegendSubtype0SymbolDash) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0SymbolDashOffset> for LegendSubtype0SymbolDashOffset {
    fn from(value: &LegendSubtype0SymbolDashOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0SymbolFillColor> for LegendSubtype0SymbolFillColor {
    fn from(value: &LegendSubtype0SymbolFillColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0SymbolOffset> for LegendSubtype0SymbolOffset {
    fn from(value: &LegendSubtype0SymbolOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0SymbolOpacity> for LegendSubtype0SymbolOpacity {
    fn from(value: &LegendSubtype0SymbolOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0SymbolSize> for LegendSubtype0SymbolSize {
    fn from(value: &LegendSubtype0SymbolSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0SymbolStrokeColor> for LegendSubtype0SymbolStrokeColor {
    fn from(value: &LegendSubtype0SymbolStrokeColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0SymbolStrokeWidth> for LegendSubtype0SymbolStrokeWidth {
    fn from(value: &LegendSubtype0SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&LegendSubtype0SymbolType> for LegendSubtype0SymbolType {
    fn from(value: &LegendSubtype0SymbolType) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleAlign {
    Variant0(LegendSubtype0TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&LegendSubtype0TitleAlign> for LegendSubtype0TitleAlign {
    fn from(value: &LegendSubtype0TitleAlign) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&LegendSubtype0TitleAlignVariant0> for LegendSubtype0TitleAlignVariant0 {
    fn from(value: &LegendSubtype0TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleAlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0TitleAlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleAnchor {
    Variant0(Option<LegendSubtype0TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&LegendSubtype0TitleAnchor> for LegendSubtype0TitleAnchor {
    fn from(value: &LegendSubtype0TitleAnchor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&LegendSubtype0TitleAnchorVariant0> for LegendSubtype0TitleAnchorVariant0 {
    fn from(value: &LegendSubtype0TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleAnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0TitleAnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleBaseline {
    Variant0(LegendSubtype0TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&LegendSubtype0TitleBaseline> for LegendSubtype0TitleBaseline {
    fn from(value: &LegendSubtype0TitleBaseline) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&LegendSubtype0TitleBaselineVariant0> for LegendSubtype0TitleBaselineVariant0 {
    fn from(value: &LegendSubtype0TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleBaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0TitleBaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&LegendSubtype0TitleColor> for LegendSubtype0TitleColor {
    fn from(value: &LegendSubtype0TitleColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&LegendSubtype0TitleFont> for LegendSubtype0TitleFont {
    fn from(value: &LegendSubtype0TitleFont) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0TitleFontSize> for LegendSubtype0TitleFontSize {
    fn from(value: &LegendSubtype0TitleFontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&LegendSubtype0TitleFontStyle> for LegendSubtype0TitleFontStyle {
    fn from(value: &LegendSubtype0TitleFontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&LegendSubtype0TitleFontWeight> for LegendSubtype0TitleFontWeight {
    fn from(value: &LegendSubtype0TitleFontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0TitleLimit> for LegendSubtype0TitleLimit {
    fn from(value: &LegendSubtype0TitleLimit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0TitleLineHeight> for LegendSubtype0TitleLineHeight {
    fn from(value: &LegendSubtype0TitleLineHeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0TitleOpacity> for LegendSubtype0TitleOpacity {
    fn from(value: &LegendSubtype0TitleOpacity) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitleOrient {
    Variant0(LegendSubtype0TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&LegendSubtype0TitleOrient> for LegendSubtype0TitleOrient {
    fn from(value: &LegendSubtype0TitleOrient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&LegendSubtype0TitleOrientVariant0> for LegendSubtype0TitleOrientVariant0 {
    fn from(value: &LegendSubtype0TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0TitleOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0TitleOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0TitleOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0TitleOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype0TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&LegendSubtype0TitlePadding> for LegendSubtype0TitlePadding {
    fn from(value: &LegendSubtype0TitlePadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendSubtype0Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&LegendSubtype0Type> for LegendSubtype0Type {
    fn from(value: &LegendSubtype0Type) -> Self {
        value.clone()
    }
}
impl ToString for LegendSubtype0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendSubtype0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendSubtype0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendSubtype0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendSubtype0Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendSubtype1 {
    Variant0 {},
    Variant1 {},
    Variant2 {},
    Variant3 {},
    Variant4 {},
    Variant5 {},
    Variant6 {},
}
impl From<&LegendSubtype1> for LegendSubtype1 {
    fn from(value: &LegendSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinearGradient {
    pub gradient: LinearGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
impl From<&LinearGradient> for LinearGradient {
    fn from(value: &LinearGradient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinearGradientGradient {
    #[serde(rename = "linear")]
    Linear,
}
impl From<&LinearGradientGradient> for LinearGradientGradient {
    fn from(value: &LinearGradientGradient) -> Self {
        value.clone()
    }
}
impl ToString for LinearGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
        }
    }
}
impl std::str::FromStr for LinearGradientGradient {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linear" => Ok(Self::Linear),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinearGradientGradient {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinearGradientGradient {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinearGradientGradient {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinkpathTransform {
    #[serde(rename = "as", default = "defaults::linkpath_transform_as")]
    pub as_: LinkpathTransformAs,
    #[serde(default = "defaults::linkpath_transform_orient")]
    pub orient: LinkpathTransformOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require: Option<SignalRef>,
    #[serde(default = "defaults::linkpath_transform_shape")]
    pub shape: LinkpathTransformShape,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "sourceX", default = "defaults::linkpath_transform_source_x")]
    pub source_x: LinkpathTransformSourceX,
    #[serde(rename = "sourceY", default = "defaults::linkpath_transform_source_y")]
    pub source_y: LinkpathTransformSourceY,
    #[serde(rename = "targetX", default = "defaults::linkpath_transform_target_x")]
    pub target_x: LinkpathTransformTargetX,
    #[serde(rename = "targetY", default = "defaults::linkpath_transform_target_y")]
    pub target_y: LinkpathTransformTargetY,
    #[serde(rename = "type")]
    pub type_: LinkpathTransformType,
}
impl From<&LinkpathTransform> for LinkpathTransform {
    fn from(value: &LinkpathTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LinkpathTransformAs> for LinkpathTransformAs {
    fn from(value: &LinkpathTransformAs) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformAs {
    fn default() -> Self {
        LinkpathTransformAs::Variant0("path".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformOrient {
    Variant0(LinkpathTransformOrientVariant0),
    Variant1(SignalRef),
}
impl From<&LinkpathTransformOrient> for LinkpathTransformOrient {
    fn from(value: &LinkpathTransformOrient) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformOrient {
    fn default() -> Self {
        LinkpathTransformOrient::Variant0(LinkpathTransformOrientVariant0::Vertical)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformOrientVariant0 {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "radial")]
    Radial,
}
impl From<&LinkpathTransformOrientVariant0> for LinkpathTransformOrientVariant0 {
    fn from(value: &LinkpathTransformOrientVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformOrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformOrientVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformShape {
    Variant0(LinkpathTransformShapeVariant0),
    Variant1(SignalRef),
}
impl From<&LinkpathTransformShape> for LinkpathTransformShape {
    fn from(value: &LinkpathTransformShape) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformShape {
    fn default() -> Self {
        LinkpathTransformShape::Variant0(LinkpathTransformShapeVariant0::Line)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformShapeVariant0 {
    #[serde(rename = "line")]
    Line,
    #[serde(rename = "arc")]
    Arc,
    #[serde(rename = "curve")]
    Curve,
    #[serde(rename = "diagonal")]
    Diagonal,
    #[serde(rename = "orthogonal")]
    Orthogonal,
}
impl From<&LinkpathTransformShapeVariant0> for LinkpathTransformShapeVariant0 {
    fn from(value: &LinkpathTransformShapeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformShapeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Line => "line".to_string(),
            Self::Arc => "arc".to_string(),
            Self::Curve => "curve".to_string(),
            Self::Diagonal => "diagonal".to_string(),
            Self::Orthogonal => "orthogonal".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformShapeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "line" => Ok(Self::Line),
            "arc" => Ok(Self::Arc),
            "curve" => Ok(Self::Curve),
            "diagonal" => Ok(Self::Diagonal),
            "orthogonal" => Ok(Self::Orthogonal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformShapeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformShapeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformShapeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformSourceX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LinkpathTransformSourceX> for LinkpathTransformSourceX {
    fn from(value: &LinkpathTransformSourceX) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformSourceX {
    fn default() -> Self {
        LinkpathTransformSourceX::ScaleField(ScaleField(StringOrSignal::Variant0(
            "source.x".to_string(),
        )))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformSourceY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LinkpathTransformSourceY> for LinkpathTransformSourceY {
    fn from(value: &LinkpathTransformSourceY) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformSourceY {
    fn default() -> Self {
        LinkpathTransformSourceY::ScaleField(ScaleField(StringOrSignal::Variant0(
            "source.y".to_string(),
        )))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformTargetX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LinkpathTransformTargetX> for LinkpathTransformTargetX {
    fn from(value: &LinkpathTransformTargetX) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformTargetX {
    fn default() -> Self {
        LinkpathTransformTargetX::ScaleField(ScaleField(StringOrSignal::Variant0(
            "target.x".to_string(),
        )))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformTargetY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LinkpathTransformTargetY> for LinkpathTransformTargetY {
    fn from(value: &LinkpathTransformTargetY) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformTargetY {
    fn default() -> Self {
        LinkpathTransformTargetY::ScaleField(ScaleField(StringOrSignal::Variant0(
            "target.y".to_string(),
        )))
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformType {
    #[serde(rename = "linkpath")]
    Linkpath,
}
impl From<&LinkpathTransformType> for LinkpathTransformType {
    fn from(value: &LinkpathTransformType) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Linkpath => "linkpath".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linkpath" => Ok(Self::Linkpath),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Listener {
    Variant0(SignalRef),
    Variant1 { scale: String },
    Variant2(Stream),
}
impl From<&Listener> for Listener {
    fn from(value: &Listener) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LoessTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LoessTransformAs>,
    #[serde(default = "defaults::loess_transform_bandwidth")]
    pub bandwidth: LoessTransformBandwidth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<LoessTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LoessTransformType,
    pub x: LoessTransformX,
    pub y: LoessTransformY,
}
impl From<&LoessTransform> for LoessTransform {
    fn from(value: &LoessTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformAs {
    Variant0(Vec<LoessTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LoessTransformAs> for LoessTransformAs {
    fn from(value: &LoessTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LoessTransformAsVariant0Item> for LoessTransformAsVariant0Item {
    fn from(value: &LoessTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&LoessTransformBandwidth> for LoessTransformBandwidth {
    fn from(value: &LoessTransformBandwidth) -> Self {
        value.clone()
    }
}
impl Default for LoessTransformBandwidth {
    fn default() -> Self {
        LoessTransformBandwidth::Variant0(0.3_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformGroupby {
    Variant0(Vec<LoessTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LoessTransformGroupby> for LoessTransformGroupby {
    fn from(value: &LoessTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LoessTransformGroupbyVariant0Item> for LoessTransformGroupbyVariant0Item {
    fn from(value: &LoessTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LoessTransformType {
    #[serde(rename = "loess")]
    Loess,
}
impl From<&LoessTransformType> for LoessTransformType {
    fn from(value: &LoessTransformType) -> Self {
        value.clone()
    }
}
impl ToString for LoessTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Loess => "loess".to_string(),
        }
    }
}
impl std::str::FromStr for LoessTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "loess" => Ok(Self::Loess),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LoessTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LoessTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LoessTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LoessTransformX> for LoessTransformX {
    fn from(value: &LoessTransformX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LoessTransformY> for LoessTransformY {
    fn from(value: &LoessTransformY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LookupTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LookupTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    pub fields: LookupTransformFields,
    pub from: String,
    pub key: LookupTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LookupTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<LookupTransformValues>,
}
impl From<&LookupTransform> for LookupTransform {
    fn from(value: &LookupTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformAs {
    Variant0(Vec<LookupTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LookupTransformAs> for LookupTransformAs {
    fn from(value: &LookupTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&LookupTransformAsVariant0Item> for LookupTransformAsVariant0Item {
    fn from(value: &LookupTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformFields {
    Variant0(Vec<LookupTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LookupTransformFields> for LookupTransformFields {
    fn from(value: &LookupTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LookupTransformFieldsVariant0Item> for LookupTransformFieldsVariant0Item {
    fn from(value: &LookupTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LookupTransformKey> for LookupTransformKey {
    fn from(value: &LookupTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LookupTransformType {
    #[serde(rename = "lookup")]
    Lookup,
}
impl From<&LookupTransformType> for LookupTransformType {
    fn from(value: &LookupTransformType) -> Self {
        value.clone()
    }
}
impl ToString for LookupTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Lookup => "lookup".to_string(),
        }
    }
}
impl std::str::FromStr for LookupTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "lookup" => Ok(Self::Lookup),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for LookupTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LookupTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LookupTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformValues {
    Variant0(Vec<LookupTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl From<&LookupTransformValues> for LookupTransformValues {
    fn from(value: &LookupTransformValues) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformValuesVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&LookupTransformValuesVariant0Item> for LookupTransformValuesVariant0Item {
    fn from(value: &LookupTransformValuesVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Mark {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<Markclip>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interactive: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on: Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transform: Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
impl From<&Mark> for Mark {
    fn from(value: &Mark) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarkGroup {
    #[serde(flatten)]
    pub mark: Mark,
    #[serde(flatten)]
    pub scope: Scope,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<MarkGroupFrom>,
    #[serde(rename = "type")]
    pub type_: MarkGroupType,
}
impl From<&MarkGroup> for MarkGroup {
    fn from(value: &MarkGroup) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarkGroupFrom {
    From(From),
    Facet(Facet),
}
impl From<&MarkGroupFrom> for MarkGroupFrom {
    fn from(value: &MarkGroupFrom) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarkGroupType {
    #[serde(rename = "group")]
    Group,
}
impl From<&MarkGroupType> for MarkGroupType {
    fn from(value: &MarkGroupType) -> Self {
        value.clone()
    }
}
impl ToString for MarkGroupType {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
        }
    }
}
impl std::str::FromStr for MarkGroupType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "group" => Ok(Self::Group),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for MarkGroupType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarkGroupType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarkGroupType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarkVisual {
    #[serde(flatten)]
    pub mark: Mark,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<From>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<MarkVisualType>,
}
impl From<&MarkVisual> for MarkVisual {
    fn from(value: &MarkVisual) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct MarkVisualType(String);
impl std::ops::Deref for MarkVisualType {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<MarkVisualType> for String {
    fn from(value: MarkVisualType) -> Self {
        value.0
    }
}
impl From<&MarkVisualType> for MarkVisualType {
    fn from(value: &MarkVisualType) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<String> for MarkVisualType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if ["group".to_string()].contains(&value) {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for MarkVisualType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(String::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Markclip {
    Variant0(BooleanOrSignal),
    Variant1 { path: StringOrSignal },
    Variant2 { sphere: StringOrSignal },
}
impl From<&Markclip> for Markclip {
    fn from(value: &Markclip) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Marktype(pub String);
impl std::ops::Deref for Marktype {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Marktype> for String {
    fn from(value: Marktype) -> Self {
        value.0
    }
}
impl From<&Marktype> for Marktype {
    fn from(value: &Marktype) -> Self {
        value.clone()
    }
}
impl From<String> for Marktype {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Marktype {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Marktype {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NestTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generate: Option<NestTransformGenerate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keys: Option<NestTransformKeys>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: NestTransformType,
}
impl From<&NestTransform> for NestTransform {
    fn from(value: &NestTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformGenerate {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&NestTransformGenerate> for NestTransformGenerate {
    fn from(value: &NestTransformGenerate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformKeys {
    Variant0(Vec<NestTransformKeysVariant0Item>),
    Variant1(SignalRef),
}
impl From<&NestTransformKeys> for NestTransformKeys {
    fn from(value: &NestTransformKeys) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformKeysVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&NestTransformKeysVariant0Item> for NestTransformKeysVariant0Item {
    fn from(value: &NestTransformKeysVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum NestTransformType {
    #[serde(rename = "nest")]
    Nest,
}
impl From<&NestTransformType> for NestTransformType {
    fn from(value: &NestTransformType) -> Self {
        value.clone()
    }
}
impl ToString for NestTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Nest => "nest".to_string(),
        }
    }
}
impl std::str::FromStr for NestTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "nest" => Ok(Self::Nest),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for NestTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NestTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NestTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub band: Option<NumberModifiersBand>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exponent: Option<NumberModifiersExponent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mult: Option<NumberModifiersMult>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<NumberModifiersOffset>,
    #[serde(default)]
    pub round: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
impl From<&NumberModifiers> for NumberModifiers {
    fn from(value: &NumberModifiers) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersBand {
    Variant0(f64),
    Variant1(bool),
}
impl From<&NumberModifiersBand> for NumberModifiersBand {
    fn from(value: &NumberModifiersBand) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberModifiersBand {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for NumberModifiersBand {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberModifiersBand {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberModifiersBand {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for NumberModifiersBand {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersExponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&NumberModifiersExponent> for NumberModifiersExponent {
    fn from(value: &NumberModifiersExponent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersMult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&NumberModifiersMult> for NumberModifiersMult {
    fn from(value: &NumberModifiersMult) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&NumberModifiersOffset> for NumberModifiersOffset {
    fn from(value: &NumberModifiersOffset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberOrSignal {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&NumberOrSignal> for NumberOrSignal {
    fn from(value: &NumberOrSignal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValue {
    Variant0(Vec<NumberValueVariant0Item>),
    Variant1(NumberValueVariant1),
}
impl From<&NumberValue> for NumberValue {
    fn from(value: &NumberValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant0ItemSubtype1,
}
impl From<&NumberValueVariant0Item> for NumberValueVariant0Item {
    fn from(value: &NumberValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: NumberModifiers,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant0ItemSubtype1Subtype1,
}
impl From<&NumberValueVariant0ItemSubtype1> for NumberValueVariant0ItemSubtype1 {
    fn from(value: &NumberValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<NumberValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&NumberValueVariant0ItemSubtype1Subtype1> for NumberValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: f64,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&NumberValueVariant0ItemSubtype1Subtype1Subtype0>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&NumberValueVariant0ItemSubtype1Subtype1Subtype1>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&NumberValueVariant0ItemSubtype1Subtype1Subtype2>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&NumberValueVariant0ItemSubtype1Subtype1Subtype3>
    for NumberValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &NumberValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: NumberModifiers,
    #[serde(flatten)]
    pub subtype_1: NumberValueVariant1Subtype1,
}
impl From<&NumberValueVariant1> for NumberValueVariant1 {
    fn from(value: &NumberValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<NumberValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<NumberValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<NumberValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<NumberValueVariant1Subtype1Subtype3>,
}
impl From<&NumberValueVariant1Subtype1> for NumberValueVariant1Subtype1 {
    fn from(value: &NumberValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: f64,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: NumberValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&NumberValueVariant1Subtype1Subtype0> for NumberValueVariant1Subtype1Subtype0 {
    fn from(value: &NumberValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&NumberValueVariant1Subtype1Subtype0Variant3Range>
    for NumberValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &NumberValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype1 {}
impl From<&NumberValueVariant1Subtype1Subtype1> for NumberValueVariant1Subtype1Subtype1 {
    fn from(value: &NumberValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype2 {}
impl From<&NumberValueVariant1Subtype1Subtype2> for NumberValueVariant1Subtype1Subtype2 {
    fn from(value: &NumberValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberValueVariant1Subtype1Subtype3 {}
impl From<&NumberValueVariant1Subtype1Subtype3> for NumberValueVariant1Subtype1Subtype3 {
    fn from(value: &NumberValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnEvents(pub Vec<OnEventsItem>);
impl std::ops::Deref for OnEvents {
    type Target = Vec<OnEventsItem>;
    fn deref(&self) -> &Vec<OnEventsItem> {
        &self.0
    }
}
impl From<OnEvents> for Vec<OnEventsItem> {
    fn from(value: OnEvents) -> Self {
        value.0
    }
}
impl From<&OnEvents> for OnEvents {
    fn from(value: &OnEvents) -> Self {
        value.clone()
    }
}
impl From<Vec<OnEventsItem>> for OnEvents {
    fn from(value: Vec<OnEventsItem>) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnEventsItem {
    #[serde(flatten)]
    pub subtype_0: OnEventsItemSubtype0,
    #[serde(flatten)]
    pub subtype_1: OnEventsItemSubtype1,
}
impl From<&OnEventsItem> for OnEventsItem {
    fn from(value: &OnEventsItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnEventsItemSubtype0 {
    pub events: OnEventsItemSubtype0Events,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub force: Option<bool>,
}
impl From<&OnEventsItemSubtype0> for OnEventsItemSubtype0 {
    fn from(value: &OnEventsItemSubtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItemSubtype0Events {
    Variant0(Selector),
    Variant1(Listener),
    Variant2(Vec<Listener>),
}
impl From<&OnEventsItemSubtype0Events> for OnEventsItemSubtype0Events {
    fn from(value: &OnEventsItemSubtype0Events) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum OnEventsItemSubtype1 {
    #[serde(rename = "encode")]
    Encode(String),
    #[serde(rename = "update")]
    Update(OnEventsItemSubtype1Update),
}
impl From<&OnEventsItemSubtype1> for OnEventsItemSubtype1 {
    fn from(value: &OnEventsItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItemSubtype1Update {
    Variant0(ExprString),
    Variant1(Expr),
    Variant2(SignalRef),
    Variant3 { value: serde_json::Value },
}
impl From<&OnEventsItemSubtype1Update> for OnEventsItemSubtype1Update {
    fn from(value: &OnEventsItemSubtype1Update) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnMarkTrigger(pub Vec<OnMarkTriggerItem>);
impl std::ops::Deref for OnMarkTrigger {
    type Target = Vec<OnMarkTriggerItem>;
    fn deref(&self) -> &Vec<OnMarkTriggerItem> {
        &self.0
    }
}
impl From<OnMarkTrigger> for Vec<OnMarkTriggerItem> {
    fn from(value: OnMarkTrigger) -> Self {
        value.0
    }
}
impl From<&OnMarkTrigger> for OnMarkTrigger {
    fn from(value: &OnMarkTrigger) -> Self {
        value.clone()
    }
}
impl From<Vec<OnMarkTriggerItem>> for OnMarkTrigger {
    fn from(value: Vec<OnMarkTriggerItem>) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnMarkTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
impl From<&OnMarkTriggerItem> for OnMarkTriggerItem {
    fn from(value: &OnMarkTriggerItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnTrigger(pub Vec<OnTriggerItem>);
impl std::ops::Deref for OnTrigger {
    type Target = Vec<OnTriggerItem>;
    fn deref(&self) -> &Vec<OnTriggerItem> {
        &self.0
    }
}
impl From<OnTrigger> for Vec<OnTriggerItem> {
    fn from(value: OnTrigger) -> Self {
        value.0
    }
}
impl From<&OnTrigger> for OnTrigger {
    fn from(value: &OnTrigger) -> Self {
        value.clone()
    }
}
impl From<Vec<OnTriggerItem>> for OnTrigger {
    fn from(value: Vec<OnTriggerItem>) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insert: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<OnTriggerItemRemove>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub toggle: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
impl From<&OnTriggerItem> for OnTriggerItem {
    fn from(value: &OnTriggerItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnTriggerItemRemove {
    Variant0(bool),
    Variant1(ExprString),
}
impl From<&OnTriggerItemRemove> for OnTriggerItemRemove {
    fn from(value: &OnTriggerItemRemove) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OnTriggerItemRemove {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for OnTriggerItemRemove {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OnTriggerItemRemove {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OnTriggerItemRemove {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for OnTriggerItemRemove {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValue {
    Variant0(Vec<OrientValueVariant0Item>),
    Variant1(OrientValueVariant1),
}
impl From<&OrientValue> for OrientValue {
    fn from(value: &OrientValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant0ItemSubtype1,
}
impl From<&OrientValueVariant0Item> for OrientValueVariant0Item {
    fn from(value: &OrientValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant0ItemSubtype1Subtype1,
}
impl From<&OrientValueVariant0ItemSubtype1> for OrientValueVariant0ItemSubtype1 {
    fn from(value: &OrientValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<OrientValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&OrientValueVariant0ItemSubtype1Subtype1> for OrientValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype0>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for OrientValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype1>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype2>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&OrientValueVariant0ItemSubtype1Subtype1Subtype3>
    for OrientValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &OrientValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: OrientValueVariant1Subtype1,
}
impl From<&OrientValueVariant1> for OrientValueVariant1 {
    fn from(value: &OrientValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<OrientValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<OrientValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<OrientValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<OrientValueVariant1Subtype1Subtype3>,
}
impl From<&OrientValueVariant1Subtype1> for OrientValueVariant1Subtype1 {
    fn from(value: &OrientValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: OrientValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: OrientValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&OrientValueVariant1Subtype1Subtype0> for OrientValueVariant1Subtype1Subtype0 {
    fn from(value: &OrientValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrientValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&OrientValueVariant1Subtype1Subtype0Variant1Value>
    for OrientValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &OrientValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for OrientValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&OrientValueVariant1Subtype1Subtype0Variant3Range>
    for OrientValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &OrientValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OrientValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for OrientValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype1 {}
impl From<&OrientValueVariant1Subtype1Subtype1> for OrientValueVariant1Subtype1Subtype1 {
    fn from(value: &OrientValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype2 {}
impl From<&OrientValueVariant1Subtype1Subtype2> for OrientValueVariant1Subtype1Subtype2 {
    fn from(value: &OrientValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OrientValueVariant1Subtype1Subtype3 {}
impl From<&OrientValueVariant1Subtype1Subtype3> for OrientValueVariant1Subtype1Subtype3 {
    fn from(value: &OrientValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackTransform {
    #[serde(rename = "as", default = "defaults::pack_transform_as")]
    pub as_: PackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PackTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<PackTransformRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PackTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PackTransformType,
}
impl From<&PackTransform> for PackTransform {
    fn from(value: &PackTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformAs {
    Variant0(
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
        PackTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&PackTransformAs> for PackTransformAs {
    fn from(value: &PackTransformAs) -> Self {
        value.clone()
    }
}
impl Default for PackTransformAs {
    fn default() -> Self {
        PackTransformAs::Variant0(
            PackTransformAsVariant0::Variant0("x".to_string()),
            PackTransformAsVariant0::Variant0("y".to_string()),
            PackTransformAsVariant0::Variant0("r".to_string()),
            PackTransformAsVariant0::Variant0("depth".to_string()),
            PackTransformAsVariant0::Variant0("children".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&PackTransformAsVariant0> for PackTransformAsVariant0 {
    fn from(value: &PackTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PackTransformField> for PackTransformField {
    fn from(value: &PackTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PackTransformPadding> for PackTransformPadding {
    fn from(value: &PackTransformPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformRadius {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PackTransformRadius> for PackTransformRadius {
    fn from(value: &PackTransformRadius) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformSize {
    Variant0(PackTransformSizeVariant0, PackTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&PackTransformSize> for PackTransformSize {
    fn from(value: &PackTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PackTransformSizeVariant0> for PackTransformSizeVariant0 {
    fn from(value: &PackTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackTransformType {
    #[serde(rename = "pack")]
    Pack,
}
impl From<&PackTransformType> for PackTransformType {
    fn from(value: &PackTransformType) -> Self {
        value.clone()
    }
}
impl ToString for PackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pack => "pack".to_string(),
        }
    }
}
impl std::str::FromStr for PackTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pack" => Ok(Self::Pack),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PackTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Padding {
    Variant0(f64),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bottom: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        left: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        right: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        top: Option<f64>,
    },
    Variant2(SignalRef),
}
impl From<&Padding> for Padding {
    fn from(value: &Padding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParamField {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub field: String,
}
impl From<&ParamField> for ParamField {
    fn from(value: &ParamField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PartitionTransform {
    #[serde(rename = "as", default = "defaults::partition_transform_as")]
    pub as_: PartitionTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PartitionTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PartitionTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<PartitionTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PartitionTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PartitionTransformType,
}
impl From<&PartitionTransform> for PartitionTransform {
    fn from(value: &PartitionTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformAs {
    Variant0(
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
        PartitionTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&PartitionTransformAs> for PartitionTransformAs {
    fn from(value: &PartitionTransformAs) -> Self {
        value.clone()
    }
}
impl Default for PartitionTransformAs {
    fn default() -> Self {
        PartitionTransformAs::Variant0(
            PartitionTransformAsVariant0::Variant0("x0".to_string()),
            PartitionTransformAsVariant0::Variant0("y0".to_string()),
            PartitionTransformAsVariant0::Variant0("x1".to_string()),
            PartitionTransformAsVariant0::Variant0("y1".to_string()),
            PartitionTransformAsVariant0::Variant0("depth".to_string()),
            PartitionTransformAsVariant0::Variant0("children".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&PartitionTransformAsVariant0> for PartitionTransformAsVariant0 {
    fn from(value: &PartitionTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PartitionTransformField> for PartitionTransformField {
    fn from(value: &PartitionTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PartitionTransformPadding> for PartitionTransformPadding {
    fn from(value: &PartitionTransformPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&PartitionTransformRound> for PartitionTransformRound {
    fn from(value: &PartitionTransformRound) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformSize {
    Variant0(
        PartitionTransformSizeVariant0,
        PartitionTransformSizeVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&PartitionTransformSize> for PartitionTransformSize {
    fn from(value: &PartitionTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PartitionTransformSizeVariant0> for PartitionTransformSizeVariant0 {
    fn from(value: &PartitionTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PartitionTransformType {
    #[serde(rename = "partition")]
    Partition,
}
impl From<&PartitionTransformType> for PartitionTransformType {
    fn from(value: &PartitionTransformType) -> Self {
        value.clone()
    }
}
impl ToString for PartitionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Partition => "partition".to_string(),
        }
    }
}
impl std::str::FromStr for PartitionTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "partition" => Ok(Self::Partition),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PartitionTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PartitionTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PartitionTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PieTransform {
    #[serde(rename = "as", default = "defaults::pie_transform_as")]
    pub as_: PieTransformAs,
    #[serde(rename = "endAngle", default = "defaults::pie_transform_end_angle")]
    pub end_angle: PieTransformEndAngle,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PieTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<PieTransformSort>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<PieTransformStartAngle>,
    #[serde(rename = "type")]
    pub type_: PieTransformType,
}
impl From<&PieTransform> for PieTransform {
    fn from(value: &PieTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformAs {
    Variant0(PieTransformAsVariant0, PieTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&PieTransformAs> for PieTransformAs {
    fn from(value: &PieTransformAs) -> Self {
        value.clone()
    }
}
impl Default for PieTransformAs {
    fn default() -> Self {
        PieTransformAs::Variant0(
            PieTransformAsVariant0::Variant0("startAngle".to_string()),
            PieTransformAsVariant0::Variant0("endAngle".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&PieTransformAsVariant0> for PieTransformAsVariant0 {
    fn from(value: &PieTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformEndAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PieTransformEndAngle> for PieTransformEndAngle {
    fn from(value: &PieTransformEndAngle) -> Self {
        value.clone()
    }
}
impl Default for PieTransformEndAngle {
    fn default() -> Self {
        PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PieTransformField> for PieTransformField {
    fn from(value: &PieTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformSort {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&PieTransformSort> for PieTransformSort {
    fn from(value: &PieTransformSort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformStartAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PieTransformStartAngle> for PieTransformStartAngle {
    fn from(value: &PieTransformStartAngle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PieTransformType {
    #[serde(rename = "pie")]
    Pie,
}
impl From<&PieTransformType> for PieTransformType {
    fn from(value: &PieTransformType) -> Self {
        value.clone()
    }
}
impl ToString for PieTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pie => "pie".to_string(),
        }
    }
}
impl std::str::FromStr for PieTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pie" => Ok(Self::Pie),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PieTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PieTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PieTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PivotTransform {
    pub field: PivotTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<PivotTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<PivotTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<PivotTransformLimit>,
    #[serde(default = "defaults::pivot_transform_op")]
    pub op: PivotTransformOp,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: PivotTransformType,
    pub value: PivotTransformValue,
}
impl From<&PivotTransform> for PivotTransform {
    fn from(value: &PivotTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PivotTransformField> for PivotTransformField {
    fn from(value: &PivotTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformGroupby {
    Variant0(Vec<PivotTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&PivotTransformGroupby> for PivotTransformGroupby {
    fn from(value: &PivotTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PivotTransformGroupbyVariant0Item> for PivotTransformGroupbyVariant0Item {
    fn from(value: &PivotTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PivotTransformKey> for PivotTransformKey {
    fn from(value: &PivotTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformLimit {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&PivotTransformLimit> for PivotTransformLimit {
    fn from(value: &PivotTransformLimit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformOp {
    Variant0(PivotTransformOpVariant0),
    Variant1(SignalRef),
}
impl From<&PivotTransformOp> for PivotTransformOp {
    fn from(value: &PivotTransformOp) -> Self {
        value.clone()
    }
}
impl Default for PivotTransformOp {
    fn default() -> Self {
        PivotTransformOp::Variant0(PivotTransformOpVariant0::Sum)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PivotTransformOpVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&PivotTransformOpVariant0> for PivotTransformOpVariant0 {
    fn from(value: &PivotTransformOpVariant0) -> Self {
        value.clone()
    }
}
impl ToString for PivotTransformOpVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformOpVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformOpVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformOpVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PivotTransformOpVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PivotTransformType {
    #[serde(rename = "pivot")]
    Pivot,
}
impl From<&PivotTransformType> for PivotTransformType {
    fn from(value: &PivotTransformType) -> Self {
        value.clone()
    }
}
impl ToString for PivotTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pivot => "pivot".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pivot" => Ok(Self::Pivot),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PivotTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformValue {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&PivotTransformValue> for PivotTransformValue {
    fn from(value: &PivotTransformValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<ProjectTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<ProjectTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ProjectTransformType,
}
impl From<&ProjectTransform> for ProjectTransform {
    fn from(value: &ProjectTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformAs {
    Variant0(Vec<ProjectTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ProjectTransformAs> for ProjectTransformAs {
    fn from(value: &ProjectTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&ProjectTransformAsVariant0Item> for ProjectTransformAsVariant0Item {
    fn from(value: &ProjectTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformFields {
    Variant0(Vec<ProjectTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&ProjectTransformFields> for ProjectTransformFields {
    fn from(value: &ProjectTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&ProjectTransformFieldsVariant0Item> for ProjectTransformFieldsVariant0Item {
    fn from(value: &ProjectTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectTransformType {
    #[serde(rename = "project")]
    Project,
}
impl From<&ProjectTransformType> for ProjectTransformType {
    fn from(value: &ProjectTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ProjectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Project => "project".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "project" => Ok(Self::Project),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Projection {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub center: Option<ProjectionCenter>,
    #[serde(rename = "clipAngle", default, skip_serializing_if = "Option::is_none")]
    pub clip_angle: Option<NumberOrSignal>,
    #[serde(
        rename = "clipExtent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub clip_extent: Option<ProjectionClipExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<ProjectionExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fit: Option<ProjectionFit>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallels: Option<ProjectionParallels>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub precision: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<ProjectionRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<ProjectionSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<ProjectionTranslate>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&Projection> for Projection {
    fn from(value: &Projection) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionCenter {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionCenter> for ProjectionCenter {
    fn from(value: &ProjectionCenter) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionClipExtent {
    Variant0(ProjectionClipExtentVariant0, ProjectionClipExtentVariant0),
    Variant1(SignalRef),
}
impl From<&ProjectionClipExtent> for ProjectionClipExtent {
    fn from(value: &ProjectionClipExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionClipExtentVariant0 {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionClipExtentVariant0> for ProjectionClipExtentVariant0 {
    fn from(value: &ProjectionClipExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionExtent {
    Variant0(ProjectionExtentVariant0, ProjectionExtentVariant0),
    Variant1(SignalRef),
}
impl From<&ProjectionExtent> for ProjectionExtent {
    fn from(value: &ProjectionExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionExtentVariant0 {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionExtentVariant0> for ProjectionExtentVariant0 {
    fn from(value: &ProjectionExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionFit {
    Variant0(serde_json::Map<String, serde_json::Value>),
    Variant1(Vec<serde_json::Value>),
}
impl From<&ProjectionFit> for ProjectionFit {
    fn from(value: &ProjectionFit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionParallels {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionParallels> for ProjectionParallels {
    fn from(value: &ProjectionParallels) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionRotate {
    Variant0(Vec<NumberOrSignal>),
    Variant1(SignalRef),
}
impl From<&ProjectionRotate> for ProjectionRotate {
    fn from(value: &ProjectionRotate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionSize {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionSize> for ProjectionSize {
    fn from(value: &ProjectionSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionTranslate {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ProjectionTranslate> for ProjectionTranslate {
    fn from(value: &ProjectionTranslate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct QuantileTransform {
    #[serde(rename = "as", default = "defaults::quantile_transform_as")]
    pub as_: QuantileTransformAs,
    pub field: QuantileTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<QuantileTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probs: Option<QuantileTransformProbs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::quantile_transform_step")]
    pub step: QuantileTransformStep,
    #[serde(rename = "type")]
    pub type_: QuantileTransformType,
}
impl From<&QuantileTransform> for QuantileTransform {
    fn from(value: &QuantileTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformAs {
    Variant0(Vec<QuantileTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&QuantileTransformAs> for QuantileTransformAs {
    fn from(value: &QuantileTransformAs) -> Self {
        value.clone()
    }
}
impl Default for QuantileTransformAs {
    fn default() -> Self {
        QuantileTransformAs::Variant0(vec![
            QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&QuantileTransformAsVariant0Item> for QuantileTransformAsVariant0Item {
    fn from(value: &QuantileTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&QuantileTransformField> for QuantileTransformField {
    fn from(value: &QuantileTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformGroupby {
    Variant0(Vec<QuantileTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&QuantileTransformGroupby> for QuantileTransformGroupby {
    fn from(value: &QuantileTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&QuantileTransformGroupbyVariant0Item> for QuantileTransformGroupbyVariant0Item {
    fn from(value: &QuantileTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformProbs {
    Variant0(Vec<QuantileTransformProbsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&QuantileTransformProbs> for QuantileTransformProbs {
    fn from(value: &QuantileTransformProbs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformProbsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&QuantileTransformProbsVariant0Item> for QuantileTransformProbsVariant0Item {
    fn from(value: &QuantileTransformProbsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&QuantileTransformStep> for QuantileTransformStep {
    fn from(value: &QuantileTransformStep) -> Self {
        value.clone()
    }
}
impl Default for QuantileTransformStep {
    fn default() -> Self {
        QuantileTransformStep::Variant0(0.01_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum QuantileTransformType {
    #[serde(rename = "quantile")]
    Quantile,
}
impl From<&QuantileTransformType> for QuantileTransformType {
    fn from(value: &QuantileTransformType) -> Self {
        value.clone()
    }
}
impl ToString for QuantileTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for QuantileTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for QuantileTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for QuantileTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for QuantileTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RadialGradient {
    pub gradient: RadialGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r2: Option<f64>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
impl From<&RadialGradient> for RadialGradient {
    fn from(value: &RadialGradient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RadialGradientGradient {
    #[serde(rename = "radial")]
    Radial,
}
impl From<&RadialGradientGradient> for RadialGradientGradient {
    fn from(value: &RadialGradientGradient) -> Self {
        value.clone()
    }
}
impl ToString for RadialGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for RadialGradientGradient {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RadialGradientGradient {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RadialGradientGradient {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RadialGradientGradient {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegressionTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<RegressionTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<RegressionTransformExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<RegressionTransformGroupby>,
    #[serde(default = "defaults::regression_transform_method")]
    pub method: RegressionTransformMethod,
    #[serde(default = "defaults::regression_transform_order")]
    pub order: RegressionTransformOrder,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<RegressionTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: RegressionTransformType,
    pub x: RegressionTransformX,
    pub y: RegressionTransformY,
}
impl From<&RegressionTransform> for RegressionTransform {
    fn from(value: &RegressionTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformAs {
    Variant0(Vec<RegressionTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&RegressionTransformAs> for RegressionTransformAs {
    fn from(value: &RegressionTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&RegressionTransformAsVariant0Item> for RegressionTransformAsVariant0Item {
    fn from(value: &RegressionTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformExtent {
    Variant0(
        RegressionTransformExtentVariant0,
        RegressionTransformExtentVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&RegressionTransformExtent> for RegressionTransformExtent {
    fn from(value: &RegressionTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformExtentVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&RegressionTransformExtentVariant0> for RegressionTransformExtentVariant0 {
    fn from(value: &RegressionTransformExtentVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformGroupby {
    Variant0(Vec<RegressionTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&RegressionTransformGroupby> for RegressionTransformGroupby {
    fn from(value: &RegressionTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&RegressionTransformGroupbyVariant0Item> for RegressionTransformGroupbyVariant0Item {
    fn from(value: &RegressionTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&RegressionTransformMethod> for RegressionTransformMethod {
    fn from(value: &RegressionTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for RegressionTransformMethod {
    fn default() -> Self {
        RegressionTransformMethod::Variant0("linear".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformOrder {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&RegressionTransformOrder> for RegressionTransformOrder {
    fn from(value: &RegressionTransformOrder) -> Self {
        value.clone()
    }
}
impl Default for RegressionTransformOrder {
    fn default() -> Self {
        RegressionTransformOrder::Variant0(3_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformParams {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&RegressionTransformParams> for RegressionTransformParams {
    fn from(value: &RegressionTransformParams) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegressionTransformType {
    #[serde(rename = "regression")]
    Regression,
}
impl From<&RegressionTransformType> for RegressionTransformType {
    fn from(value: &RegressionTransformType) -> Self {
        value.clone()
    }
}
impl ToString for RegressionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Regression => "regression".to_string(),
        }
    }
}
impl std::str::FromStr for RegressionTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "regression" => Ok(Self::Regression),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for RegressionTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RegressionTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RegressionTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&RegressionTransformX> for RegressionTransformX {
    fn from(value: &RegressionTransformX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&RegressionTransformY> for RegressionTransformY {
    fn from(value: &RegressionTransformY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ResolvefilterTransform {
    pub filter: serde_json::Value,
    pub ignore: ResolvefilterTransformIgnore,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ResolvefilterTransformType,
}
impl From<&ResolvefilterTransform> for ResolvefilterTransform {
    fn from(value: &ResolvefilterTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ResolvefilterTransformIgnore {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&ResolvefilterTransformIgnore> for ResolvefilterTransformIgnore {
    fn from(value: &ResolvefilterTransformIgnore) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ResolvefilterTransformType {
    #[serde(rename = "resolvefilter")]
    Resolvefilter,
}
impl From<&ResolvefilterTransformType> for ResolvefilterTransformType {
    fn from(value: &ResolvefilterTransformType) -> Self {
        value.clone()
    }
}
impl ToString for ResolvefilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolvefilter => "resolvefilter".to_string(),
        }
    }
}
impl std::str::FromStr for ResolvefilterTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "resolvefilter" => Ok(Self::Resolvefilter),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ResolvefilterTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ResolvefilterTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ResolvefilterTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Rule {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<String>,
}
impl From<&Rule> for Rule {
    fn from(value: &Rule) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SampleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::sample_transform_size")]
    pub size: SampleTransformSize,
    #[serde(rename = "type")]
    pub type_: SampleTransformType,
}
impl From<&SampleTransform> for SampleTransform {
    fn from(value: &SampleTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SampleTransformSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&SampleTransformSize> for SampleTransformSize {
    fn from(value: &SampleTransformSize) -> Self {
        value.clone()
    }
}
impl Default for SampleTransformSize {
    fn default() -> Self {
        SampleTransformSize::Variant0(1000_f64)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SampleTransformType {
    #[serde(rename = "sample")]
    Sample,
}
impl From<&SampleTransformType> for SampleTransformType {
    fn from(value: &SampleTransformType) -> Self {
        value.clone()
    }
}
impl ToString for SampleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sample => "sample".to_string(),
        }
    }
}
impl std::str::FromStr for SampleTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "sample" => Ok(Self::Sample),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SampleTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SampleTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SampleTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Scale {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant0Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant0DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant1Domain>,
        #[serde(
            rename = "domainImplicit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        domain_implicit: Option<BooleanOrSignal>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant1DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant1Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant1Type,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant2Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant2DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingInner",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_inner: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant2Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant2Type,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant3Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant3DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant3Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant3Type,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant4Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant4DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant4Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant4Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant4Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant5Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant5DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant5Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant5Type,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant6Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant6DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant6Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant6Type,
    },
    Variant7 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant7Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant7DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant7Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant7Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant7Type,
    },
    Variant8 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant8Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant8DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant8Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant8Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<ScaleVariant8Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant9 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        base: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant9Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant9DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant9Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant9Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant9Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant10 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant10Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant10DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant10Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant10Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant10Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant11 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        constant: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant11Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant11DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant11Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant11Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant11Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
}
impl From<&Scale> for Scale {
    fn from(value: &Scale) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleBins {
    Variant0(Vec<NumberOrSignal>),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start: Option<NumberOrSignal>,
        step: NumberOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        stop: Option<NumberOrSignal>,
    },
    Variant2(SignalRef),
}
impl From<&ScaleBins> for ScaleBins {
    fn from(value: &ScaleBins) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleData {
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleDataVariant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant2Sort>,
    },
}
impl From<&ScaleData> for ScaleData {
    fn from(value: &ScaleData) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleDataVariant0Sort> for ScaleDataVariant0Sort {
    fn from(value: &ScaleDataVariant0Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleDataVariant1Sort> for ScaleDataVariant1Sort {
    fn from(value: &ScaleDataVariant1Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&ScaleDataVariant1SortVariant1Op> for ScaleDataVariant1SortVariant1Op {
    fn from(value: &ScaleDataVariant1SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&ScaleDataVariant1SortVariant2Op> for ScaleDataVariant1SortVariant2Op {
    fn from(value: &ScaleDataVariant1SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2FieldsItem {
    Variant0 { data: String, field: StringOrSignal },
    Variant1(Vec<ScaleDataVariant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleDataVariant2FieldsItem> for ScaleDataVariant2FieldsItem {
    fn from(value: &ScaleDataVariant2FieldsItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleDataVariant2FieldsItemVariant1Item {
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
impl From<&ScaleDataVariant2FieldsItemVariant1Item> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: &ScaleDataVariant2FieldsItemVariant1Item) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ScaleDataVariant2FieldsItemVariant1Item {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for ScaleDataVariant2FieldsItemVariant1Item {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
            Self::Variant2(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleDataVariant2Sort> for ScaleDataVariant2Sort {
    fn from(value: &ScaleDataVariant2Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&ScaleDataVariant2SortVariant1Op> for ScaleDataVariant2SortVariant1Op {
    fn from(value: &ScaleDataVariant2SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&ScaleDataVariant2SortVariant2Op> for ScaleDataVariant2SortVariant2Op {
    fn from(value: &ScaleDataVariant2SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ScaleField(pub StringOrSignal);
impl std::ops::Deref for ScaleField {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl From<ScaleField> for StringOrSignal {
    fn from(value: ScaleField) -> Self {
        value.0
    }
}
impl From<&ScaleField> for ScaleField {
    fn from(value: &ScaleField) -> Self {
        value.clone()
    }
}
impl From<StringOrSignal> for ScaleField {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleInterpolate {
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        gamma: Option<NumberOrSignal>,
        #[serde(rename = "type")]
        type_: StringOrSignal,
    },
}
impl From<&ScaleInterpolate> for ScaleInterpolate {
    fn from(value: &ScaleInterpolate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0Domain {
    Variant0(Vec<ScaleVariant0DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant0Domain> for ScaleVariant0Domain {
    fn from(value: &ScaleVariant0Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant0DomainRaw> for ScaleVariant0DomainRaw {
    fn from(value: &ScaleVariant0DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant0DomainVariant0Item> for ScaleVariant0DomainVariant0Item {
    fn from(value: &ScaleVariant0DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant0Type {
    #[serde(rename = "identity")]
    Identity,
}
impl From<&ScaleVariant0Type> for ScaleVariant0Type {
    fn from(value: &ScaleVariant0Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Identity => "identity".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant0Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "identity" => Ok(Self::Identity),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant0Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant0Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant0Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10Domain {
    Variant0(Vec<ScaleVariant10DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant10Domain> for ScaleVariant10Domain {
    fn from(value: &ScaleVariant10Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant10DomainRaw> for ScaleVariant10DomainRaw {
    fn from(value: &ScaleVariant10DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant10DomainVariant0Item> for ScaleVariant10DomainVariant0Item {
    fn from(value: &ScaleVariant10DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&ScaleVariant10Nice> for ScaleVariant10Nice {
    fn from(value: &ScaleVariant10Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant10Range {
    Variant0(ScaleVariant10RangeVariant0),
    Variant1(Vec<ScaleVariant10RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant10RangeVariant2Extent>,
        scheme: ScaleVariant10RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant10Range> for ScaleVariant10Range {
    fn from(value: &ScaleVariant10Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant10RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant10RangeVariant0> for ScaleVariant10RangeVariant0 {
    fn from(value: &ScaleVariant10RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant10RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant10RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant10RangeVariant1Item> for ScaleVariant10RangeVariant1Item {
    fn from(value: &ScaleVariant10RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant10RangeVariant2Extent> for ScaleVariant10RangeVariant2Extent {
    fn from(value: &ScaleVariant10RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant10RangeVariant2Scheme> for ScaleVariant10RangeVariant2Scheme {
    fn from(value: &ScaleVariant10RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant10RangeVariant2SchemeVariant1Item>
    for ScaleVariant10RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant10RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant10Type {
    #[serde(rename = "pow")]
    Pow,
}
impl From<&ScaleVariant10Type> for ScaleVariant10Type {
    fn from(value: &ScaleVariant10Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant10Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pow => "pow".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "pow" => Ok(Self::Pow),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant10Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11Domain {
    Variant0(Vec<ScaleVariant11DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant11Domain> for ScaleVariant11Domain {
    fn from(value: &ScaleVariant11Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant11DomainRaw> for ScaleVariant11DomainRaw {
    fn from(value: &ScaleVariant11DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant11DomainVariant0Item> for ScaleVariant11DomainVariant0Item {
    fn from(value: &ScaleVariant11DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&ScaleVariant11Nice> for ScaleVariant11Nice {
    fn from(value: &ScaleVariant11Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant11Range {
    Variant0(ScaleVariant11RangeVariant0),
    Variant1(Vec<ScaleVariant11RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant11RangeVariant2Extent>,
        scheme: ScaleVariant11RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant11Range> for ScaleVariant11Range {
    fn from(value: &ScaleVariant11Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant11RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant11RangeVariant0> for ScaleVariant11RangeVariant0 {
    fn from(value: &ScaleVariant11RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant11RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant11RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant11RangeVariant1Item> for ScaleVariant11RangeVariant1Item {
    fn from(value: &ScaleVariant11RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant11RangeVariant2Extent> for ScaleVariant11RangeVariant2Extent {
    fn from(value: &ScaleVariant11RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant11RangeVariant2Scheme> for ScaleVariant11RangeVariant2Scheme {
    fn from(value: &ScaleVariant11RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant11RangeVariant2SchemeVariant1Item>
    for ScaleVariant11RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant11RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant11Type {
    #[serde(rename = "symlog")]
    Symlog,
}
impl From<&ScaleVariant11Type> for ScaleVariant11Type {
    fn from(value: &ScaleVariant11Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant11Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Symlog => "symlog".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "symlog" => Ok(Self::Symlog),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant11Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1Domain {
    Variant0(Vec<ScaleVariant1DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant1Domain> for ScaleVariant1Domain {
    fn from(value: &ScaleVariant1Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant1DomainRaw> for ScaleVariant1DomainRaw {
    fn from(value: &ScaleVariant1DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant1DomainVariant0Item> for ScaleVariant1DomainVariant0Item {
    fn from(value: &ScaleVariant1DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1Range {
    Variant0(ScaleVariant1RangeVariant0),
    Variant1(Vec<ScaleVariant1RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant1RangeVariant2Extent>,
        scheme: ScaleVariant1RangeVariant2Scheme,
    },
    Variant3(ScaleVariant1RangeVariant3),
    Variant4(SignalRef),
}
impl From<&ScaleVariant1Range> for ScaleVariant1Range {
    fn from(value: &ScaleVariant1Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant1RangeVariant0> for ScaleVariant1RangeVariant0 {
    fn from(value: &ScaleVariant1RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant1RangeVariant1Item> for ScaleVariant1RangeVariant1Item {
    fn from(value: &ScaleVariant1RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant1RangeVariant2Extent> for ScaleVariant1RangeVariant2Extent {
    fn from(value: &ScaleVariant1RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant1RangeVariant2Scheme> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: &ScaleVariant1RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant1RangeVariant2SchemeVariant1Item>
    for ScaleVariant1RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant1RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3 {
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleVariant1RangeVariant3Variant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant2Sort>,
    },
}
impl From<&ScaleVariant1RangeVariant3> for ScaleVariant1RangeVariant3 {
    fn from(value: &ScaleVariant1RangeVariant3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleVariant1RangeVariant3Variant0Sort> for ScaleVariant1RangeVariant3Variant0Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant0Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleVariant1RangeVariant3Variant1Sort> for ScaleVariant1RangeVariant3Variant1Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant1Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&ScaleVariant1RangeVariant3Variant1SortVariant1Op>
    for ScaleVariant1RangeVariant3Variant1SortVariant1Op
{
    fn from(value: &ScaleVariant1RangeVariant3Variant1SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&ScaleVariant1RangeVariant3Variant1SortVariant2Op>
    for ScaleVariant1RangeVariant3Variant1SortVariant2Op
{
    fn from(value: &ScaleVariant1RangeVariant3Variant1SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItem {
    Variant0 { data: String, field: StringOrSignal },
    Variant1(Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant1RangeVariant3Variant2FieldsItem>
    for ScaleVariant1RangeVariant3Variant2FieldsItem
{
    fn from(value: &ScaleVariant1RangeVariant3Variant2FieldsItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
impl From<&ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>
    for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item
{
    fn from(value: &ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
            Self::Variant2(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&ScaleVariant1RangeVariant3Variant2Sort> for ScaleVariant1RangeVariant3Variant2Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant2Sort) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&ScaleVariant1RangeVariant3Variant2SortVariant1Op>
    for ScaleVariant1RangeVariant3Variant2SortVariant1Op
{
    fn from(value: &ScaleVariant1RangeVariant3Variant2SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&ScaleVariant1RangeVariant3Variant2SortVariant2Op>
    for ScaleVariant1RangeVariant3Variant2SortVariant2Op
{
    fn from(value: &ScaleVariant1RangeVariant3Variant2SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1Type {
    #[serde(rename = "ordinal")]
    Ordinal,
}
impl From<&ScaleVariant1Type> for ScaleVariant1Type {
    fn from(value: &ScaleVariant1Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Ordinal => "ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ordinal" => Ok(Self::Ordinal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2Domain {
    Variant0(Vec<ScaleVariant2DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant2Domain> for ScaleVariant2Domain {
    fn from(value: &ScaleVariant2Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant2DomainRaw> for ScaleVariant2DomainRaw {
    fn from(value: &ScaleVariant2DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant2DomainVariant0Item> for ScaleVariant2DomainVariant0Item {
    fn from(value: &ScaleVariant2DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant2Range {
    Variant0(ScaleVariant2RangeVariant0),
    Variant1(Vec<ScaleVariant2RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl From<&ScaleVariant2Range> for ScaleVariant2Range {
    fn from(value: &ScaleVariant2Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant2RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant2RangeVariant0> for ScaleVariant2RangeVariant0 {
    fn from(value: &ScaleVariant2RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant2RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant2RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant2RangeVariant1Item> for ScaleVariant2RangeVariant1Item {
    fn from(value: &ScaleVariant2RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant2Type {
    #[serde(rename = "band")]
    Band,
}
impl From<&ScaleVariant2Type> for ScaleVariant2Type {
    fn from(value: &ScaleVariant2Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Band => "band".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "band" => Ok(Self::Band),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant2Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3Domain {
    Variant0(Vec<ScaleVariant3DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant3Domain> for ScaleVariant3Domain {
    fn from(value: &ScaleVariant3Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant3DomainRaw> for ScaleVariant3DomainRaw {
    fn from(value: &ScaleVariant3DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant3DomainVariant0Item> for ScaleVariant3DomainVariant0Item {
    fn from(value: &ScaleVariant3DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant3Range {
    Variant0(ScaleVariant3RangeVariant0),
    Variant1(Vec<ScaleVariant3RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl From<&ScaleVariant3Range> for ScaleVariant3Range {
    fn from(value: &ScaleVariant3Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant3RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant3RangeVariant0> for ScaleVariant3RangeVariant0 {
    fn from(value: &ScaleVariant3RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant3RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant3RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant3RangeVariant1Item> for ScaleVariant3RangeVariant1Item {
    fn from(value: &ScaleVariant3RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant3Type {
    #[serde(rename = "point")]
    Point,
}
impl From<&ScaleVariant3Type> for ScaleVariant3Type {
    fn from(value: &ScaleVariant3Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Point => "point".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "point" => Ok(Self::Point),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant3Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4Domain {
    Variant0(Vec<ScaleVariant4DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant4Domain> for ScaleVariant4Domain {
    fn from(value: &ScaleVariant4Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant4DomainRaw> for ScaleVariant4DomainRaw {
    fn from(value: &ScaleVariant4DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant4DomainVariant0Item> for ScaleVariant4DomainVariant0Item {
    fn from(value: &ScaleVariant4DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&ScaleVariant4Nice> for ScaleVariant4Nice {
    fn from(value: &ScaleVariant4Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant4Range {
    Variant0(ScaleVariant4RangeVariant0),
    Variant1(Vec<ScaleVariant4RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant4RangeVariant2Extent>,
        scheme: ScaleVariant4RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant4Range> for ScaleVariant4Range {
    fn from(value: &ScaleVariant4Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant4RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant4RangeVariant0> for ScaleVariant4RangeVariant0 {
    fn from(value: &ScaleVariant4RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant4RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant4RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant4RangeVariant1Item> for ScaleVariant4RangeVariant1Item {
    fn from(value: &ScaleVariant4RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant4RangeVariant2Extent> for ScaleVariant4RangeVariant2Extent {
    fn from(value: &ScaleVariant4RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant4RangeVariant2Scheme> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: &ScaleVariant4RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant4RangeVariant2SchemeVariant1Item>
    for ScaleVariant4RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant4RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant4Type {
    #[serde(rename = "quantize")]
    Quantize,
    #[serde(rename = "threshold")]
    Threshold,
}
impl From<&ScaleVariant4Type> for ScaleVariant4Type {
    fn from(value: &ScaleVariant4Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant4Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantize => "quantize".to_string(),
            Self::Threshold => "threshold".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantize" => Ok(Self::Quantize),
            "threshold" => Ok(Self::Threshold),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant4Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5Domain {
    Variant0(Vec<ScaleVariant5DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant5Domain> for ScaleVariant5Domain {
    fn from(value: &ScaleVariant5Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant5DomainRaw> for ScaleVariant5DomainRaw {
    fn from(value: &ScaleVariant5DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant5DomainVariant0Item> for ScaleVariant5DomainVariant0Item {
    fn from(value: &ScaleVariant5DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant5Range {
    Variant0(ScaleVariant5RangeVariant0),
    Variant1(Vec<ScaleVariant5RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant5RangeVariant2Extent>,
        scheme: ScaleVariant5RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant5Range> for ScaleVariant5Range {
    fn from(value: &ScaleVariant5Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant5RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant5RangeVariant0> for ScaleVariant5RangeVariant0 {
    fn from(value: &ScaleVariant5RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant5RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant5RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant5RangeVariant1Item> for ScaleVariant5RangeVariant1Item {
    fn from(value: &ScaleVariant5RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant5RangeVariant2Extent> for ScaleVariant5RangeVariant2Extent {
    fn from(value: &ScaleVariant5RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant5RangeVariant2Scheme> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: &ScaleVariant5RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant5RangeVariant2SchemeVariant1Item>
    for ScaleVariant5RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant5RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant5Type {
    #[serde(rename = "quantile")]
    Quantile,
}
impl From<&ScaleVariant5Type> for ScaleVariant5Type {
    fn from(value: &ScaleVariant5Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant5Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant5Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6Domain {
    Variant0(Vec<ScaleVariant6DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant6Domain> for ScaleVariant6Domain {
    fn from(value: &ScaleVariant6Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant6DomainRaw> for ScaleVariant6DomainRaw {
    fn from(value: &ScaleVariant6DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant6DomainVariant0Item> for ScaleVariant6DomainVariant0Item {
    fn from(value: &ScaleVariant6DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant6Range {
    Variant0(ScaleVariant6RangeVariant0),
    Variant1(Vec<ScaleVariant6RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant6RangeVariant2Extent>,
        scheme: ScaleVariant6RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant6Range> for ScaleVariant6Range {
    fn from(value: &ScaleVariant6Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant6RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant6RangeVariant0> for ScaleVariant6RangeVariant0 {
    fn from(value: &ScaleVariant6RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant6RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant6RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant6RangeVariant1Item> for ScaleVariant6RangeVariant1Item {
    fn from(value: &ScaleVariant6RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant6RangeVariant2Extent> for ScaleVariant6RangeVariant2Extent {
    fn from(value: &ScaleVariant6RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant6RangeVariant2Scheme> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: &ScaleVariant6RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant6RangeVariant2SchemeVariant1Item>
    for ScaleVariant6RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant6RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant6Type {
    #[serde(rename = "bin-ordinal")]
    BinOrdinal,
}
impl From<&ScaleVariant6Type> for ScaleVariant6Type {
    fn from(value: &ScaleVariant6Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant6Type {
    fn to_string(&self) -> String {
        match *self {
            Self::BinOrdinal => "bin-ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "bin-ordinal" => Ok(Self::BinOrdinal),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant6Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7Domain {
    Variant0(Vec<ScaleVariant7DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant7Domain> for ScaleVariant7Domain {
    fn from(value: &ScaleVariant7Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant7DomainRaw> for ScaleVariant7DomainRaw {
    fn from(value: &ScaleVariant7DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant7DomainVariant0Item> for ScaleVariant7DomainVariant0Item {
    fn from(value: &ScaleVariant7DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Nice {
    Variant0(bool),
    Variant1(ScaleVariant7NiceVariant1),
    Variant2 {
        interval: ScaleVariant7NiceVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
}
impl From<&ScaleVariant7Nice> for ScaleVariant7Nice {
    fn from(value: &ScaleVariant7Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7NiceVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&ScaleVariant7NiceVariant1> for ScaleVariant7NiceVariant1 {
    fn from(value: &ScaleVariant7NiceVariant1) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7NiceVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7NiceVariant1 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7NiceVariant2Interval {
    Variant0(ScaleVariant7NiceVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl From<&ScaleVariant7NiceVariant2Interval> for ScaleVariant7NiceVariant2Interval {
    fn from(value: &ScaleVariant7NiceVariant2Interval) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7NiceVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&ScaleVariant7NiceVariant2IntervalVariant0>
    for ScaleVariant7NiceVariant2IntervalVariant0
{
    fn from(value: &ScaleVariant7NiceVariant2IntervalVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Range {
    Variant0(ScaleVariant7RangeVariant0),
    Variant1(Vec<ScaleVariant7RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant7RangeVariant2Extent>,
        scheme: ScaleVariant7RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant7Range> for ScaleVariant7Range {
    fn from(value: &ScaleVariant7Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant7RangeVariant0> for ScaleVariant7RangeVariant0 {
    fn from(value: &ScaleVariant7RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant7RangeVariant1Item> for ScaleVariant7RangeVariant1Item {
    fn from(value: &ScaleVariant7RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant7RangeVariant2Extent> for ScaleVariant7RangeVariant2Extent {
    fn from(value: &ScaleVariant7RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant7RangeVariant2Scheme> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: &ScaleVariant7RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant7RangeVariant2SchemeVariant1Item>
    for ScaleVariant7RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant7RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7Type {
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&ScaleVariant7Type> for ScaleVariant7Type {
    fn from(value: &ScaleVariant7Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8Domain {
    Variant0(Vec<ScaleVariant8DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant8Domain> for ScaleVariant8Domain {
    fn from(value: &ScaleVariant8Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant8DomainRaw> for ScaleVariant8DomainRaw {
    fn from(value: &ScaleVariant8DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant8DomainVariant0Item> for ScaleVariant8DomainVariant0Item {
    fn from(value: &ScaleVariant8DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&ScaleVariant8Nice> for ScaleVariant8Nice {
    fn from(value: &ScaleVariant8Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant8Range {
    Variant0(ScaleVariant8RangeVariant0),
    Variant1(Vec<ScaleVariant8RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant8RangeVariant2Extent>,
        scheme: ScaleVariant8RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant8Range> for ScaleVariant8Range {
    fn from(value: &ScaleVariant8Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant8RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant8RangeVariant0> for ScaleVariant8RangeVariant0 {
    fn from(value: &ScaleVariant8RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant8RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant8RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant8RangeVariant1Item> for ScaleVariant8RangeVariant1Item {
    fn from(value: &ScaleVariant8RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant8RangeVariant2Extent> for ScaleVariant8RangeVariant2Extent {
    fn from(value: &ScaleVariant8RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant8RangeVariant2Scheme> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: &ScaleVariant8RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant8RangeVariant2SchemeVariant1Item>
    for ScaleVariant8RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant8RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant8Type {
    #[serde(rename = "linear")]
    Linear,
    #[serde(rename = "sqrt")]
    Sqrt,
    #[serde(rename = "sequential")]
    Sequential,
}
impl From<&ScaleVariant8Type> for ScaleVariant8Type {
    fn from(value: &ScaleVariant8Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant8Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
            Self::Sqrt => "sqrt".to_string(),
            Self::Sequential => "sequential".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "linear" => Ok(Self::Linear),
            "sqrt" => Ok(Self::Sqrt),
            "sequential" => Ok(Self::Sequential),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant8Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9Domain {
    Variant0(Vec<ScaleVariant9DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&ScaleVariant9Domain> for ScaleVariant9Domain {
    fn from(value: &ScaleVariant9Domain) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant9DomainRaw> for ScaleVariant9DomainRaw {
    fn from(value: &ScaleVariant9DomainRaw) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant9DomainVariant0Item> for ScaleVariant9DomainVariant0Item {
    fn from(value: &ScaleVariant9DomainVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&ScaleVariant9Nice> for ScaleVariant9Nice {
    fn from(value: &ScaleVariant9Nice) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant9Range {
    Variant0(ScaleVariant9RangeVariant0),
    Variant1(Vec<ScaleVariant9RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant9RangeVariant2Extent>,
        scheme: ScaleVariant9RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&ScaleVariant9Range> for ScaleVariant9Range {
    fn from(value: &ScaleVariant9Range) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant9RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&ScaleVariant9RangeVariant0> for ScaleVariant9RangeVariant0 {
    fn from(value: &ScaleVariant9RangeVariant0) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant9RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9RangeVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant9RangeVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&ScaleVariant9RangeVariant1Item> for ScaleVariant9RangeVariant1Item {
    fn from(value: &ScaleVariant9RangeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Extent {
    Variant0(NumberOrSignal, NumberOrSignal),
    Variant1(SignalRef),
}
impl From<&ScaleVariant9RangeVariant2Extent> for ScaleVariant9RangeVariant2Extent {
    fn from(value: &ScaleVariant9RangeVariant2Extent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&ScaleVariant9RangeVariant2Scheme> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: &ScaleVariant9RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&ScaleVariant9RangeVariant2SchemeVariant1Item>
    for ScaleVariant9RangeVariant2SchemeVariant1Item
{
    fn from(value: &ScaleVariant9RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant9Type {
    #[serde(rename = "log")]
    Log,
}
impl From<&ScaleVariant9Type> for ScaleVariant9Type {
    fn from(value: &ScaleVariant9Type) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant9Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Log => "log".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9Type {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "log" => Ok(Self::Log),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9Type {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9Type {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant9Type {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Scope {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub axes: Vec<Axis>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<Layout>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub legends: Vec<Legend>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub marks: Vec<ScopeMarksItem>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub projections: Vec<Projection>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub scales: Vec<Scale>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub signals: Vec<Signal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<Title>,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub usermeta: serde_json::Map<String, serde_json::Value>,
}
impl From<&Scope> for Scope {
    fn from(value: &Scope) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScopeMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl From<&ScopeMarksItem> for ScopeMarksItem {
    fn from(value: &ScopeMarksItem) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Selector(pub String);
impl std::ops::Deref for Selector {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Selector> for String {
    fn from(value: Selector) -> Self {
        value.0
    }
}
impl From<&Selector> for Selector {
    fn from(value: &Selector) -> Self {
        value.clone()
    }
}
impl From<String> for Selector {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Selector {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Selector {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SequenceTransform {
    #[serde(rename = "as", default = "defaults::sequence_transform_as")]
    pub as_: SequenceTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub start: SequenceTransformStart,
    #[serde(default = "defaults::sequence_transform_step")]
    pub step: SequenceTransformStep,
    pub stop: SequenceTransformStop,
    #[serde(rename = "type")]
    pub type_: SequenceTransformType,
}
impl From<&SequenceTransform> for SequenceTransform {
    fn from(value: &SequenceTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&SequenceTransformAs> for SequenceTransformAs {
    fn from(value: &SequenceTransformAs) -> Self {
        value.clone()
    }
}
impl Default for SequenceTransformAs {
    fn default() -> Self {
        SequenceTransformAs::Variant0("data".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStart {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&SequenceTransformStart> for SequenceTransformStart {
    fn from(value: &SequenceTransformStart) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&SequenceTransformStep> for SequenceTransformStep {
    fn from(value: &SequenceTransformStep) -> Self {
        value.clone()
    }
}
impl Default for SequenceTransformStep {
    fn default() -> Self {
        SequenceTransformStep::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&SequenceTransformStop> for SequenceTransformStop {
    fn from(value: &SequenceTransformStop) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SequenceTransformType {
    #[serde(rename = "sequence")]
    Sequence,
}
impl From<&SequenceTransformType> for SequenceTransformType {
    fn from(value: &SequenceTransformType) -> Self {
        value.clone()
    }
}
impl ToString for SequenceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sequence => "sequence".to_string(),
        }
    }
}
impl std::str::FromStr for SequenceTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "sequence" => Ok(Self::Sequence),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SequenceTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SequenceTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SequenceTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Signal {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        push: SignalVariant0Push,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default = "defaults::default_bool::<true>")]
        react: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        update: Option<ExprString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        init: ExprString,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
}
impl From<&Signal> for Signal {
    fn from(value: &Signal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Serialize)]
pub struct SignalName(String);
impl std::ops::Deref for SignalName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<SignalName> for String {
    fn from(value: SignalName) -> Self {
        value.0
    }
}
impl From<&SignalName> for SignalName {
    fn from(value: &SignalName) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<String> for SignalName {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        if [
            "parent".to_string(),
            "datum".to_string(),
            "event".to_string(),
            "item".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value")
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for SignalName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(String::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SignalRef {
    pub signal: String,
}
impl From<&SignalRef> for SignalRef {
    fn from(value: &SignalRef) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SignalVariant0Push {
    #[serde(rename = "outer")]
    Outer,
}
impl From<&SignalVariant0Push> for SignalVariant0Push {
    fn from(value: &SignalVariant0Push) -> Self {
        value.clone()
    }
}
impl ToString for SignalVariant0Push {
    fn to_string(&self) -> String {
        match *self {
            Self::Outer => "outer".to_string(),
        }
    }
}
impl std::str::FromStr for SignalVariant0Push {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "outer" => Ok(Self::Outer),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SignalVariant0Push {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SignalVariant0Push {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SignalVariant0Push {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SortOrder {
    Variant0(SortOrderVariant0),
    Variant1(SignalRef),
}
impl From<&SortOrder> for SortOrder {
    fn from(value: &SortOrder) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SortOrderVariant0 {
    #[serde(rename = "ascending")]
    Ascending,
    #[serde(rename = "descending")]
    Descending,
}
impl From<&SortOrderVariant0> for SortOrderVariant0 {
    fn from(value: &SortOrderVariant0) -> Self {
        value.clone()
    }
}
impl ToString for SortOrderVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Ascending => "ascending".to_string(),
            Self::Descending => "descending".to_string(),
        }
    }
}
impl std::str::FromStr for SortOrderVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for SortOrderVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SortOrderVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SortOrderVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StackTransform {
    #[serde(rename = "as", default = "defaults::stack_transform_as")]
    pub as_: StackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<StackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<StackTransformGroupby>,
    #[serde(default = "defaults::stack_transform_offset")]
    pub offset: StackTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: StackTransformType,
}
impl From<&StackTransform> for StackTransform {
    fn from(value: &StackTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformAs {
    Variant0(StackTransformAsVariant0, StackTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&StackTransformAs> for StackTransformAs {
    fn from(value: &StackTransformAs) -> Self {
        value.clone()
    }
}
impl Default for StackTransformAs {
    fn default() -> Self {
        StackTransformAs::Variant0(
            StackTransformAsVariant0::Variant0("y0".to_string()),
            StackTransformAsVariant0::Variant0("y1".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&StackTransformAsVariant0> for StackTransformAsVariant0 {
    fn from(value: &StackTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&StackTransformField> for StackTransformField {
    fn from(value: &StackTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformGroupby {
    Variant0(Vec<StackTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&StackTransformGroupby> for StackTransformGroupby {
    fn from(value: &StackTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&StackTransformGroupbyVariant0Item> for StackTransformGroupbyVariant0Item {
    fn from(value: &StackTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformOffset {
    Variant0(StackTransformOffsetVariant0),
    Variant1(SignalRef),
}
impl From<&StackTransformOffset> for StackTransformOffset {
    fn from(value: &StackTransformOffset) -> Self {
        value.clone()
    }
}
impl Default for StackTransformOffset {
    fn default() -> Self {
        StackTransformOffset::Variant0(StackTransformOffsetVariant0::Zero)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StackTransformOffsetVariant0 {
    #[serde(rename = "zero")]
    Zero,
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "normalize")]
    Normalize,
}
impl From<&StackTransformOffsetVariant0> for StackTransformOffsetVariant0 {
    fn from(value: &StackTransformOffsetVariant0) -> Self {
        value.clone()
    }
}
impl ToString for StackTransformOffsetVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Zero => "zero".to_string(),
            Self::Center => "center".to_string(),
            Self::Normalize => "normalize".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformOffsetVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "zero" => Ok(Self::Zero),
            "center" => Ok(Self::Center),
            "normalize" => Ok(Self::Normalize),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformOffsetVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformOffsetVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StackTransformOffsetVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StackTransformType {
    #[serde(rename = "stack")]
    Stack,
}
impl From<&StackTransformType> for StackTransformType {
    fn from(value: &StackTransformType) -> Self {
        value.clone()
    }
}
impl ToString for StackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stack => "stack".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "stack" => Ok(Self::Stack),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StackTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StratifyTransform {
    pub key: StratifyTransformKey,
    #[serde(rename = "parentKey")]
    pub parent_key: StratifyTransformParentKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: StratifyTransformType,
}
impl From<&StratifyTransform> for StratifyTransform {
    fn from(value: &StratifyTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StratifyTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&StratifyTransformKey> for StratifyTransformKey {
    fn from(value: &StratifyTransformKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StratifyTransformParentKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&StratifyTransformParentKey> for StratifyTransformParentKey {
    fn from(value: &StratifyTransformParentKey) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StratifyTransformType {
    #[serde(rename = "stratify")]
    Stratify,
}
impl From<&StratifyTransformType> for StratifyTransformType {
    fn from(value: &StratifyTransformType) -> Self {
        value.clone()
    }
}
impl ToString for StratifyTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stratify => "stratify".to_string(),
        }
    }
}
impl std::str::FromStr for StratifyTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "stratify" => Ok(Self::Stratify),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StratifyTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StratifyTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StratifyTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Stream {
    #[serde(flatten)]
    pub subtype_0: StreamSubtype0,
    #[serde(flatten)]
    pub subtype_1: StreamSubtype1,
}
impl From<&Stream> for Stream {
    fn from(value: &Stream) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StreamSubtype0 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub between: Vec<Stream>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub consume: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub debounce: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<StreamSubtype0Filter>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub markname: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub marktype: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub throttle: Option<f64>,
}
impl From<&StreamSubtype0> for StreamSubtype0 {
    fn from(value: &StreamSubtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StreamSubtype0Filter {
    Variant0(ExprString),
    Variant1(Vec<ExprString>),
}
impl From<&StreamSubtype0Filter> for StreamSubtype0Filter {
    fn from(value: &StreamSubtype0Filter) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StreamSubtype1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        source: Option<String>,
        #[serde(rename = "type")]
        type_: String,
    },
    Variant1 {
        stream: Stream,
    },
    Variant2 {
        merge: Vec<Stream>,
    },
}
impl From<&StreamSubtype1> for StreamSubtype1 {
    fn from(value: &StreamSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
impl From<&StringModifiers> for StringModifiers {
    fn from(value: &StringModifiers) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringOrSignal {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&StringOrSignal> for StringOrSignal {
    fn from(value: &StringOrSignal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValue {
    Variant0(Vec<StringValueVariant0Item>),
    Variant1(StringValueVariant1),
}
impl From<&StringValue> for StringValue {
    fn from(value: &StringValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant0ItemSubtype1,
}
impl From<&StringValueVariant0Item> for StringValueVariant0Item {
    fn from(value: &StringValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant0ItemSubtype1Subtype1,
}
impl From<&StringValueVariant0ItemSubtype1> for StringValueVariant0ItemSubtype1 {
    fn from(value: &StringValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StringValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StringValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StringValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StringValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&StringValueVariant0ItemSubtype1Subtype1> for StringValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: String,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StringValueVariant0ItemSubtype1Subtype1Subtype0>
    for StringValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StringValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&StringValueVariant0ItemSubtype1Subtype1Subtype1>
    for StringValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&StringValueVariant0ItemSubtype1Subtype1Subtype2>
    for StringValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&StringValueVariant0ItemSubtype1Subtype1Subtype3>
    for StringValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &StringValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StringValueVariant1Subtype1,
}
impl From<&StringValueVariant1> for StringValueVariant1 {
    fn from(value: &StringValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StringValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StringValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StringValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StringValueVariant1Subtype1Subtype3>,
}
impl From<&StringValueVariant1Subtype1> for StringValueVariant1Subtype1 {
    fn from(value: &StringValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: String,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StringValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StringValueVariant1Subtype1Subtype0> for StringValueVariant1Subtype1Subtype0 {
    fn from(value: &StringValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StringValueVariant1Subtype1Subtype0Variant3Range>
    for StringValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &StringValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StringValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for StringValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StringValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StringValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StringValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype1 {}
impl From<&StringValueVariant1Subtype1Subtype1> for StringValueVariant1Subtype1Subtype1 {
    fn from(value: &StringValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype2 {}
impl From<&StringValueVariant1Subtype1Subtype2> for StringValueVariant1Subtype1Subtype2 {
    fn from(value: &StringValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringValueVariant1Subtype1Subtype3 {}
impl From<&StringValueVariant1Subtype1Subtype3> for StringValueVariant1Subtype1Subtype3 {
    fn from(value: &StringValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValue {
    Variant0(Vec<StrokeCapValueVariant0Item>),
    Variant1(StrokeCapValueVariant1),
}
impl From<&StrokeCapValue> for StrokeCapValue {
    fn from(value: &StrokeCapValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant0ItemSubtype1,
}
impl From<&StrokeCapValueVariant0Item> for StrokeCapValueVariant0Item {
    fn from(value: &StrokeCapValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant0ItemSubtype1Subtype1,
}
impl From<&StrokeCapValueVariant0ItemSubtype1> for StrokeCapValueVariant0ItemSubtype1 {
    fn from(value: &StrokeCapValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1>
    for StrokeCapValueVariant0ItemSubtype1Subtype1
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3>
    for StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &StrokeCapValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeCapValueVariant1Subtype1,
}
impl From<&StrokeCapValueVariant1> for StrokeCapValueVariant1 {
    fn from(value: &StrokeCapValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeCapValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeCapValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeCapValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeCapValueVariant1Subtype1Subtype3>,
}
impl From<&StrokeCapValueVariant1Subtype1> for StrokeCapValueVariant1Subtype1 {
    fn from(value: &StrokeCapValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: StrokeCapValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeCapValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StrokeCapValueVariant1Subtype1Subtype0> for StrokeCapValueVariant1Subtype1Subtype0 {
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl From<&StrokeCapValueVariant1Subtype1Subtype0Variant1Value>
    for StrokeCapValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StrokeCapValueVariant1Subtype1Subtype0Variant3Range>
    for StrokeCapValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StrokeCapValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype1 {}
impl From<&StrokeCapValueVariant1Subtype1Subtype1> for StrokeCapValueVariant1Subtype1Subtype1 {
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype2 {}
impl From<&StrokeCapValueVariant1Subtype1Subtype2> for StrokeCapValueVariant1Subtype1Subtype2 {
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeCapValueVariant1Subtype1Subtype3 {}
impl From<&StrokeCapValueVariant1Subtype1Subtype3> for StrokeCapValueVariant1Subtype1Subtype3 {
    fn from(value: &StrokeCapValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValue {
    Variant0(Vec<StrokeJoinValueVariant0Item>),
    Variant1(StrokeJoinValueVariant1),
}
impl From<&StrokeJoinValue> for StrokeJoinValue {
    fn from(value: &StrokeJoinValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant0ItemSubtype1,
}
impl From<&StrokeJoinValueVariant0Item> for StrokeJoinValueVariant0Item {
    fn from(value: &StrokeJoinValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant0ItemSubtype1Subtype1,
}
impl From<&StrokeJoinValueVariant0ItemSubtype1> for StrokeJoinValueVariant0ItemSubtype1 {
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3>
    for StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &StrokeJoinValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: StrokeJoinValueVariant1Subtype1,
}
impl From<&StrokeJoinValueVariant1> for StrokeJoinValueVariant1 {
    fn from(value: &StrokeJoinValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<StrokeJoinValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<StrokeJoinValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<StrokeJoinValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<StrokeJoinValueVariant1Subtype1Subtype3>,
}
impl From<&StrokeJoinValueVariant1Subtype1> for StrokeJoinValueVariant1Subtype1 {
    fn from(value: &StrokeJoinValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: StrokeJoinValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: StrokeJoinValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&StrokeJoinValueVariant1Subtype1Subtype0> for StrokeJoinValueVariant1Subtype1Subtype0 {
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl From<&StrokeJoinValueVariant1Subtype1Subtype0Variant1Value>
    for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
impl ToString for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant1Subtype1Subtype0Variant1Value {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&StrokeJoinValueVariant1Subtype1Subtype0Variant3Range>
    for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for StrokeJoinValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype1 {}
impl From<&StrokeJoinValueVariant1Subtype1Subtype1> for StrokeJoinValueVariant1Subtype1Subtype1 {
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype2 {}
impl From<&StrokeJoinValueVariant1Subtype1Subtype2> for StrokeJoinValueVariant1Subtype1Subtype2 {
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StrokeJoinValueVariant1Subtype1Subtype3 {}
impl From<&StrokeJoinValueVariant1Subtype1Subtype3> for StrokeJoinValueVariant1Subtype1Subtype3 {
    fn from(value: &StrokeJoinValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Style {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Style> for Style {
    fn from(value: &Style) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextOrSignal {
    Variant0(TextOrSignalVariant0),
    Variant1(SignalRef),
}
impl From<&TextOrSignal> for TextOrSignal {
    fn from(value: &TextOrSignal) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextOrSignalVariant0 {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&TextOrSignalVariant0> for TextOrSignalVariant0 {
    fn from(value: &TextOrSignalVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValue {
    Variant0(Vec<TextValueVariant0Item>),
    Variant1(TextValueVariant1),
}
impl From<&TextValue> for TextValue {
    fn from(value: &TextValue) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0Item {
    #[serde(flatten)]
    pub subtype_0: Rule,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant0ItemSubtype1,
}
impl From<&TextValueVariant0Item> for TextValueVariant0Item {
    fn from(value: &TextValueVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant0ItemSubtype1Subtype1,
}
impl From<&TextValueVariant0ItemSubtype1> for TextValueVariant0ItemSubtype1 {
    fn from(value: &TextValueVariant0ItemSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TextValueVariant0ItemSubtype1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TextValueVariant0ItemSubtype1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<TextValueVariant0ItemSubtype1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<TextValueVariant0ItemSubtype1Subtype1Subtype3>,
}
impl From<&TextValueVariant0ItemSubtype1Subtype1> for TextValueVariant0ItemSubtype1Subtype1 {
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range,
    },
}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype0>
    for TextValueVariant0ItemSubtype1Subtype1Subtype0
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value>
    for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range>
    for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for TextValueVariant0ItemSubtype1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype1 {}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype1>
    for TextValueVariant0ItemSubtype1Subtype1Subtype1
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype2 {}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype2>
    for TextValueVariant0ItemSubtype1Subtype1Subtype2
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant0ItemSubtype1Subtype1Subtype3 {}
impl From<&TextValueVariant0ItemSubtype1Subtype1Subtype3>
    for TextValueVariant0ItemSubtype1Subtype1Subtype3
{
    fn from(value: &TextValueVariant0ItemSubtype1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant1 {
    #[serde(flatten)]
    pub subtype_0: StringModifiers,
    #[serde(flatten)]
    pub subtype_1: TextValueVariant1Subtype1,
}
impl From<&TextValueVariant1> for TextValueVariant1 {
    fn from(value: &TextValueVariant1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1 {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TextValueVariant1Subtype1Subtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TextValueVariant1Subtype1Subtype1>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_2: Option<TextValueVariant1Subtype1Subtype2>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_3: Option<TextValueVariant1Subtype1Subtype3>,
}
impl From<&TextValueVariant1Subtype1> for TextValueVariant1Subtype1 {
    fn from(value: &TextValueVariant1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0 {
    Variant0(SignalRef),
    Variant1 {
        value: TextValueVariant1Subtype1Subtype0Variant1Value,
    },
    Variant2 {
        field: Field,
    },
    Variant3 {
        range: TextValueVariant1Subtype1Subtype0Variant3Range,
    },
}
impl From<&TextValueVariant1Subtype1Subtype0> for TextValueVariant1Subtype1Subtype0 {
    fn from(value: &TextValueVariant1Subtype1Subtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0Variant1Value {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&TextValueVariant1Subtype1Subtype0Variant1Value>
    for TextValueVariant1Subtype1Subtype0Variant1Value
{
    fn from(value: &TextValueVariant1Subtype1Subtype0Variant1Value) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1Subtype1Subtype0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&TextValueVariant1Subtype1Subtype0Variant3Range>
    for TextValueVariant1Subtype1Subtype0Variant3Range
{
    fn from(value: &TextValueVariant1Subtype1Subtype0Variant3Range) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for TextValueVariant1Subtype1Subtype0Variant3Range {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants")
        }
    }
}
impl std::convert::TryFrom<&str> for TextValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TextValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TextValueVariant1Subtype1Subtype0Variant3Range {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl ToString for TextValueVariant1Subtype1Subtype0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype1 {}
impl From<&TextValueVariant1Subtype1Subtype1> for TextValueVariant1Subtype1Subtype1 {
    fn from(value: &TextValueVariant1Subtype1Subtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype2 {}
impl From<&TextValueVariant1Subtype1Subtype2> for TextValueVariant1Subtype1Subtype2 {
    fn from(value: &TextValueVariant1Subtype1Subtype2) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TextValueVariant1Subtype1Subtype3 {}
impl From<&TextValueVariant1Subtype1Subtype3> for TextValueVariant1Subtype1Subtype3 {
    fn from(value: &TextValueVariant1Subtype1Subtype3) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TickBand {
    Variant0(TickBandVariant0),
    Variant1(SignalRef),
}
impl From<&TickBand> for TickBand {
    fn from(value: &TickBand) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickBandVariant0 {
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "extent")]
    Extent,
}
impl From<&TickBandVariant0> for TickBandVariant0 {
    fn from(value: &TickBandVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TickBandVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Center => "center".to_string(),
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for TickBandVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "center" => Ok(Self::Center),
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickBandVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickBandVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickBandVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum TickCount {
    Variant0(f64),
    Variant1(TickCountVariant1),
    Variant2 {
        interval: TickCountVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
    Variant3(SignalRef),
}
impl From<&TickCount> for TickCount {
    fn from(value: &TickCount) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickCountVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&TickCountVariant1> for TickCountVariant1 {
    fn from(value: &TickCountVariant1) -> Self {
        value.clone()
    }
}
impl ToString for TickCountVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant1 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant1 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickCountVariant1 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TickCountVariant2Interval {
    Variant0(TickCountVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl From<&TickCountVariant2Interval> for TickCountVariant2Interval {
    fn from(value: &TickCountVariant2Interval) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickCountVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&TickCountVariant2IntervalVariant0> for TickCountVariant2IntervalVariant0 {
    fn from(value: &TickCountVariant2IntervalVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TickCountVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant2IntervalVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickCountVariant2IntervalVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TimeunitTransform {
    #[serde(rename = "as", default = "defaults::timeunit_transform_as")]
    pub as_: TimeunitTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<TimeunitTransformExtent>,
    pub field: TimeunitTransformField,
    #[serde(default = "defaults::timeunit_transform_interval")]
    pub interval: TimeunitTransformInterval,
    #[serde(default = "defaults::timeunit_transform_maxbins")]
    pub maxbins: TimeunitTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::timeunit_transform_step")]
    pub step: TimeunitTransformStep,
    #[serde(default = "defaults::timeunit_transform_timezone")]
    pub timezone: TimeunitTransformTimezone,
    #[serde(rename = "type")]
    pub type_: TimeunitTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<TimeunitTransformUnits>,
}
impl From<&TimeunitTransform> for TimeunitTransform {
    fn from(value: &TimeunitTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformAs {
    Variant0(TimeunitTransformAsVariant0, TimeunitTransformAsVariant0),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformAs> for TimeunitTransformAs {
    fn from(value: &TimeunitTransformAs) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformAs {
    fn default() -> Self {
        TimeunitTransformAs::Variant0(
            TimeunitTransformAsVariant0::Variant0("unit0".to_string()),
            TimeunitTransformAsVariant0::Variant0("unit1".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformAsVariant0> for TimeunitTransformAsVariant0 {
    fn from(value: &TimeunitTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformExtent {
    Variant0(Vec<TimeunitTransformExtentVariant0Item>),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformExtent> for TimeunitTransformExtent {
    fn from(value: &TimeunitTransformExtent) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformExtentVariant0Item> for TimeunitTransformExtentVariant0Item {
    fn from(value: &TimeunitTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&TimeunitTransformField> for TimeunitTransformField {
    fn from(value: &TimeunitTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformInterval> for TimeunitTransformInterval {
    fn from(value: &TimeunitTransformInterval) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformInterval {
    fn default() -> Self {
        TimeunitTransformInterval::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformMaxbins> for TimeunitTransformMaxbins {
    fn from(value: &TimeunitTransformMaxbins) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformMaxbins {
    fn default() -> Self {
        TimeunitTransformMaxbins::Variant0(40_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformStep> for TimeunitTransformStep {
    fn from(value: &TimeunitTransformStep) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformStep {
    fn default() -> Self {
        TimeunitTransformStep::Variant0(1_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformTimezone {
    Variant0(TimeunitTransformTimezoneVariant0),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformTimezone> for TimeunitTransformTimezone {
    fn from(value: &TimeunitTransformTimezone) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformTimezone {
    fn default() -> Self {
        TimeunitTransformTimezone::Variant0(TimeunitTransformTimezoneVariant0::Local)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformTimezoneVariant0 {
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&TimeunitTransformTimezoneVariant0> for TimeunitTransformTimezoneVariant0 {
    fn from(value: &TimeunitTransformTimezoneVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformTimezoneVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Local => "local".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformTimezoneVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "local" => Ok(Self::Local),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformTimezoneVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformTimezoneVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformTimezoneVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformType {
    #[serde(rename = "timeunit")]
    Timeunit,
}
impl From<&TimeunitTransformType> for TimeunitTransformType {
    fn from(value: &TimeunitTransformType) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Timeunit => "timeunit".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "timeunit" => Ok(Self::Timeunit),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformUnits {
    Variant0(Vec<TimeunitTransformUnitsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformUnits> for TimeunitTransformUnits {
    fn from(value: &TimeunitTransformUnits) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformUnitsVariant0Item {
    Variant0(TimeunitTransformUnitsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&TimeunitTransformUnitsVariant0Item> for TimeunitTransformUnitsVariant0Item {
    fn from(value: &TimeunitTransformUnitsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformUnitsVariant0ItemVariant0 {
    #[serde(rename = "year")]
    Year,
    #[serde(rename = "quarter")]
    Quarter,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "dayofyear")]
    Dayofyear,
    #[serde(rename = "hours")]
    Hours,
    #[serde(rename = "minutes")]
    Minutes,
    #[serde(rename = "seconds")]
    Seconds,
    #[serde(rename = "milliseconds")]
    Milliseconds,
}
impl From<&TimeunitTransformUnitsVariant0ItemVariant0>
    for TimeunitTransformUnitsVariant0ItemVariant0
{
    fn from(value: &TimeunitTransformUnitsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Year => "year".to_string(),
            Self::Quarter => "quarter".to_string(),
            Self::Month => "month".to_string(),
            Self::Week => "week".to_string(),
            Self::Date => "date".to_string(),
            Self::Day => "day".to_string(),
            Self::Dayofyear => "dayofyear".to_string(),
            Self::Hours => "hours".to_string(),
            Self::Minutes => "minutes".to_string(),
            Self::Seconds => "seconds".to_string(),
            Self::Milliseconds => "milliseconds".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "year" => Ok(Self::Year),
            "quarter" => Ok(Self::Quarter),
            "month" => Ok(Self::Month),
            "week" => Ok(Self::Week),
            "date" => Ok(Self::Date),
            "day" => Ok(Self::Day),
            "dayofyear" => Ok(Self::Dayofyear),
            "hours" => Ok(Self::Hours),
            "minutes" => Ok(Self::Minutes),
            "seconds" => Ok(Self::Seconds),
            "milliseconds" => Ok(Self::Milliseconds),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Title {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<TitleVariant1Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        anchor: Option<TitleVariant1Anchor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        angle: Option<TitleVariant1Angle>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        baseline: Option<TitleVariant1Baseline>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        color: Option<TitleVariant1Color>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dx: Option<TitleVariant1Dx>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dy: Option<TitleVariant1Dy>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<TitleVariant1Encode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        font: Option<TitleVariant1Font>,
        #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
        font_size: Option<TitleVariant1FontSize>,
        #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
        font_style: Option<TitleVariant1FontStyle>,
        #[serde(
            rename = "fontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        font_weight: Option<TitleVariant1FontWeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        frame: Option<TitleVariant1Frame>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interactive: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        limit: Option<TitleVariant1Limit>,
        #[serde(
            rename = "lineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        line_height: Option<TitleVariant1LineHeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<TitleVariant1Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<TitleVariant1Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        style: Option<Style>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        subtitle: Option<TextOrSignal>,
        #[serde(
            rename = "subtitleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_color: Option<TitleVariant1SubtitleColor>,
        #[serde(
            rename = "subtitleFont",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font: Option<TitleVariant1SubtitleFont>,
        #[serde(
            rename = "subtitleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_size: Option<TitleVariant1SubtitleFontSize>,
        #[serde(
            rename = "subtitleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_style: Option<TitleVariant1SubtitleFontStyle>,
        #[serde(
            rename = "subtitleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_weight: Option<TitleVariant1SubtitleFontWeight>,
        #[serde(
            rename = "subtitleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_line_height: Option<TitleVariant1SubtitleLineHeight>,
        #[serde(
            rename = "subtitlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        text: Option<TextOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
}
impl From<&Title> for Title {
    fn from(value: &Title) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Align {
    Variant0(TitleVariant1AlignVariant0),
    Variant1(AlignValue),
}
impl From<&TitleVariant1Align> for TitleVariant1Align {
    fn from(value: &TitleVariant1Align) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1AlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&TitleVariant1AlignVariant0> for TitleVariant1AlignVariant0 {
    fn from(value: &TitleVariant1AlignVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1AlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AlignVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AlignVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1AlignVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Anchor {
    Variant0(Option<TitleVariant1AnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&TitleVariant1Anchor> for TitleVariant1Anchor {
    fn from(value: &TitleVariant1Anchor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1AnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&TitleVariant1AnchorVariant0> for TitleVariant1AnchorVariant0 {
    fn from(value: &TitleVariant1AnchorVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1AnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AnchorVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1AnchorVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Angle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1Angle> for TitleVariant1Angle {
    fn from(value: &TitleVariant1Angle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Baseline {
    Variant0(TitleVariant1BaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&TitleVariant1Baseline> for TitleVariant1Baseline {
    fn from(value: &TitleVariant1Baseline) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1BaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&TitleVariant1BaselineVariant0> for TitleVariant1BaselineVariant0 {
    fn from(value: &TitleVariant1BaselineVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1BaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1BaselineVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1BaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1BaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1BaselineVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Color {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&TitleVariant1Color> for TitleVariant1Color {
    fn from(value: &TitleVariant1Color) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Dx {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1Dx> for TitleVariant1Dx {
    fn from(value: &TitleVariant1Dx) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Dy {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1Dy> for TitleVariant1Dy {
    fn from(value: &TitleVariant1Dy) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TitleVariant1Encode {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TitleVariant1EncodeSubtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TitleVariant1EncodeSubtype1>,
}
impl From<&TitleVariant1Encode> for TitleVariant1Encode {
    fn from(value: &TitleVariant1Encode) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype0 {}
impl From<&TitleVariant1EncodeSubtype0> for TitleVariant1EncodeSubtype0 {
    fn from(value: &TitleVariant1EncodeSubtype0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subtitle: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&TitleVariant1EncodeSubtype1> for TitleVariant1EncodeSubtype1 {
    fn from(value: &TitleVariant1EncodeSubtype1) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Font {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&TitleVariant1Font> for TitleVariant1Font {
    fn from(value: &TitleVariant1Font) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1FontSize> for TitleVariant1FontSize {
    fn from(value: &TitleVariant1FontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&TitleVariant1FontStyle> for TitleVariant1FontStyle {
    fn from(value: &TitleVariant1FontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&TitleVariant1FontWeight> for TitleVariant1FontWeight {
    fn from(value: &TitleVariant1FontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Frame {
    Variant0(TitleVariant1FrameVariant0),
    Variant1(StringValue),
}
impl From<&TitleVariant1Frame> for TitleVariant1Frame {
    fn from(value: &TitleVariant1Frame) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1FrameVariant0 {
    #[serde(rename = "group")]
    Group,
    #[serde(rename = "bounds")]
    Bounds,
}
impl From<&TitleVariant1FrameVariant0> for TitleVariant1FrameVariant0 {
    fn from(value: &TitleVariant1FrameVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1FrameVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
            Self::Bounds => "bounds".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1FrameVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "group" => Ok(Self::Group),
            "bounds" => Ok(Self::Bounds),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1FrameVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1FrameVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1FrameVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Limit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1Limit> for TitleVariant1Limit {
    fn from(value: &TitleVariant1Limit) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1LineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1LineHeight> for TitleVariant1LineHeight {
    fn from(value: &TitleVariant1LineHeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1Offset> for TitleVariant1Offset {
    fn from(value: &TitleVariant1Offset) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Orient {
    Variant0(TitleVariant1OrientVariant0),
    Variant1(SignalRef),
}
impl From<&TitleVariant1Orient> for TitleVariant1Orient {
    fn from(value: &TitleVariant1Orient) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&TitleVariant1OrientVariant0> for TitleVariant1OrientVariant0 {
    fn from(value: &TitleVariant1OrientVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1OrientVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1OrientVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl Default for TitleVariant1OrientVariant0 {
    fn default() -> Self {
        TitleVariant1OrientVariant0::Top
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&TitleVariant1SubtitleColor> for TitleVariant1SubtitleColor {
    fn from(value: &TitleVariant1SubtitleColor) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&TitleVariant1SubtitleFont> for TitleVariant1SubtitleFont {
    fn from(value: &TitleVariant1SubtitleFont) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1SubtitleFontSize> for TitleVariant1SubtitleFontSize {
    fn from(value: &TitleVariant1SubtitleFontSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&TitleVariant1SubtitleFontStyle> for TitleVariant1SubtitleFontStyle {
    fn from(value: &TitleVariant1SubtitleFontStyle) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&TitleVariant1SubtitleFontWeight> for TitleVariant1SubtitleFontWeight {
    fn from(value: &TitleVariant1SubtitleFontWeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&TitleVariant1SubtitleLineHeight> for TitleVariant1SubtitleLineHeight {
    fn from(value: &TitleVariant1SubtitleLineHeight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Transform {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    ContourTransform(ContourTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    GraticuleTransform(GraticuleTransform),
    HeatmapTransform(HeatmapTransform),
    IsocontourTransform(IsocontourTransform),
    Kde2dTransform(Kde2dTransform),
    NestTransform(NestTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreelinksTransform(TreelinksTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    LoessTransform(LoessTransform),
    RegressionTransform(RegressionTransform),
    AggregateTransform(AggregateTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    CountpatternTransform(CountpatternTransform),
    CrossTransform(CrossTransform),
    DensityTransform(DensityTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FilterTransform(FilterTransform),
    FlattenTransform(FlattenTransform),
    FoldTransform(FoldTransform),
    FormulaTransform(FormulaTransform),
    ImputeTransform(ImputeTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    KdeTransform(KdeTransform),
    LookupTransform(LookupTransform),
    PivotTransform(PivotTransform),
    ProjectTransform(ProjectTransform),
    QuantileTransform(QuantileTransform),
    SampleTransform(SampleTransform),
    SequenceTransform(SequenceTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl From<&Transform> for Transform {
    fn from(value: &Transform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TransformMark {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    HeatmapTransform(HeatmapTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FormulaTransform(FormulaTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    LookupTransform(LookupTransform),
    SampleTransform(SampleTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl From<&TransformMark> for TransformMark {
    fn from(value: &TransformMark) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreeTransform {
    #[serde(rename = "as", default = "defaults::tree_transform_as")]
    pub as_: TreeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreeTransformField>,
    #[serde(default = "defaults::tree_transform_method")]
    pub method: TreeTransformMethod,
    #[serde(rename = "nodeSize", default, skip_serializing_if = "Option::is_none")]
    pub node_size: Option<TreeTransformNodeSize>,
    #[serde(default = "defaults::tree_transform_separation")]
    pub separation: TreeTransformSeparation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreeTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreeTransformType,
}
impl From<&TreeTransform> for TreeTransform {
    fn from(value: &TreeTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformAs {
    Variant0(
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
        TreeTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&TreeTransformAs> for TreeTransformAs {
    fn from(value: &TreeTransformAs) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformAs {
    fn default() -> Self {
        TreeTransformAs::Variant0(
            TreeTransformAsVariant0::Variant0("x".to_string()),
            TreeTransformAsVariant0::Variant0("y".to_string()),
            TreeTransformAsVariant0::Variant0("depth".to_string()),
            TreeTransformAsVariant0::Variant0("children".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&TreeTransformAsVariant0> for TreeTransformAsVariant0 {
    fn from(value: &TreeTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&TreeTransformField> for TreeTransformField {
    fn from(value: &TreeTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformMethod {
    Variant0(TreeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&TreeTransformMethod> for TreeTransformMethod {
    fn from(value: &TreeTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformMethod {
    fn default() -> Self {
        TreeTransformMethod::Variant0(TreeTransformMethodVariant0::Tidy)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreeTransformMethodVariant0 {
    #[serde(rename = "tidy")]
    Tidy,
    #[serde(rename = "cluster")]
    Cluster,
}
impl From<&TreeTransformMethodVariant0> for TreeTransformMethodVariant0 {
    fn from(value: &TreeTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TreeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Tidy => "tidy".to_string(),
            Self::Cluster => "cluster".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tidy" => Ok(Self::Tidy),
            "cluster" => Ok(Self::Cluster),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreeTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformNodeSize {
    Variant0(TreeTransformNodeSizeVariant0, TreeTransformNodeSizeVariant0),
    Variant1(SignalRef),
}
impl From<&TreeTransformNodeSize> for TreeTransformNodeSize {
    fn from(value: &TreeTransformNodeSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformNodeSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreeTransformNodeSizeVariant0> for TreeTransformNodeSizeVariant0 {
    fn from(value: &TreeTransformNodeSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSeparation {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&TreeTransformSeparation> for TreeTransformSeparation {
    fn from(value: &TreeTransformSeparation) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformSeparation {
    fn default() -> Self {
        TreeTransformSeparation::Variant0(true)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSize {
    Variant0(TreeTransformSizeVariant0, TreeTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&TreeTransformSize> for TreeTransformSize {
    fn from(value: &TreeTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreeTransformSizeVariant0> for TreeTransformSizeVariant0 {
    fn from(value: &TreeTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreeTransformType {
    #[serde(rename = "tree")]
    Tree,
}
impl From<&TreeTransformType> for TreeTransformType {
    fn from(value: &TreeTransformType) -> Self {
        value.clone()
    }
}
impl ToString for TreeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tree => "tree".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "tree" => Ok(Self::Tree),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreeTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreelinksTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: TreelinksTransformType,
}
impl From<&TreelinksTransform> for TreelinksTransform {
    fn from(value: &TreelinksTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreelinksTransformType {
    #[serde(rename = "treelinks")]
    Treelinks,
}
impl From<&TreelinksTransformType> for TreelinksTransformType {
    fn from(value: &TreelinksTransformType) -> Self {
        value.clone()
    }
}
impl ToString for TreelinksTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treelinks => "treelinks".to_string(),
        }
    }
}
impl std::str::FromStr for TreelinksTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "treelinks" => Ok(Self::Treelinks),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreelinksTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreelinksTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreelinksTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreemapTransform {
    #[serde(rename = "as", default = "defaults::treemap_transform_as")]
    pub as_: TreemapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreemapTransformField>,
    #[serde(default = "defaults::treemap_transform_method")]
    pub method: TreemapTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<TreemapTransformPadding>,
    #[serde(
        rename = "paddingBottom",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_bottom: Option<TreemapTransformPaddingBottom>,
    #[serde(
        rename = "paddingInner",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_inner: Option<TreemapTransformPaddingInner>,
    #[serde(
        rename = "paddingLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_left: Option<TreemapTransformPaddingLeft>,
    #[serde(
        rename = "paddingOuter",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_outer: Option<TreemapTransformPaddingOuter>,
    #[serde(
        rename = "paddingRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_right: Option<TreemapTransformPaddingRight>,
    #[serde(
        rename = "paddingTop",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_top: Option<TreemapTransformPaddingTop>,
    #[serde(default = "defaults::treemap_transform_ratio")]
    pub ratio: TreemapTransformRatio,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<TreemapTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreemapTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreemapTransformType,
}
impl From<&TreemapTransform> for TreemapTransform {
    fn from(value: &TreemapTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformAs {
    Variant0(
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
        TreemapTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&TreemapTransformAs> for TreemapTransformAs {
    fn from(value: &TreemapTransformAs) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformAs {
    fn default() -> Self {
        TreemapTransformAs::Variant0(
            TreemapTransformAsVariant0::Variant0("x0".to_string()),
            TreemapTransformAsVariant0::Variant0("y0".to_string()),
            TreemapTransformAsVariant0::Variant0("x1".to_string()),
            TreemapTransformAsVariant0::Variant0("y1".to_string()),
            TreemapTransformAsVariant0::Variant0("depth".to_string()),
            TreemapTransformAsVariant0::Variant0("children".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&TreemapTransformAsVariant0> for TreemapTransformAsVariant0 {
    fn from(value: &TreemapTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&TreemapTransformField> for TreemapTransformField {
    fn from(value: &TreemapTransformField) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformMethod {
    Variant0(TreemapTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&TreemapTransformMethod> for TreemapTransformMethod {
    fn from(value: &TreemapTransformMethod) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformMethod {
    fn default() -> Self {
        TreemapTransformMethod::Variant0(TreemapTransformMethodVariant0::Squarify)
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreemapTransformMethodVariant0 {
    #[serde(rename = "squarify")]
    Squarify,
    #[serde(rename = "resquarify")]
    Resquarify,
    #[serde(rename = "binary")]
    Binary,
    #[serde(rename = "dice")]
    Dice,
    #[serde(rename = "slice")]
    Slice,
    #[serde(rename = "slicedice")]
    Slicedice,
}
impl From<&TreemapTransformMethodVariant0> for TreemapTransformMethodVariant0 {
    fn from(value: &TreemapTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ToString for TreemapTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Squarify => "squarify".to_string(),
            Self::Resquarify => "resquarify".to_string(),
            Self::Binary => "binary".to_string(),
            Self::Dice => "dice".to_string(),
            Self::Slice => "slice".to_string(),
            Self::Slicedice => "slicedice".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformMethodVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "squarify" => Ok(Self::Squarify),
            "resquarify" => Ok(Self::Resquarify),
            "binary" => Ok(Self::Binary),
            "dice" => Ok(Self::Dice),
            "slice" => Ok(Self::Slice),
            "slicedice" => Ok(Self::Slicedice),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreemapTransformMethodVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPadding> for TreemapTransformPadding {
    fn from(value: &TreemapTransformPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingBottom {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingBottom> for TreemapTransformPaddingBottom {
    fn from(value: &TreemapTransformPaddingBottom) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingInner {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingInner> for TreemapTransformPaddingInner {
    fn from(value: &TreemapTransformPaddingInner) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingLeft {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingLeft> for TreemapTransformPaddingLeft {
    fn from(value: &TreemapTransformPaddingLeft) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingOuter {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingOuter> for TreemapTransformPaddingOuter {
    fn from(value: &TreemapTransformPaddingOuter) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingRight {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingRight> for TreemapTransformPaddingRight {
    fn from(value: &TreemapTransformPaddingRight) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingTop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformPaddingTop> for TreemapTransformPaddingTop {
    fn from(value: &TreemapTransformPaddingTop) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformRatio {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformRatio> for TreemapTransformRatio {
    fn from(value: &TreemapTransformRatio) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformRatio {
    fn default() -> Self {
        TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&TreemapTransformRound> for TreemapTransformRound {
    fn from(value: &TreemapTransformRound) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformSize {
    Variant0(TreemapTransformSizeVariant0, TreemapTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&TreemapTransformSize> for TreemapTransformSize {
    fn from(value: &TreemapTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&TreemapTransformSizeVariant0> for TreemapTransformSizeVariant0 {
    fn from(value: &TreemapTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreemapTransformType {
    #[serde(rename = "treemap")]
    Treemap,
}
impl From<&TreemapTransformType> for TreemapTransformType {
    fn from(value: &TreemapTransformType) -> Self {
        value.clone()
    }
}
impl ToString for TreemapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treemap => "treemap".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "treemap" => Ok(Self::Treemap),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreemapTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VoronoiTransform {
    #[serde(rename = "as", default = "defaults::voronoi_transform_as")]
    pub as_: VoronoiTransformAs,
    #[serde(default = "defaults::voronoi_transform_extent")]
    pub extent: VoronoiTransformExtent,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<VoronoiTransformSize>,
    #[serde(rename = "type")]
    pub type_: VoronoiTransformType,
    pub x: VoronoiTransformX,
    pub y: VoronoiTransformY,
}
impl From<&VoronoiTransform> for VoronoiTransform {
    fn from(value: &VoronoiTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&VoronoiTransformAs> for VoronoiTransformAs {
    fn from(value: &VoronoiTransformAs) -> Self {
        value.clone()
    }
}
impl Default for VoronoiTransformAs {
    fn default() -> Self {
        VoronoiTransformAs::Variant0("path".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformExtent {
    Variant0(serde_json::Value, serde_json::Value),
    Variant1(SignalRef),
}
impl From<&VoronoiTransformExtent> for VoronoiTransformExtent {
    fn from(value: &VoronoiTransformExtent) -> Self {
        value.clone()
    }
}
impl Default for VoronoiTransformExtent {
    fn default() -> Self {
        VoronoiTransformExtent::Variant0(
            serde_json::from_str::<serde_json::Value>("[-100000,-100000]").unwrap(),
            serde_json::from_str::<serde_json::Value>("[100000,100000]").unwrap(),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformSize {
    Variant0(VoronoiTransformSizeVariant0, VoronoiTransformSizeVariant0),
    Variant1(SignalRef),
}
impl From<&VoronoiTransformSize> for VoronoiTransformSize {
    fn from(value: &VoronoiTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&VoronoiTransformSizeVariant0> for VoronoiTransformSizeVariant0 {
    fn from(value: &VoronoiTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum VoronoiTransformType {
    #[serde(rename = "voronoi")]
    Voronoi,
}
impl From<&VoronoiTransformType> for VoronoiTransformType {
    fn from(value: &VoronoiTransformType) -> Self {
        value.clone()
    }
}
impl ToString for VoronoiTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Voronoi => "voronoi".to_string(),
        }
    }
}
impl std::str::FromStr for VoronoiTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "voronoi" => Ok(Self::Voronoi),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for VoronoiTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for VoronoiTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for VoronoiTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&VoronoiTransformX> for VoronoiTransformX {
    fn from(value: &VoronoiTransformX) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&VoronoiTransformY> for VoronoiTransformY {
    fn from(value: &VoronoiTransformY) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WindowTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<WindowTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<WindowTransformFields>,
    #[serde(default = "defaults::window_transform_frame")]
    pub frame: WindowTransformFrame,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<WindowTransformGroupby>,
    #[serde(
        rename = "ignorePeers",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ignore_peers: Option<WindowTransformIgnorePeers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<WindowTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<WindowTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: WindowTransformType,
}
impl From<&WindowTransform> for WindowTransform {
    fn from(value: &WindowTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformAs {
    Variant0(Vec<WindowTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&WindowTransformAs> for WindowTransformAs {
    fn from(value: &WindowTransformAs) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&WindowTransformAsVariant0Item> for WindowTransformAsVariant0Item {
    fn from(value: &WindowTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFields {
    Variant0(Vec<WindowTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&WindowTransformFields> for WindowTransformFields {
    fn from(value: &WindowTransformFields) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&WindowTransformFieldsVariant0Item> for WindowTransformFieldsVariant0Item {
    fn from(value: &WindowTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFrame {
    Variant0(WindowTransformFrameVariant0, WindowTransformFrameVariant0),
    Variant1(SignalRef),
}
impl From<&WindowTransformFrame> for WindowTransformFrame {
    fn from(value: &WindowTransformFrame) -> Self {
        value.clone()
    }
}
impl Default for WindowTransformFrame {
    fn default() -> Self {
        WindowTransformFrame::Variant0(
            WindowTransformFrameVariant0::Variant2,
            WindowTransformFrameVariant0::Variant0(0_f64),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFrameVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&WindowTransformFrameVariant0> for WindowTransformFrameVariant0 {
    fn from(value: &WindowTransformFrameVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformGroupby {
    Variant0(Vec<WindowTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&WindowTransformGroupby> for WindowTransformGroupby {
    fn from(value: &WindowTransformGroupby) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&WindowTransformGroupbyVariant0Item> for WindowTransformGroupbyVariant0Item {
    fn from(value: &WindowTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformIgnorePeers {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&WindowTransformIgnorePeers> for WindowTransformIgnorePeers {
    fn from(value: &WindowTransformIgnorePeers) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformOps {
    Variant0(Vec<WindowTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&WindowTransformOps> for WindowTransformOps {
    fn from(value: &WindowTransformOps) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformOpsVariant0Item {
    Variant0(WindowTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&WindowTransformOpsVariant0Item> for WindowTransformOpsVariant0Item {
    fn from(value: &WindowTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WindowTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "row_number")]
    RowNumber,
    #[serde(rename = "rank")]
    Rank,
    #[serde(rename = "dense_rank")]
    DenseRank,
    #[serde(rename = "percent_rank")]
    PercentRank,
    #[serde(rename = "cume_dist")]
    CumeDist,
    #[serde(rename = "ntile")]
    Ntile,
    #[serde(rename = "lag")]
    Lag,
    #[serde(rename = "lead")]
    Lead,
    #[serde(rename = "first_value")]
    FirstValue,
    #[serde(rename = "last_value")]
    LastValue,
    #[serde(rename = "nth_value")]
    NthValue,
    #[serde(rename = "prev_value")]
    PrevValue,
    #[serde(rename = "next_value")]
    NextValue,
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&WindowTransformOpsVariant0ItemVariant0> for WindowTransformOpsVariant0ItemVariant0 {
    fn from(value: &WindowTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ToString for WindowTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::RowNumber => "row_number".to_string(),
            Self::Rank => "rank".to_string(),
            Self::DenseRank => "dense_rank".to_string(),
            Self::PercentRank => "percent_rank".to_string(),
            Self::CumeDist => "cume_dist".to_string(),
            Self::Ntile => "ntile".to_string(),
            Self::Lag => "lag".to_string(),
            Self::Lead => "lead".to_string(),
            Self::FirstValue => "first_value".to_string(),
            Self::LastValue => "last_value".to_string(),
            Self::NthValue => "nth_value".to_string(),
            Self::PrevValue => "prev_value".to_string(),
            Self::NextValue => "next_value".to_string(),
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformOpsVariant0ItemVariant0 {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "row_number" => Ok(Self::RowNumber),
            "rank" => Ok(Self::Rank),
            "dense_rank" => Ok(Self::DenseRank),
            "percent_rank" => Ok(Self::PercentRank),
            "cume_dist" => Ok(Self::CumeDist),
            "ntile" => Ok(Self::Ntile),
            "lag" => Ok(Self::Lag),
            "lead" => Ok(Self::Lead),
            "first_value" => Ok(Self::FirstValue),
            "last_value" => Ok(Self::LastValue),
            "nth_value" => Ok(Self::NthValue),
            "prev_value" => Ok(Self::PrevValue),
            "next_value" => Ok(Self::NextValue),
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformParams {
    Variant0(Vec<WindowTransformParamsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&WindowTransformParams> for WindowTransformParams {
    fn from(value: &WindowTransformParams) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformParamsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&WindowTransformParamsVariant0Item> for WindowTransformParamsVariant0Item {
    fn from(value: &WindowTransformParamsVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WindowTransformType {
    #[serde(rename = "window")]
    Window,
}
impl From<&WindowTransformType> for WindowTransformType {
    fn from(value: &WindowTransformType) -> Self {
        value.clone()
    }
}
impl ToString for WindowTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Window => "window".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "window" => Ok(Self::Window),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WindowTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WordcloudTransform {
    #[serde(rename = "as", default = "defaults::wordcloud_transform_as")]
    pub as_: WordcloudTransformAs,
    #[serde(default = "defaults::wordcloud_transform_font")]
    pub font: WordcloudTransformFont,
    #[serde(
        rename = "fontSize",
        default = "defaults::wordcloud_transform_font_size"
    )]
    pub font_size: WordcloudTransformFontSize,
    #[serde(
        rename = "fontSizeRange",
        default = "defaults::wordcloud_transform_font_size_range"
    )]
    pub font_size_range: WordcloudTransformFontSizeRange,
    #[serde(
        rename = "fontStyle",
        default = "defaults::wordcloud_transform_font_style"
    )]
    pub font_style: WordcloudTransformFontStyle,
    #[serde(
        rename = "fontWeight",
        default = "defaults::wordcloud_transform_font_weight"
    )]
    pub font_weight: WordcloudTransformFontWeight,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<WordcloudTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<WordcloudTransformRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<WordcloudTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spiral: Option<WordcloudTransformSpiral>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<WordcloudTransformText>,
    #[serde(rename = "type")]
    pub type_: WordcloudTransformType,
}
impl From<&WordcloudTransform> for WordcloudTransform {
    fn from(value: &WordcloudTransform) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformAs {
    Variant0(
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
        WordcloudTransformAsVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformAs> for WordcloudTransformAs {
    fn from(value: &WordcloudTransformAs) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformAs {
    fn default() -> Self {
        WordcloudTransformAs::Variant0(
            WordcloudTransformAsVariant0::Variant0("x".to_string()),
            WordcloudTransformAsVariant0::Variant0("y".to_string()),
            WordcloudTransformAsVariant0::Variant0("font".to_string()),
            WordcloudTransformAsVariant0::Variant0("fontSize".to_string()),
            WordcloudTransformAsVariant0::Variant0("fontStyle".to_string()),
            WordcloudTransformAsVariant0::Variant0("fontWeight".to_string()),
            WordcloudTransformAsVariant0::Variant0("angle".to_string()),
        )
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformAsVariant0 {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformAsVariant0> for WordcloudTransformAsVariant0 {
    fn from(value: &WordcloudTransformAsVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFont {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformFont> for WordcloudTransformFont {
    fn from(value: &WordcloudTransformFont) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFont {
    fn default() -> Self {
        WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSize {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformFontSize> for WordcloudTransformFontSize {
    fn from(value: &WordcloudTransformFontSize) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontSize {
    fn default() -> Self {
        WordcloudTransformFontSize::Variant0(14_f64)
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRange {
    Variant0(Vec<WordcloudTransformFontSizeRangeVariant0Item>),
    Variant1(SignalRef),
    Variant2,
}
impl From<&WordcloudTransformFontSizeRange> for WordcloudTransformFontSizeRange {
    fn from(value: &WordcloudTransformFontSizeRange) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontSizeRange {
    fn default() -> Self {
        WordcloudTransformFontSizeRange::Variant0(vec![
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRangeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformFontSizeRangeVariant0Item>
    for WordcloudTransformFontSizeRangeVariant0Item
{
    fn from(value: &WordcloudTransformFontSizeRangeVariant0Item) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontStyle {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformFontStyle> for WordcloudTransformFontStyle {
    fn from(value: &WordcloudTransformFontStyle) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontStyle {
    fn default() -> Self {
        WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontWeight {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformFontWeight> for WordcloudTransformFontWeight {
    fn from(value: &WordcloudTransformFontWeight) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontWeight {
    fn default() -> Self {
        WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformPadding> for WordcloudTransformPadding {
    fn from(value: &WordcloudTransformPadding) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformRotate {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&WordcloudTransformRotate> for WordcloudTransformRotate {
    fn from(value: &WordcloudTransformRotate) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSize {
    Variant0(
        WordcloudTransformSizeVariant0,
        WordcloudTransformSizeVariant0,
    ),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformSize> for WordcloudTransformSize {
    fn from(value: &WordcloudTransformSize) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSizeVariant0 {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformSizeVariant0> for WordcloudTransformSizeVariant0 {
    fn from(value: &WordcloudTransformSizeVariant0) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSpiral {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&WordcloudTransformSpiral> for WordcloudTransformSpiral {
    fn from(value: &WordcloudTransformSpiral) -> Self {
        value.clone()
    }
}
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformText {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&WordcloudTransformText> for WordcloudTransformText {
    fn from(value: &WordcloudTransformText) -> Self {
        value.clone()
    }
}
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WordcloudTransformType {
    #[serde(rename = "wordcloud")]
    Wordcloud,
}
impl From<&WordcloudTransformType> for WordcloudTransformType {
    fn from(value: &WordcloudTransformType) -> Self {
        value.clone()
    }
}
impl ToString for WordcloudTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Wordcloud => "wordcloud".to_string(),
        }
    }
}
impl std::str::FromStr for WordcloudTransformType {
    type Err = &'static str;
    fn from_str(value: &str) -> Result<Self, &'static str> {
        match value {
            "wordcloud" => Ok(Self::Wordcloud),
            _ => Err("invalid value"),
        }
    }
}
impl std::convert::TryFrom<&str> for WordcloudTransformType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WordcloudTransformType {
    type Error = &'static str;
    fn try_from(value: &String) -> Result<Self, &'static str> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WordcloudTransformType {
    type Error = &'static str;
    fn try_from(value: String) -> Result<Self, &'static str> {
        value.parse()
    }
}
mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn default_i64<T, const V: i64>() -> T
    where
        T: std::convert::TryFrom<i64>,
        <T as std::convert::TryFrom<i64>>::Error: std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
    pub(super) fn aggregate_transform_drop() -> super::AggregateTransformDrop {
        super::AggregateTransformDrop::Variant0(true)
    }
    pub(super) fn bin_transform_as() -> super::BinTransformAs {
        super::BinTransformAs::Variant0(
            super::BinTransformAsVariant0::Variant0("bin0".to_string()),
            super::BinTransformAsVariant0::Variant0("bin1".to_string()),
        )
    }
    pub(super) fn bin_transform_base() -> super::BinTransformBase {
        super::BinTransformBase::Variant0(10_f64)
    }
    pub(super) fn bin_transform_divide() -> super::BinTransformDivide {
        super::BinTransformDivide::Variant0(vec![
            super::BinTransformDivideVariant0Item::Variant0(5_f64),
            super::BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
    pub(super) fn bin_transform_interval() -> super::BinTransformInterval {
        super::BinTransformInterval::Variant0(true)
    }
    pub(super) fn bin_transform_maxbins() -> super::BinTransformMaxbins {
        super::BinTransformMaxbins::Variant0(20_f64)
    }
    pub(super) fn bin_transform_nice() -> super::BinTransformNice {
        super::BinTransformNice::Variant0(true)
    }
    pub(super) fn contour_transform_smooth() -> super::ContourTransformSmooth {
        super::ContourTransformSmooth::Variant0(true)
    }
    pub(super) fn countpattern_transform_as() -> super::CountpatternTransformAs {
        super::CountpatternTransformAs::Variant0(
            super::CountpatternTransformAsVariant0::Variant0("text".to_string()),
            super::CountpatternTransformAsVariant0::Variant0("count".to_string()),
        )
    }
    pub(super) fn countpattern_transform_case() -> super::CountpatternTransformCase {
        super::CountpatternTransformCase::Variant0(super::CountpatternTransformCaseVariant0::Mixed)
    }
    pub(super) fn countpattern_transform_pattern() -> super::CountpatternTransformPattern {
        super::CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
    pub(super) fn cross_transform_as() -> super::CrossTransformAs {
        super::CrossTransformAs::Variant0(
            super::CrossTransformAsVariant0::Variant0("a".to_string()),
            super::CrossTransformAsVariant0::Variant0("b".to_string()),
        )
    }
    pub(super) fn density_transform_as() -> super::DensityTransformAs {
        super::DensityTransformAs::Variant0(vec![
            super::DensityTransformAsVariant0Item::Variant0("value".to_string()),
            super::DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn density_transform_maxsteps() -> super::DensityTransformMaxsteps {
        super::DensityTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn density_transform_method() -> super::DensityTransformMethod {
        super::DensityTransformMethod::Variant0("pdf".to_string())
    }
    pub(super) fn density_transform_minsteps() -> super::DensityTransformMinsteps {
        super::DensityTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn density_transform_distribution_variant0_stdev(
    ) -> super::DensityTransformDistributionVariant0Stdev {
        super::DensityTransformDistributionVariant0Stdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_variant1_stdev(
    ) -> super::DensityTransformDistributionVariant1Stdev {
        super::DensityTransformDistributionVariant1Stdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_variant2_max(
    ) -> super::DensityTransformDistributionVariant2Max {
        super::DensityTransformDistributionVariant2Max::Variant0(1_f64)
    }
    pub(super) fn dotbin_transform_as() -> super::DotbinTransformAs {
        super::DotbinTransformAs::Variant0("bin".to_string())
    }
    pub(super) fn fold_transform_as() -> super::FoldTransformAs {
        super::FoldTransformAs::Variant0(
            super::FoldTransformAsVariant0::Variant0("key".to_string()),
            super::FoldTransformAsVariant0::Variant0("value".to_string()),
        )
    }
    pub(super) fn force_transform_alpha() -> super::ForceTransformAlpha {
        super::ForceTransformAlpha::Variant0(1_f64)
    }
    pub(super) fn force_transform_alpha_min() -> super::ForceTransformAlphaMin {
        super::ForceTransformAlphaMin::Variant0(0.001_f64)
    }
    pub(super) fn force_transform_as() -> super::ForceTransformAs {
        super::ForceTransformAs::Variant0(vec![
            super::ForceTransformAsVariant0Item::Variant0("x".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("y".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
    pub(super) fn force_transform_iterations() -> super::ForceTransformIterations {
        super::ForceTransformIterations::Variant0(300_f64)
    }
    pub(super) fn force_transform_velocity_decay() -> super::ForceTransformVelocityDecay {
        super::ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
    pub(super) fn force_transform_forces_item_variant1_iterations(
    ) -> super::ForceTransformForcesItemVariant1Iterations {
        super::ForceTransformForcesItemVariant1Iterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant1_strength(
    ) -> super::ForceTransformForcesItemVariant1Strength {
        super::ForceTransformForcesItemVariant1Strength::Variant0(0.7_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_distance_min(
    ) -> super::ForceTransformForcesItemVariant2DistanceMin {
        super::ForceTransformForcesItemVariant2DistanceMin::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_strength(
    ) -> super::ForceTransformForcesItemVariant2Strength {
        super::ForceTransformForcesItemVariant2Strength::Variant0(-30_f64)
    }
    pub(super) fn force_transform_forces_item_variant2_theta(
    ) -> super::ForceTransformForcesItemVariant2Theta {
        super::ForceTransformForcesItemVariant2Theta::Variant0(0.9_f64)
    }
    pub(super) fn force_transform_forces_item_variant3_distance(
    ) -> super::ForceTransformForcesItemVariant3Distance {
        super::ForceTransformForcesItemVariant3Distance::Variant0(30_f64)
    }
    pub(super) fn force_transform_forces_item_variant3_iterations(
    ) -> super::ForceTransformForcesItemVariant3Iterations {
        super::ForceTransformForcesItemVariant3Iterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_variant4_strength(
    ) -> super::ForceTransformForcesItemVariant4Strength {
        super::ForceTransformForcesItemVariant4Strength::Variant0(0.1_f64)
    }
    pub(super) fn force_transform_forces_item_variant5_strength(
    ) -> super::ForceTransformForcesItemVariant5Strength {
        super::ForceTransformForcesItemVariant5Strength::Variant0(0.1_f64)
    }
    pub(super) fn geopath_transform_as() -> super::GeopathTransformAs {
        super::GeopathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn geopoint_transform_as() -> super::GeopointTransformAs {
        super::GeopointTransformAs::Variant0(
            super::GeopointTransformAsVariant0::Variant0("x".to_string()),
            super::GeopointTransformAsVariant0::Variant0("y".to_string()),
        )
    }
    pub(super) fn geoshape_transform_as() -> super::GeoshapeTransformAs {
        super::GeoshapeTransformAs::Variant0("shape".to_string())
    }
    pub(super) fn geoshape_transform_field() -> super::GeoshapeTransformField {
        super::GeoshapeTransformField::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("datum".to_string()),
        ))
    }
    pub(super) fn graticule_transform_precision() -> super::GraticuleTransformPrecision {
        super::GraticuleTransformPrecision::Variant0(2.5_f64)
    }
    pub(super) fn graticule_transform_step_major() -> super::GraticuleTransformStepMajor {
        super::GraticuleTransformStepMajor::Variant0(
            super::GraticuleTransformStepMajorVariant0::Variant0(90_f64),
            super::GraticuleTransformStepMajorVariant0::Variant0(360_f64),
        )
    }
    pub(super) fn graticule_transform_step_minor() -> super::GraticuleTransformStepMinor {
        super::GraticuleTransformStepMinor::Variant0(
            super::GraticuleTransformStepMinorVariant0::Variant0(10_f64),
            super::GraticuleTransformStepMinorVariant0::Variant0(10_f64),
        )
    }
    pub(super) fn heatmap_transform_as() -> super::HeatmapTransformAs {
        super::HeatmapTransformAs::Variant0("image".to_string())
    }
    pub(super) fn heatmap_transform_resolve() -> super::HeatmapTransformResolve {
        super::HeatmapTransformResolve::Variant0(
            super::HeatmapTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn impute_transform_method() -> super::ImputeTransformMethod {
        super::ImputeTransformMethod::Variant0(super::ImputeTransformMethodVariant0::Value)
    }
    pub(super) fn isocontour_transform_as() -> super::IsocontourTransformAs {
        super::IsocontourTransformAs::Variant0("contour".to_string())
    }
    pub(super) fn isocontour_transform_resolve() -> super::IsocontourTransformResolve {
        super::IsocontourTransformResolve::Variant0(
            super::IsocontourTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn isocontour_transform_smooth() -> super::IsocontourTransformSmooth {
        super::IsocontourTransformSmooth::Variant0(true)
    }
    pub(super) fn isocontour_transform_zero() -> super::IsocontourTransformZero {
        super::IsocontourTransformZero::Variant0(true)
    }
    pub(super) fn kde2d_transform_as() -> super::Kde2dTransformAs {
        super::Kde2dTransformAs::Variant0("grid".to_string())
    }
    pub(super) fn kde_transform_as() -> super::KdeTransformAs {
        super::KdeTransformAs::Variant0(vec![
            super::KdeTransformAsVariant0Item::Variant0("value".to_string()),
            super::KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn kde_transform_maxsteps() -> super::KdeTransformMaxsteps {
        super::KdeTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn kde_transform_minsteps() -> super::KdeTransformMinsteps {
        super::KdeTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn kde_transform_resolve() -> super::KdeTransformResolve {
        super::KdeTransformResolve::Variant0(super::KdeTransformResolveVariant0::Independent)
    }
    pub(super) fn label_transform_anchor() -> super::LabelTransformAnchor {
        super::LabelTransformAnchor::Variant0(vec![
            super::LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
    pub(super) fn label_transform_as() -> super::LabelTransformAs {
        super::LabelTransformAs::Variant0(
            super::LabelTransformAsVariant0::Variant0("x".to_string()),
            super::LabelTransformAsVariant0::Variant0("y".to_string()),
            super::LabelTransformAsVariant0::Variant0("opacity".to_string()),
            super::LabelTransformAsVariant0::Variant0("align".to_string()),
            super::LabelTransformAsVariant0::Variant0("baseline".to_string()),
        )
    }
    pub(super) fn label_transform_avoid_base_mark() -> super::LabelTransformAvoidBaseMark {
        super::LabelTransformAvoidBaseMark::Variant0(true)
    }
    pub(super) fn label_transform_line_anchor() -> super::LabelTransformLineAnchor {
        super::LabelTransformLineAnchor::Variant0("end".to_string())
    }
    pub(super) fn label_transform_method() -> super::LabelTransformMethod {
        super::LabelTransformMethod::Variant0("naive".to_string())
    }
    pub(super) fn label_transform_offset() -> super::LabelTransformOffset {
        super::LabelTransformOffset::Variant0(vec![
            super::LabelTransformOffsetVariant0Item::Variant0(1_f64),
        ])
    }
    pub(super) fn linkpath_transform_as() -> super::LinkpathTransformAs {
        super::LinkpathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn linkpath_transform_orient() -> super::LinkpathTransformOrient {
        super::LinkpathTransformOrient::Variant0(super::LinkpathTransformOrientVariant0::Vertical)
    }
    pub(super) fn linkpath_transform_shape() -> super::LinkpathTransformShape {
        super::LinkpathTransformShape::Variant0(super::LinkpathTransformShapeVariant0::Line)
    }
    pub(super) fn linkpath_transform_source_x() -> super::LinkpathTransformSourceX {
        super::LinkpathTransformSourceX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_source_y() -> super::LinkpathTransformSourceY {
        super::LinkpathTransformSourceY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.y".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_x() -> super::LinkpathTransformTargetX {
        super::LinkpathTransformTargetX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_y() -> super::LinkpathTransformTargetY {
        super::LinkpathTransformTargetY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.y".to_string()),
        ))
    }
    pub(super) fn loess_transform_bandwidth() -> super::LoessTransformBandwidth {
        super::LoessTransformBandwidth::Variant0(0.3_f64)
    }
    pub(super) fn pack_transform_as() -> super::PackTransformAs {
        super::PackTransformAs::Variant0(
            super::PackTransformAsVariant0::Variant0("x".to_string()),
            super::PackTransformAsVariant0::Variant0("y".to_string()),
            super::PackTransformAsVariant0::Variant0("r".to_string()),
            super::PackTransformAsVariant0::Variant0("depth".to_string()),
            super::PackTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn partition_transform_as() -> super::PartitionTransformAs {
        super::PartitionTransformAs::Variant0(
            super::PartitionTransformAsVariant0::Variant0("x0".to_string()),
            super::PartitionTransformAsVariant0::Variant0("y0".to_string()),
            super::PartitionTransformAsVariant0::Variant0("x1".to_string()),
            super::PartitionTransformAsVariant0::Variant0("y1".to_string()),
            super::PartitionTransformAsVariant0::Variant0("depth".to_string()),
            super::PartitionTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn pie_transform_as() -> super::PieTransformAs {
        super::PieTransformAs::Variant0(
            super::PieTransformAsVariant0::Variant0("startAngle".to_string()),
            super::PieTransformAsVariant0::Variant0("endAngle".to_string()),
        )
    }
    pub(super) fn pie_transform_end_angle() -> super::PieTransformEndAngle {
        super::PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
    pub(super) fn pivot_transform_op() -> super::PivotTransformOp {
        super::PivotTransformOp::Variant0(super::PivotTransformOpVariant0::Sum)
    }
    pub(super) fn quantile_transform_as() -> super::QuantileTransformAs {
        super::QuantileTransformAs::Variant0(vec![
            super::QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            super::QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn quantile_transform_step() -> super::QuantileTransformStep {
        super::QuantileTransformStep::Variant0(0.01_f64)
    }
    pub(super) fn regression_transform_method() -> super::RegressionTransformMethod {
        super::RegressionTransformMethod::Variant0("linear".to_string())
    }
    pub(super) fn regression_transform_order() -> super::RegressionTransformOrder {
        super::RegressionTransformOrder::Variant0(3_f64)
    }
    pub(super) fn sample_transform_size() -> super::SampleTransformSize {
        super::SampleTransformSize::Variant0(1000_f64)
    }
    pub(super) fn sequence_transform_as() -> super::SequenceTransformAs {
        super::SequenceTransformAs::Variant0("data".to_string())
    }
    pub(super) fn sequence_transform_step() -> super::SequenceTransformStep {
        super::SequenceTransformStep::Variant0(1_f64)
    }
    pub(super) fn stack_transform_as() -> super::StackTransformAs {
        super::StackTransformAs::Variant0(
            super::StackTransformAsVariant0::Variant0("y0".to_string()),
            super::StackTransformAsVariant0::Variant0("y1".to_string()),
        )
    }
    pub(super) fn stack_transform_offset() -> super::StackTransformOffset {
        super::StackTransformOffset::Variant0(super::StackTransformOffsetVariant0::Zero)
    }
    pub(super) fn timeunit_transform_as() -> super::TimeunitTransformAs {
        super::TimeunitTransformAs::Variant0(
            super::TimeunitTransformAsVariant0::Variant0("unit0".to_string()),
            super::TimeunitTransformAsVariant0::Variant0("unit1".to_string()),
        )
    }
    pub(super) fn timeunit_transform_interval() -> super::TimeunitTransformInterval {
        super::TimeunitTransformInterval::Variant0(true)
    }
    pub(super) fn timeunit_transform_maxbins() -> super::TimeunitTransformMaxbins {
        super::TimeunitTransformMaxbins::Variant0(40_f64)
    }
    pub(super) fn timeunit_transform_step() -> super::TimeunitTransformStep {
        super::TimeunitTransformStep::Variant0(1_f64)
    }
    pub(super) fn timeunit_transform_timezone() -> super::TimeunitTransformTimezone {
        super::TimeunitTransformTimezone::Variant0(super::TimeunitTransformTimezoneVariant0::Local)
    }
    pub(super) fn tree_transform_as() -> super::TreeTransformAs {
        super::TreeTransformAs::Variant0(
            super::TreeTransformAsVariant0::Variant0("x".to_string()),
            super::TreeTransformAsVariant0::Variant0("y".to_string()),
            super::TreeTransformAsVariant0::Variant0("depth".to_string()),
            super::TreeTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn tree_transform_method() -> super::TreeTransformMethod {
        super::TreeTransformMethod::Variant0(super::TreeTransformMethodVariant0::Tidy)
    }
    pub(super) fn tree_transform_separation() -> super::TreeTransformSeparation {
        super::TreeTransformSeparation::Variant0(true)
    }
    pub(super) fn treemap_transform_as() -> super::TreemapTransformAs {
        super::TreemapTransformAs::Variant0(
            super::TreemapTransformAsVariant0::Variant0("x0".to_string()),
            super::TreemapTransformAsVariant0::Variant0("y0".to_string()),
            super::TreemapTransformAsVariant0::Variant0("x1".to_string()),
            super::TreemapTransformAsVariant0::Variant0("y1".to_string()),
            super::TreemapTransformAsVariant0::Variant0("depth".to_string()),
            super::TreemapTransformAsVariant0::Variant0("children".to_string()),
        )
    }
    pub(super) fn treemap_transform_method() -> super::TreemapTransformMethod {
        super::TreemapTransformMethod::Variant0(super::TreemapTransformMethodVariant0::Squarify)
    }
    pub(super) fn treemap_transform_ratio() -> super::TreemapTransformRatio {
        super::TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
    pub(super) fn voronoi_transform_as() -> super::VoronoiTransformAs {
        super::VoronoiTransformAs::Variant0("path".to_string())
    }
    pub(super) fn voronoi_transform_extent() -> super::VoronoiTransformExtent {
        super::VoronoiTransformExtent::Variant0(
            serde_json::from_str::<serde_json::Value>("[-100000,-100000]").unwrap(),
            serde_json::from_str::<serde_json::Value>("[100000,100000]").unwrap(),
        )
    }
    pub(super) fn window_transform_frame() -> super::WindowTransformFrame {
        super::WindowTransformFrame::Variant0(
            super::WindowTransformFrameVariant0::Variant2,
            super::WindowTransformFrameVariant0::Variant0(0_f64),
        )
    }
    pub(super) fn wordcloud_transform_as() -> super::WordcloudTransformAs {
        super::WordcloudTransformAs::Variant0(
            super::WordcloudTransformAsVariant0::Variant0("x".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("y".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("font".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontSize".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontStyle".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("fontWeight".to_string()),
            super::WordcloudTransformAsVariant0::Variant0("angle".to_string()),
        )
    }
    pub(super) fn wordcloud_transform_font() -> super::WordcloudTransformFont {
        super::WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
    pub(super) fn wordcloud_transform_font_size() -> super::WordcloudTransformFontSize {
        super::WordcloudTransformFontSize::Variant0(14_f64)
    }
    pub(super) fn wordcloud_transform_font_size_range() -> super::WordcloudTransformFontSizeRange {
        super::WordcloudTransformFontSizeRange::Variant0(vec![
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
    pub(super) fn wordcloud_transform_font_style() -> super::WordcloudTransformFontStyle {
        super::WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
    pub(super) fn wordcloud_transform_font_weight() -> super::WordcloudTransformFontWeight {
        super::WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
