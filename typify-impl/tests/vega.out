#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "`AggregateTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cross\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"drop\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"aggregate\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AggregateTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<AggregateTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cross: ::std::option::Option<AggregateTransformCross>,
    #[serde(default = "defaults::aggregate_transform_drop")]
    pub drop: AggregateTransformDrop,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<AggregateTransformFields>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<AggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<AggregateTransformKey>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ops: ::std::option::Option<AggregateTransformOps>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: AggregateTransformType,
}
impl ::std::convert::From<&AggregateTransform> for AggregateTransform {
    fn from(value: &AggregateTransform) -> Self {
        value.clone()
    }
}
#[doc = "`AggregateTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformAs {
    Variant0(::std::vec::Vec<AggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformAs {
    fn from(value: &AggregateTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AggregateTransformAsVariant0Item>>
    for AggregateTransformAs
{
    fn from(value: ::std::vec::Vec<AggregateTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for AggregateTransformAsVariant0Item {
    fn from(value: &AggregateTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformCross`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformCross {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformCross {
    fn from(value: &AggregateTransformCross) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for AggregateTransformCross {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformCross {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformDrop`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformDrop {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformDrop {
    fn from(value: &AggregateTransformDrop) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AggregateTransformDrop {
    fn default() -> Self {
        AggregateTransformDrop::Variant0(true)
    }
}
impl ::std::convert::From<bool> for AggregateTransformDrop {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformDrop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformFields {
    Variant0(::std::vec::Vec<AggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformFields {
    fn from(value: &AggregateTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AggregateTransformFieldsVariant0Item>>
    for AggregateTransformFields
{
    fn from(value: ::std::vec::Vec<AggregateTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl ::std::convert::From<&Self> for AggregateTransformFieldsVariant0Item {
    fn from(value: &AggregateTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for AggregateTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ParamField> for AggregateTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for AggregateTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AggregateTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformGroupby {
    Variant0(::std::vec::Vec<AggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformGroupby {
    fn from(value: &AggregateTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AggregateTransformGroupbyVariant0Item>>
    for AggregateTransformGroupby
{
    fn from(value: ::std::vec::Vec<AggregateTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for AggregateTransformGroupbyVariant0Item {
    fn from(value: &AggregateTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for AggregateTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for AggregateTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for AggregateTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`AggregateTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for AggregateTransformKey {
    fn from(value: &AggregateTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for AggregateTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for AggregateTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for AggregateTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`AggregateTransformOps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformOps {
    Variant0(::std::vec::Vec<AggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformOps {
    fn from(value: &AggregateTransformOps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AggregateTransformOpsVariant0Item>>
    for AggregateTransformOps
{
    fn from(value: ::std::vec::Vec<AggregateTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformOpsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AggregateTransformOpsVariant0Item {
    Variant0(AggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AggregateTransformOpsVariant0Item {
    fn from(value: &AggregateTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AggregateTransformOpsVariant0ItemVariant0>
    for AggregateTransformOpsVariant0Item
{
    fn from(value: AggregateTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AggregateTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AggregateTransformOpsVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    XXcountXx,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ::std::convert::From<&Self> for AggregateTransformOpsVariant0ItemVariant0 {
    fn from(value: &AggregateTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AggregateTransformOpsVariant0ItemVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Values => write!(f, "values"),
            Self::Count => write!(f, "count"),
            Self::XXcountXx => write!(f, "__count__"),
            Self::Missing => write!(f, "missing"),
            Self::Valid => write!(f, "valid"),
            Self::Sum => write!(f, "sum"),
            Self::Product => write!(f, "product"),
            Self::Mean => write!(f, "mean"),
            Self::Average => write!(f, "average"),
            Self::Variance => write!(f, "variance"),
            Self::Variancep => write!(f, "variancep"),
            Self::Stdev => write!(f, "stdev"),
            Self::Stdevp => write!(f, "stdevp"),
            Self::Stderr => write!(f, "stderr"),
            Self::Distinct => write!(f, "distinct"),
            Self::Ci0 => write!(f, "ci0"),
            Self::Ci1 => write!(f, "ci1"),
            Self::Median => write!(f, "median"),
            Self::Q1 => write!(f, "q1"),
            Self::Q3 => write!(f, "q3"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
            Self::Argmin => write!(f, "argmin"),
            Self::Argmax => write!(f, "argmax"),
        }
    }
}
impl ::std::str::FromStr for AggregateTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::XXcountXx),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AggregateTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"aggregate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AggregateTransformType {
    #[serde(rename = "aggregate")]
    Aggregate,
}
impl ::std::convert::From<&Self> for AggregateTransformType {
    fn from(value: &AggregateTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AggregateTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Aggregate => write!(f, "aggregate"),
        }
    }
}
impl ::std::str::FromStr for AggregateTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "aggregate" => Ok(Self::Aggregate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AlignValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"left\","]
#[doc = "                              \"right\","]
#[doc = "                              \"center\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"center\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValue {
    Variant0(::std::vec::Vec<AlignValueVariant0Item>),
    Variant1(AlignValueVariant1),
}
impl ::std::convert::From<&Self> for AlignValue {
    fn from(value: &AlignValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AlignValueVariant0Item>> for AlignValue {
    fn from(value: ::std::vec::Vec<AlignValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValueVariant1> for AlignValue {
    fn from(value: AlignValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AlignValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"center\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant0Item {
    Variant0(AlignValueVariant0ItemVariant0),
    Variant1(AlignValueVariant0ItemVariant1),
    Variant2(AlignValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AlignValueVariant0Item {
    fn from(value: &AlignValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AlignValueVariant0ItemVariant0> for AlignValueVariant0Item {
    fn from(value: AlignValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValueVariant0ItemVariant1> for AlignValueVariant0Item {
    fn from(value: AlignValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AlignValueVariant0ItemVariant2> for AlignValueVariant0Item {
    fn from(value: AlignValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AlignValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: AlignValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: AlignValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AlignValueVariant0ItemVariant0 {
    fn from(value: &AlignValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`AlignValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AlignValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for AlignValueVariant0ItemVariant0Variant1Value {
    fn from(value: &AlignValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AlignValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for AlignValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AlignValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AlignValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AlignValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AlignValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AlignValueVariant0ItemVariant0Variant3Range {
    fn from(value: &AlignValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AlignValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AlignValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AlignValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AlignValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AlignValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AlignValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AlignValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AlignValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AlignValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for AlignValueVariant0ItemVariant1 {
    fn from(value: &AlignValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`AlignValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AlignValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for AlignValueVariant0ItemVariant2 {
    fn from(value: &AlignValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`AlignValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"left\","]
#[doc = "                    \"right\","]
#[doc = "                    \"center\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant1 {
    Variant0(AlignValueVariant1Variant0),
    Variant1(AlignValueVariant1Variant1),
    Variant2(AlignValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for AlignValueVariant1 {
    fn from(value: &AlignValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AlignValueVariant1Variant0> for AlignValueVariant1 {
    fn from(value: AlignValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValueVariant1Variant1> for AlignValueVariant1 {
    fn from(value: AlignValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AlignValueVariant1Variant2> for AlignValueVariant1 {
    fn from(value: AlignValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AlignValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: AlignValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: AlignValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for AlignValueVariant1Variant0 {
    fn from(value: &AlignValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`AlignValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AlignValueVariant1Variant0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for AlignValueVariant1Variant0Variant1Value {
    fn from(value: &AlignValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AlignValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for AlignValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AlignValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AlignValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AlignValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AlignValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AlignValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AlignValueVariant1Variant0Variant3Range {
    fn from(value: &AlignValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AlignValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AlignValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AlignValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AlignValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AlignValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AlignValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AlignValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AlignValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AlignValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for AlignValueVariant1Variant1 {
    fn from(value: &AlignValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`AlignValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AlignValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for AlignValueVariant1Variant2 {
    fn from(value: &AlignValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"start\","]
#[doc = "                              \"middle\","]
#[doc = "                              \"end\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValue {
    Variant0(::std::vec::Vec<AnchorValueVariant0Item>),
    Variant1(AnchorValueVariant1),
}
impl ::std::convert::From<&Self> for AnchorValue {
    fn from(value: &AnchorValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AnchorValueVariant0Item>> for AnchorValue {
    fn from(value: ::std::vec::Vec<AnchorValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValueVariant1> for AnchorValue {
    fn from(value: AnchorValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnchorValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant0Item {
    Variant0(AnchorValueVariant0ItemVariant0),
    Variant1(AnchorValueVariant0ItemVariant1),
    Variant2(AnchorValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AnchorValueVariant0Item {
    fn from(value: &AnchorValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AnchorValueVariant0ItemVariant0> for AnchorValueVariant0Item {
    fn from(value: AnchorValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValueVariant0ItemVariant1> for AnchorValueVariant0Item {
    fn from(value: AnchorValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AnchorValueVariant0ItemVariant2> for AnchorValueVariant0Item {
    fn from(value: AnchorValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AnchorValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: AnchorValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: AnchorValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AnchorValueVariant0ItemVariant0 {
    fn from(value: &AnchorValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AnchorValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for AnchorValueVariant0ItemVariant0Variant1Value {
    fn from(value: &AnchorValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AnchorValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for AnchorValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnchorValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AnchorValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AnchorValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AnchorValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AnchorValueVariant0ItemVariant0Variant3Range {
    fn from(value: &AnchorValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnchorValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnchorValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AnchorValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AnchorValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnchorValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AnchorValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AnchorValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnchorValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"start\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"end\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnchorValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for AnchorValueVariant0ItemVariant1 {
    fn from(value: &AnchorValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"start\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"end\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnchorValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for AnchorValueVariant0ItemVariant2 {
    fn from(value: &AnchorValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"start\","]
#[doc = "                    \"middle\","]
#[doc = "                    \"end\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant1 {
    Variant0(AnchorValueVariant1Variant0),
    Variant1(AnchorValueVariant1Variant1),
    Variant2(AnchorValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for AnchorValueVariant1 {
    fn from(value: &AnchorValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AnchorValueVariant1Variant0> for AnchorValueVariant1 {
    fn from(value: AnchorValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValueVariant1Variant1> for AnchorValueVariant1 {
    fn from(value: AnchorValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AnchorValueVariant1Variant2> for AnchorValueVariant1 {
    fn from(value: AnchorValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AnchorValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: AnchorValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: AnchorValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for AnchorValueVariant1Variant0 {
    fn from(value: &AnchorValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AnchorValueVariant1Variant0Variant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for AnchorValueVariant1Variant0Variant1Value {
    fn from(value: &AnchorValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AnchorValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for AnchorValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnchorValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnchorValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnchorValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AnchorValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnchorValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AnchorValueVariant1Variant0Variant3Range {
    fn from(value: &AnchorValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnchorValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnchorValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnchorValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnchorValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnchorValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AnchorValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AnchorValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnchorValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"start\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"end\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnchorValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for AnchorValueVariant1Variant1 {
    fn from(value: &AnchorValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`AnchorValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"start\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"end\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnchorValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for AnchorValueVariant1Variant2 {
    fn from(value: &AnchorValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {}"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValue {
    Variant0(::std::vec::Vec<AnyValueVariant0Item>),
    Variant1(AnyValueVariant1),
}
impl ::std::convert::From<&Self> for AnyValue {
    fn from(value: &AnyValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<AnyValueVariant0Item>> for AnyValue {
    fn from(value: ::std::vec::Vec<AnyValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnyValueVariant1> for AnyValue {
    fn from(value: AnyValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnyValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant0Item {
    Variant0(AnyValueVariant0ItemVariant0),
    Variant1(AnyValueVariant0ItemVariant1),
    Variant2(AnyValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AnyValueVariant0Item {
    fn from(value: &AnyValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AnyValueVariant0ItemVariant0> for AnyValueVariant0Item {
    fn from(value: AnyValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnyValueVariant0ItemVariant1> for AnyValueVariant0Item {
    fn from(value: AnyValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AnyValueVariant0ItemVariant2> for AnyValueVariant0Item {
    fn from(value: AnyValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AnyValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {}"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: ::serde_json::Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: AnyValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for AnyValueVariant0ItemVariant0 {
    fn from(value: &AnyValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AnyValueVariant0ItemVariant0Variant3Range {
    fn from(value: &AnyValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnyValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnyValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnyValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnyValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnyValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AnyValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AnyValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnyValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {}"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnyValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for AnyValueVariant0ItemVariant1 {
    fn from(value: &AnyValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {}"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnyValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for AnyValueVariant0ItemVariant2 {
    fn from(value: &AnyValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {}"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant1 {
    Variant0(AnyValueVariant1Variant0),
    Variant1(AnyValueVariant1Variant1),
    Variant2(AnyValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for AnyValueVariant1 {
    fn from(value: &AnyValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AnyValueVariant1Variant0> for AnyValueVariant1 {
    fn from(value: AnyValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnyValueVariant1Variant1> for AnyValueVariant1 {
    fn from(value: AnyValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<AnyValueVariant1Variant2> for AnyValueVariant1 {
    fn from(value: AnyValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AnyValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {}"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: ::serde_json::Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: AnyValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for AnyValueVariant1Variant0 {
    fn from(value: &AnyValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AnyValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for AnyValueVariant1Variant0Variant3Range {
    fn from(value: &AnyValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for AnyValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for AnyValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AnyValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AnyValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for AnyValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for AnyValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for AnyValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AnyValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {}"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnyValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for AnyValueVariant1Variant1 {
    fn from(value: &AnyValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`AnyValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {}"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum AnyValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for AnyValueVariant1Variant2 {
    fn from(value: &AnyValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayOrSignal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayOrSignal {
    Variant0(::std::vec::Vec<::serde_json::Value>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ArrayOrSignal {
    fn from(value: &ArrayOrSignal) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ArrayOrSignal {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ArrayOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ArrayValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"array\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"array\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValue {
    Variant0(::std::vec::Vec<ArrayValueVariant0Item>),
    Variant1(ArrayValueVariant1),
}
impl ::std::convert::From<&Self> for ArrayValue {
    fn from(value: &ArrayValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ArrayValueVariant0Item>> for ArrayValue {
    fn from(value: ::std::vec::Vec<ArrayValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValueVariant1> for ArrayValue {
    fn from(value: ArrayValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ArrayValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"array\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant0Item {
    Variant0(ArrayValueVariant0ItemVariant0),
    Variant1(ArrayValueVariant0ItemVariant1),
    Variant2(ArrayValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for ArrayValueVariant0Item {
    fn from(value: &ArrayValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ArrayValueVariant0ItemVariant0> for ArrayValueVariant0Item {
    fn from(value: ArrayValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValueVariant0ItemVariant1> for ArrayValueVariant0Item {
    fn from(value: ArrayValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<ArrayValueVariant0ItemVariant2> for ArrayValueVariant0Item {
    fn from(value: ArrayValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ArrayValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: ::std::vec::Vec<::serde_json::Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: ArrayValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for ArrayValueVariant0ItemVariant0 {
    fn from(value: &ArrayValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for ArrayValueVariant0ItemVariant0Variant3Range {
    fn from(value: &ArrayValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ArrayValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ArrayValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ArrayValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ArrayValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ArrayValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for ArrayValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for ArrayValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ArrayValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"array\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum ArrayValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for ArrayValueVariant0ItemVariant1 {
    fn from(value: &ArrayValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"array\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum ArrayValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for ArrayValueVariant0ItemVariant2 {
    fn from(value: &ArrayValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"array\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant1 {
    Variant0(ArrayValueVariant1Variant0),
    Variant1(ArrayValueVariant1Variant1),
    Variant2(ArrayValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for ArrayValueVariant1 {
    fn from(value: &ArrayValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ArrayValueVariant1Variant0> for ArrayValueVariant1 {
    fn from(value: ArrayValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValueVariant1Variant1> for ArrayValueVariant1 {
    fn from(value: ArrayValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<ArrayValueVariant1Variant2> for ArrayValueVariant1 {
    fn from(value: ArrayValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ArrayValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: ::std::vec::Vec<::serde_json::Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: ArrayValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for ArrayValueVariant1Variant0 {
    fn from(value: &ArrayValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ArrayValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for ArrayValueVariant1Variant0Variant3Range {
    fn from(value: &ArrayValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ArrayValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ArrayValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ArrayValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ArrayValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ArrayValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for ArrayValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for ArrayValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ArrayValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"array\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum ArrayValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for ArrayValueVariant1Variant1 {
    fn from(value: &ArrayValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`ArrayValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"array\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum ArrayValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for ArrayValueVariant1Variant2 {
    fn from(value: &ArrayValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`Autosize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"pad\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pad\","]
#[doc = "        \"fit\","]
#[doc = "        \"fit-x\","]
#[doc = "        \"fit-y\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"contains\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"content\","]
#[doc = "            \"padding\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"resize\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"default\": \"pad\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"pad\","]
#[doc = "            \"fit\","]
#[doc = "            \"fit-x\","]
#[doc = "            \"fit-y\","]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Autosize {
    Variant0(AutosizeVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        contains: ::std::option::Option<AutosizeVariant1Contains>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        resize: ::std::option::Option<bool>,
        #[serde(rename = "type")]
        type_: AutosizeVariant1Type,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for Autosize {
    fn from(value: &Autosize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AutosizeVariant0> for Autosize {
    fn from(value: AutosizeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Autosize {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AutosizeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pad\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pad\","]
#[doc = "    \"fit\","]
#[doc = "    \"fit-x\","]
#[doc = "    \"fit-y\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AutosizeVariant0 {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for AutosizeVariant0 {
    fn from(value: &AutosizeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AutosizeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pad => write!(f, "pad"),
            Self::Fit => write!(f, "fit"),
            Self::FitX => write!(f, "fit-x"),
            Self::FitY => write!(f, "fit-y"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for AutosizeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AutosizeVariant1Contains`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"content\","]
#[doc = "    \"padding\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AutosizeVariant1Contains {
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "padding")]
    Padding,
}
impl ::std::convert::From<&Self> for AutosizeVariant1Contains {
    fn from(value: &AutosizeVariant1Contains) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AutosizeVariant1Contains {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Content => write!(f, "content"),
            Self::Padding => write!(f, "padding"),
        }
    }
}
impl ::std::str::FromStr for AutosizeVariant1Contains {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "content" => Ok(Self::Content),
            "padding" => Ok(Self::Padding),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AutosizeVariant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pad\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pad\","]
#[doc = "    \"fit\","]
#[doc = "    \"fit-x\","]
#[doc = "    \"fit-y\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AutosizeVariant1Type {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for AutosizeVariant1Type {
    fn from(value: &AutosizeVariant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AutosizeVariant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pad => write!(f, "pad"),
            Self::Fit => write!(f, "fit"),
            Self::FitX => write!(f, "fit-x"),
            Self::FitY => write!(f, "fit-y"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for AutosizeVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::default::Default for AutosizeVariant1Type {
    fn default() -> Self {
        AutosizeVariant1Type::Pad
    }
}
#[doc = "`Axis`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"orient\","]
#[doc = "    \"scale\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"aria\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"bandPosition\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"domain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"domainCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"axis\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"grid\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"ticks\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"day\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"hours\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"milliseconds\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"minutes\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"month\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"quarter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"seconds\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"week\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"year\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"formatType\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"number\","]
#[doc = "            \"time\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"grid\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"gridCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridScale\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gridWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelAlign\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"left\","]
#[doc = "            \"right\","]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/alignValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelAngle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelBaseline\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"middle\","]
#[doc = "            \"bottom\","]
#[doc = "            \"alphabetic\","]
#[doc = "            \"line-top\","]
#[doc = "            \"line-bottom\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelBound\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFlush\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFlushOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"labelFont\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontStyle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontWeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"normal\","]
#[doc = "            \"bold\","]
#[doc = "            \"lighter\","]
#[doc = "            \"bolder\","]
#[doc = "            \"100\","]
#[doc = "            \"200\","]
#[doc = "            \"300\","]
#[doc = "            \"400\","]
#[doc = "            \"500\","]
#[doc = "            \"600\","]
#[doc = "            \"700\","]
#[doc = "            \"800\","]
#[doc = "            \"900\","]
#[doc = "            100,"]
#[doc = "            200,"]
#[doc = "            300,"]
#[doc = "            400,"]
#[doc = "            500,"]
#[doc = "            600,"]
#[doc = "            700,"]
#[doc = "            800,"]
#[doc = "            900"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelLimit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelLineHeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOverlap\": {"]
#[doc = "      \"$ref\": \"#/definitions/labelOverlap\""]
#[doc = "    },"]
#[doc = "    \"labelPadding\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelSeparation\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maxExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"bottom\","]
#[doc = "            \"left\","]
#[doc = "            \"right\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"position\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tickBand\": {"]
#[doc = "      \"$ref\": \"#/definitions/tickBand\""]
#[doc = "    },"]
#[doc = "    \"tickCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickCount\": {"]
#[doc = "      \"$ref\": \"#/definitions/tickCount\""]
#[doc = "    },"]
#[doc = "    \"tickDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickExtra\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"tickMinStep\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"tickOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickRound\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ticks\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "    },"]
#[doc = "    \"titleAlign\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"left\","]
#[doc = "            \"right\","]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/alignValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleAnchor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"start\","]
#[doc = "            \"middle\","]
#[doc = "            \"end\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleAngle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleBaseline\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"middle\","]
#[doc = "            \"bottom\","]
#[doc = "            \"alphabetic\","]
#[doc = "            \"line-top\","]
#[doc = "            \"line-bottom\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFont\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontStyle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontWeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"normal\","]
#[doc = "            \"bold\","]
#[doc = "            \"lighter\","]
#[doc = "            \"bolder\","]
#[doc = "            \"100\","]
#[doc = "            \"200\","]
#[doc = "            \"300\","]
#[doc = "            \"400\","]
#[doc = "            \"500\","]
#[doc = "            \"600\","]
#[doc = "            \"700\","]
#[doc = "            \"800\","]
#[doc = "            \"900\","]
#[doc = "            100,"]
#[doc = "            200,"]
#[doc = "            300,"]
#[doc = "            400,"]
#[doc = "            500,"]
#[doc = "            600,"]
#[doc = "            700,"]
#[doc = "            800,"]
#[doc = "            900"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleLimit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleLineHeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titlePadding\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleX\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleY\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/arrayOrSignal\""]
#[doc = "    },"]
#[doc = "    \"zindex\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Axis {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aria: ::std::option::Option<bool>,
    #[serde(
        rename = "bandPosition",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub band_position: ::std::option::Option<AxisBandPosition>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub domain: ::std::option::Option<bool>,
    #[serde(
        rename = "domainCap",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_cap: ::std::option::Option<AxisDomainCap>,
    #[serde(
        rename = "domainColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_color: ::std::option::Option<AxisDomainColor>,
    #[serde(
        rename = "domainDash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_dash: ::std::option::Option<AxisDomainDash>,
    #[serde(
        rename = "domainDashOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_dash_offset: ::std::option::Option<AxisDomainDashOffset>,
    #[serde(
        rename = "domainOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_opacity: ::std::option::Option<AxisDomainOpacity>,
    #[serde(
        rename = "domainWidth",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub domain_width: ::std::option::Option<AxisDomainWidth>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<AxisEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub format: ::std::option::Option<AxisFormat>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub format_type: ::std::option::Option<AxisFormatType>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub grid: ::std::option::Option<bool>,
    #[serde(
        rename = "gridCap",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_cap: ::std::option::Option<AxisGridCap>,
    #[serde(
        rename = "gridColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_color: ::std::option::Option<AxisGridColor>,
    #[serde(
        rename = "gridDash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_dash: ::std::option::Option<AxisGridDash>,
    #[serde(
        rename = "gridDashOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_dash_offset: ::std::option::Option<AxisGridDashOffset>,
    #[serde(
        rename = "gridOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_opacity: ::std::option::Option<AxisGridOpacity>,
    #[serde(
        rename = "gridScale",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_scale: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "gridWidth",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub grid_width: ::std::option::Option<AxisGridWidth>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_align: ::std::option::Option<AxisLabelAlign>,
    #[serde(
        rename = "labelAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_angle: ::std::option::Option<AxisLabelAngle>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_baseline: ::std::option::Option<AxisLabelBaseline>,
    #[serde(
        rename = "labelBound",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_bound: ::std::option::Option<AxisLabelBound>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_color: ::std::option::Option<AxisLabelColor>,
    #[serde(
        rename = "labelFlush",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_flush: ::std::option::Option<AxisLabelFlush>,
    #[serde(
        rename = "labelFlushOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_flush_offset: ::std::option::Option<NumberOrSignal>,
    #[serde(
        rename = "labelFont",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_font: ::std::option::Option<AxisLabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_font_size: ::std::option::Option<AxisLabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_font_style: ::std::option::Option<AxisLabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_font_weight: ::std::option::Option<AxisLabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_limit: ::std::option::Option<AxisLabelLimit>,
    #[serde(
        rename = "labelLineHeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_line_height: ::std::option::Option<AxisLabelLineHeight>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_offset: ::std::option::Option<AxisLabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_opacity: ::std::option::Option<AxisLabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_overlap: ::std::option::Option<LabelOverlap>,
    #[serde(
        rename = "labelPadding",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_padding: ::std::option::Option<AxisLabelPadding>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub label_separation: ::std::option::Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<bool>,
    #[serde(
        rename = "maxExtent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub max_extent: ::std::option::Option<AxisMaxExtent>,
    #[serde(
        rename = "minExtent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub min_extent: ::std::option::Option<AxisMinExtent>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<AxisOffset>,
    pub orient: AxisOrient,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub position: ::std::option::Option<AxisPosition>,
    pub scale: ::std::string::String,
    #[serde(
        rename = "tickBand",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_band: ::std::option::Option<TickBand>,
    #[serde(
        rename = "tickCap",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_cap: ::std::option::Option<AxisTickCap>,
    #[serde(
        rename = "tickColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_color: ::std::option::Option<AxisTickColor>,
    #[serde(
        rename = "tickCount",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_count: ::std::option::Option<TickCount>,
    #[serde(
        rename = "tickDash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_dash: ::std::option::Option<AxisTickDash>,
    #[serde(
        rename = "tickDashOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_dash_offset: ::std::option::Option<AxisTickDashOffset>,
    #[serde(
        rename = "tickExtra",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_extra: ::std::option::Option<BooleanOrSignal>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_min_step: ::std::option::Option<NumberOrSignal>,
    #[serde(
        rename = "tickOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_offset: ::std::option::Option<AxisTickOffset>,
    #[serde(
        rename = "tickOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_opacity: ::std::option::Option<AxisTickOpacity>,
    #[serde(
        rename = "tickRound",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_round: ::std::option::Option<AxisTickRound>,
    #[serde(
        rename = "tickSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_size: ::std::option::Option<AxisTickSize>,
    #[serde(
        rename = "tickWidth",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub tick_width: ::std::option::Option<AxisTickWidth>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ticks: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_align: ::std::option::Option<AxisTitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_anchor: ::std::option::Option<AxisTitleAnchor>,
    #[serde(
        rename = "titleAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_angle: ::std::option::Option<AxisTitleAngle>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_baseline: ::std::option::Option<AxisTitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_color: ::std::option::Option<AxisTitleColor>,
    #[serde(
        rename = "titleFont",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_font: ::std::option::Option<AxisTitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_font_size: ::std::option::Option<AxisTitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_font_style: ::std::option::Option<AxisTitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_font_weight: ::std::option::Option<AxisTitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_limit: ::std::option::Option<AxisTitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_line_height: ::std::option::Option<AxisTitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_opacity: ::std::option::Option<AxisTitleOpacity>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_padding: ::std::option::Option<AxisTitlePadding>,
    #[serde(
        rename = "titleX",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_x: ::std::option::Option<AxisTitleX>,
    #[serde(
        rename = "titleY",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub title_y: ::std::option::Option<AxisTitleY>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub translate: ::std::option::Option<AxisTranslate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub values: ::std::option::Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub zindex: ::std::option::Option<f64>,
}
impl ::std::convert::From<&Axis> for Axis {
    fn from(value: &Axis) -> Self {
        value.clone()
    }
}
#[doc = "`AxisBandPosition`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisBandPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisBandPosition {
    fn from(value: &AxisBandPosition) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisBandPosition {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisBandPosition {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisDomainCap`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainCap {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisDomainCap {
    fn from(value: &AxisDomainCap) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisDomainCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisDomainColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for AxisDomainColor {
    fn from(value: &AxisDomainColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for AxisDomainColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisDomainDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for AxisDomainDash {
    fn from(value: &AxisDomainDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for AxisDomainDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for AxisDomainDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisDomainDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisDomainDashOffset {
    fn from(value: &AxisDomainDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisDomainDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisDomainDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisDomainOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisDomainOpacity {
    fn from(value: &AxisDomainOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisDomainOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisDomainOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisDomainWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisDomainWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisDomainWidth {
    fn from(value: &AxisDomainWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisDomainWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisDomainWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisEncode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"axis\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"domain\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"grid\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"ticks\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct AxisEncode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub axis: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub domain: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub grid: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ticks: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&AxisEncode> for AxisEncode {
    fn from(value: &AxisEncode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for AxisEncode {
    fn default() -> Self {
        Self {
            axis: Default::default(),
            domain: Default::default(),
            grid: Default::default(),
            labels: Default::default(),
            ticks: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`AxisFormat`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum AxisFormat {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for AxisFormat {
    fn from(value: &AxisFormat) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for AxisFormat {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisFormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisFormatType {
    Variant0(AxisFormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AxisFormatType {
    fn from(value: &AxisFormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisFormatTypeVariant0> for AxisFormatType {
    fn from(value: AxisFormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AxisFormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisFormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisFormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for AxisFormatTypeVariant0 {
    fn from(value: &AxisFormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisFormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for AxisFormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisGridCap`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridCap {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisGridCap {
    fn from(value: &AxisGridCap) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisGridCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisGridColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for AxisGridColor {
    fn from(value: &AxisGridColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for AxisGridColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisGridDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for AxisGridDash {
    fn from(value: &AxisGridDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for AxisGridDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for AxisGridDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisGridDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisGridDashOffset {
    fn from(value: &AxisGridDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisGridDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisGridDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisGridOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisGridOpacity {
    fn from(value: &AxisGridOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisGridOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisGridOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisGridWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisGridWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisGridWidth {
    fn from(value: &AxisGridWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisGridWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisGridWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelAlign {
    Variant0(AxisLabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for AxisLabelAlign {
    fn from(value: &AxisLabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisLabelAlignVariant0> for AxisLabelAlign {
    fn from(value: AxisLabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for AxisLabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisLabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for AxisLabelAlignVariant0 {
    fn from(value: &AxisLabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisLabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for AxisLabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisLabelAngle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelAngle {
    fn from(value: &AxisLabelAngle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelAngle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelBaseline {
    Variant0(AxisLabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for AxisLabelBaseline {
    fn from(value: &AxisLabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisLabelBaselineVariant0> for AxisLabelBaseline {
    fn from(value: AxisLabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for AxisLabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisLabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for AxisLabelBaselineVariant0 {
    fn from(value: &AxisLabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisLabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for AxisLabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisLabelBound`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelBound {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for AxisLabelBound {
    fn from(value: &AxisLabelBound) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for AxisLabelBound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for AxisLabelBound {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for AxisLabelBound {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisLabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for AxisLabelColor {
    fn from(value: &AxisLabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for AxisLabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisLabelFlush`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelFlush {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for AxisLabelFlush {
    fn from(value: &AxisLabelFlush) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for AxisLabelFlush {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for AxisLabelFlush {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for AxisLabelFlush {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisLabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisLabelFont {
    fn from(value: &AxisLabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisLabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelFontSize {
    fn from(value: &AxisLabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisLabelFontStyle {
    fn from(value: &AxisLabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisLabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for AxisLabelFontWeight {
    fn from(value: &AxisLabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for AxisLabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for AxisLabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelLimit {
    fn from(value: &AxisLabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelLineHeight {
    fn from(value: &AxisLabelLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelOffset {
    fn from(value: &AxisLabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelOpacity {
    fn from(value: &AxisLabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisLabelPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisLabelPadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisLabelPadding {
    fn from(value: &AxisLabelPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisLabelPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisLabelPadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisMaxExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisMaxExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisMaxExtent {
    fn from(value: &AxisMaxExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisMaxExtent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisMaxExtent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisMinExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisMinExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisMinExtent {
    fn from(value: &AxisMinExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisMinExtent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisMinExtent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisOffset {
    fn from(value: &AxisOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"left\","]
#[doc = "        \"right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisOrient {
    Variant0(AxisOrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for AxisOrient {
    fn from(value: &AxisOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisOrientVariant0> for AxisOrient {
    fn from(value: AxisOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for AxisOrient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"left\","]
#[doc = "    \"right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisOrientVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
}
impl ::std::convert::From<&Self> for AxisOrientVariant0 {
    fn from(value: &AxisOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
        }
    }
}
impl ::std::str::FromStr for AxisOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisPosition`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisPosition {
    fn from(value: &AxisPosition) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisPosition {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisPosition {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickCap`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickCap {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisTickCap {
    fn from(value: &AxisTickCap) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisTickCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for AxisTickColor {
    fn from(value: &AxisTickColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for AxisTickColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisTickDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for AxisTickDash {
    fn from(value: &AxisTickDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for AxisTickDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for AxisTickDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTickDashOffset {
    fn from(value: &AxisTickDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTickDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTickDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTickOffset {
    fn from(value: &AxisTickOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTickOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTickOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTickOpacity {
    fn from(value: &AxisTickOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTickOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTickOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickRound`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickRound {
    Variant0(bool),
    Variant1(BooleanValue),
}
impl ::std::convert::From<&Self> for AxisTickRound {
    fn from(value: &AxisTickRound) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for AxisTickRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BooleanValue> for AxisTickRound {
    fn from(value: BooleanValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTickSize {
    fn from(value: &AxisTickSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTickSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTickSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTickWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTickWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTickWidth {
    fn from(value: &AxisTickWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTickWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTickWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleAlign {
    Variant0(AxisTitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for AxisTitleAlign {
    fn from(value: &AxisTitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisTitleAlignVariant0> for AxisTitleAlign {
    fn from(value: AxisTitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for AxisTitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisTitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for AxisTitleAlignVariant0 {
    fn from(value: &AxisTitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisTitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for AxisTitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisTitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleAnchor {
    Variant0(::std::option::Option<AxisTitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for AxisTitleAnchor {
    fn from(value: &AxisTitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<AxisTitleAnchorVariant0>> for AxisTitleAnchor {
    fn from(value: ::std::option::Option<AxisTitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for AxisTitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisTitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for AxisTitleAnchorVariant0 {
    fn from(value: &AxisTitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisTitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for AxisTitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisTitleAngle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleAngle {
    fn from(value: &AxisTitleAngle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleAngle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleBaseline {
    Variant0(AxisTitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for AxisTitleBaseline {
    fn from(value: &AxisTitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AxisTitleBaselineVariant0> for AxisTitleBaseline {
    fn from(value: AxisTitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for AxisTitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AxisTitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for AxisTitleBaselineVariant0 {
    fn from(value: &AxisTitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AxisTitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for AxisTitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AxisTitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for AxisTitleColor {
    fn from(value: &AxisTitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for AxisTitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`AxisTitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisTitleFont {
    fn from(value: &AxisTitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisTitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleFontSize {
    fn from(value: &AxisTitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for AxisTitleFontStyle {
    fn from(value: &AxisTitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for AxisTitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for AxisTitleFontWeight {
    fn from(value: &AxisTitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for AxisTitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for AxisTitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleLimit {
    fn from(value: &AxisTitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleLineHeight {
    fn from(value: &AxisTitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleOpacity {
    fn from(value: &AxisTitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitlePadding {
    fn from(value: &AxisTitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleX {
    fn from(value: &AxisTitleX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTitleY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTitleY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTitleY {
    fn from(value: &AxisTitleY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTitleY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTitleY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`AxisTranslate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum AxisTranslate {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for AxisTranslate {
    fn from(value: &AxisTranslate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for AxisTranslate {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for AxisTranslate {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Background`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Background(pub StringOrSignal);
impl ::std::ops::Deref for Background {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl ::std::convert::From<Background> for StringOrSignal {
    fn from(value: Background) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Background> for Background {
    fn from(value: &Background) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringOrSignal> for Background {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[doc = "`BaseColorValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"null\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/linearGradient\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/radialGradient\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"gradient\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"gradient\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"start\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        \"stop\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"color\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"color\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum BaseColorValue {
    Variant0(BaseColorValueVariant0),
    Variant1 {
        value: LinearGradient,
    },
    Variant2 {
        value: RadialGradient,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<f64>,
        gradient: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        start: ::std::option::Option<[f64; 2usize]>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        stop: ::std::option::Option<[f64; 2usize]>,
    },
    Variant4 {
        color: BaseColorValueVariant4Color,
    },
}
impl ::std::convert::From<&Self> for BaseColorValue {
    fn from(value: &BaseColorValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BaseColorValueVariant0> for BaseColorValue {
    fn from(value: BaseColorValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`BaseColorValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"null\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaseColorValueVariant0 {
    Variant0(BaseColorValueVariant0Variant0),
    Variant1(BaseColorValueVariant0Variant1),
    Variant2(BaseColorValueVariant0Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for BaseColorValueVariant0 {
    fn from(value: &BaseColorValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BaseColorValueVariant0Variant0> for BaseColorValueVariant0 {
    fn from(value: BaseColorValueVariant0Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaseColorValueVariant0Variant1> for BaseColorValueVariant0 {
    fn from(value: BaseColorValueVariant0Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BaseColorValueVariant0Variant2> for BaseColorValueVariant0 {
    fn from(value: BaseColorValueVariant0Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BaseColorValueVariant0Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: ::std::option::Option<::std::string::String>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: BaseColorValueVariant0Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for BaseColorValueVariant0Variant0 {
    fn from(value: &BaseColorValueVariant0Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`BaseColorValueVariant0Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BaseColorValueVariant0Variant0Variant3Range {
    fn from(value: &BaseColorValueVariant0Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BaseColorValueVariant0Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BaseColorValueVariant0Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BaseColorValueVariant0Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BaseColorValueVariant0Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BaseColorValueVariant0Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BaseColorValueVariant0Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BaseColorValueVariant0Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BaseColorValueVariant0Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaseColorValueVariant0Variant1 {}
impl ::std::convert::From<&Self> for BaseColorValueVariant0Variant1 {
    fn from(value: &BaseColorValueVariant0Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`BaseColorValueVariant0Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaseColorValueVariant0Variant2 {}
impl ::std::convert::From<&Self> for BaseColorValueVariant0Variant2 {
    fn from(value: &BaseColorValueVariant0Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`BaseColorValueVariant4Color`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaseColorValueVariant4Color {
    Rgb(ColorRgb),
    Hsl(ColorHsl),
    Lab(ColorLab),
    Hcl(ColorHcl),
}
impl ::std::convert::From<&Self> for BaseColorValueVariant4Color {
    fn from(value: &BaseColorValueVariant4Color) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorRgb> for BaseColorValueVariant4Color {
    fn from(value: ColorRgb) -> Self {
        Self::Rgb(value)
    }
}
impl ::std::convert::From<ColorHsl> for BaseColorValueVariant4Color {
    fn from(value: ColorHsl) -> Self {
        Self::Hsl(value)
    }
}
impl ::std::convert::From<ColorLab> for BaseColorValueVariant4Color {
    fn from(value: ColorLab) -> Self {
        Self::Lab(value)
    }
}
impl ::std::convert::From<ColorHcl> for BaseColorValueVariant4Color {
    fn from(value: ColorHcl) -> Self {
        Self::Hcl(value)
    }
}
#[doc = "`BaselineValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"top\","]
#[doc = "                              \"middle\","]
#[doc = "                              \"bottom\","]
#[doc = "                              \"alphabetic\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"top\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"bottom\","]
#[doc = "                        \"alphabetic\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValue {
    Variant0(::std::vec::Vec<BaselineValueVariant0Item>),
    Variant1(BaselineValueVariant1),
}
impl ::std::convert::From<&Self> for BaselineValue {
    fn from(value: &BaselineValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<BaselineValueVariant0Item>> for BaselineValue {
    fn from(value: ::std::vec::Vec<BaselineValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValueVariant1> for BaselineValue {
    fn from(value: BaselineValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BaselineValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"top\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"bottom\","]
#[doc = "                        \"alphabetic\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant0Item {
    Variant0(BaselineValueVariant0ItemVariant0),
    Variant1(BaselineValueVariant0ItemVariant1),
    Variant2(BaselineValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BaselineValueVariant0Item {
    fn from(value: &BaselineValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BaselineValueVariant0ItemVariant0> for BaselineValueVariant0Item {
    fn from(value: BaselineValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValueVariant0ItemVariant1> for BaselineValueVariant0Item {
    fn from(value: BaselineValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BaselineValueVariant0ItemVariant2> for BaselineValueVariant0Item {
    fn from(value: BaselineValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BaselineValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: BaselineValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: BaselineValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BaselineValueVariant0ItemVariant0 {
    fn from(value: &BaselineValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`BaselineValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BaselineValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl ::std::convert::From<&Self> for BaselineValueVariant0ItemVariant0Variant1Value {
    fn from(value: &BaselineValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BaselineValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
        }
    }
}
impl ::std::str::FromStr for BaselineValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BaselineValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BaselineValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BaselineValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BaselineValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BaselineValueVariant0ItemVariant0Variant3Range {
    fn from(value: &BaselineValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BaselineValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BaselineValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BaselineValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BaselineValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BaselineValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BaselineValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BaselineValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BaselineValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"top\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"bottom\","]
#[doc = "                  \"alphabetic\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaselineValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for BaselineValueVariant0ItemVariant1 {
    fn from(value: &BaselineValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`BaselineValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"top\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"bottom\","]
#[doc = "                  \"alphabetic\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaselineValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for BaselineValueVariant0ItemVariant2 {
    fn from(value: &BaselineValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`BaselineValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"top\","]
#[doc = "                    \"middle\","]
#[doc = "                    \"bottom\","]
#[doc = "                    \"alphabetic\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant1 {
    Variant0(BaselineValueVariant1Variant0),
    Variant1(BaselineValueVariant1Variant1),
    Variant2(BaselineValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for BaselineValueVariant1 {
    fn from(value: &BaselineValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BaselineValueVariant1Variant0> for BaselineValueVariant1 {
    fn from(value: BaselineValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValueVariant1Variant1> for BaselineValueVariant1 {
    fn from(value: BaselineValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BaselineValueVariant1Variant2> for BaselineValueVariant1 {
    fn from(value: BaselineValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BaselineValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: BaselineValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: BaselineValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for BaselineValueVariant1Variant0 {
    fn from(value: &BaselineValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`BaselineValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BaselineValueVariant1Variant0Variant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl ::std::convert::From<&Self> for BaselineValueVariant1Variant0Variant1Value {
    fn from(value: &BaselineValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BaselineValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
        }
    }
}
impl ::std::str::FromStr for BaselineValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BaselineValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BaselineValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BaselineValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BaselineValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BaselineValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BaselineValueVariant1Variant0Variant3Range {
    fn from(value: &BaselineValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BaselineValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BaselineValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BaselineValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BaselineValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BaselineValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BaselineValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BaselineValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BaselineValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"top\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"bottom\","]
#[doc = "                  \"alphabetic\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaselineValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for BaselineValueVariant1Variant1 {
    fn from(value: &BaselineValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`BaselineValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"top\","]
#[doc = "                  \"middle\","]
#[doc = "                  \"bottom\","]
#[doc = "                  \"alphabetic\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BaselineValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for BaselineValueVariant1Variant2 {
    fn from(value: &BaselineValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`BinTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extent\","]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"anchor\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"bin0\","]
#[doc = "        \"bin1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"default\": 10,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"divide\": {"]
#[doc = "      \"default\": ["]
#[doc = "        5,"]
#[doc = "        2"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"interval\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxbins\": {"]
#[doc = "      \"default\": 20,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minstep\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"span\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"bin\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct BinTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub anchor: ::std::option::Option<BinTransformAnchor>,
    #[serde(rename = "as", default = "defaults::bin_transform_as")]
    pub as_: BinTransformAs,
    #[serde(default = "defaults::bin_transform_base")]
    pub base: BinTransformBase,
    #[serde(default = "defaults::bin_transform_divide")]
    pub divide: BinTransformDivide,
    pub extent: BinTransformExtent,
    pub field: BinTransformField,
    #[serde(default = "defaults::bin_transform_interval")]
    pub interval: BinTransformInterval,
    #[serde(default = "defaults::bin_transform_maxbins")]
    pub maxbins: BinTransformMaxbins,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub minstep: ::std::option::Option<BinTransformMinstep>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<BinTransformName>,
    #[serde(default = "defaults::bin_transform_nice")]
    pub nice: BinTransformNice,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub span: ::std::option::Option<BinTransformSpan>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub step: ::std::option::Option<BinTransformStep>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub steps: ::std::option::Option<BinTransformSteps>,
    #[serde(rename = "type")]
    pub type_: BinTransformType,
}
impl ::std::convert::From<&BinTransform> for BinTransform {
    fn from(value: &BinTransform) -> Self {
        value.clone()
    }
}
#[doc = "`BinTransformAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformAnchor {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformAnchor {
    fn from(value: &BinTransformAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformAnchor {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"bin0\","]
#[doc = "    \"bin1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformAs {
    Variant0([BinTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformAs {
    fn from(value: &BinTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformAs {
    fn default() -> Self {
        BinTransformAs::Variant0([
            BinTransformAsVariant0Item::Variant0("bin0".to_string()),
            BinTransformAsVariant0Item::Variant0("bin1".to_string()),
        ])
    }
}
impl ::std::convert::From<[BinTransformAsVariant0Item; 2usize]> for BinTransformAs {
    fn from(value: [BinTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformAsVariant0Item {
    fn from(value: &BinTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for BinTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformBase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 10,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformBase {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformBase {
    fn from(value: &BinTransformBase) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformBase {
    fn default() -> Self {
        BinTransformBase::Variant0(10_f64)
    }
}
impl ::std::convert::From<f64> for BinTransformBase {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformBase {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformDivide`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    5,"]
#[doc = "    2"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformDivide {
    Variant0(::std::vec::Vec<BinTransformDivideVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformDivide {
    fn from(value: &BinTransformDivide) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformDivide {
    fn default() -> Self {
        BinTransformDivide::Variant0(vec![
            BinTransformDivideVariant0Item::Variant0(5_f64),
            BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<BinTransformDivideVariant0Item>> for BinTransformDivide {
    fn from(value: ::std::vec::Vec<BinTransformDivideVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformDivide {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformDivideVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformDivideVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformDivideVariant0Item {
    fn from(value: &BinTransformDivideVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformDivideVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformDivideVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformExtent {
    Variant0([BinTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformExtent {
    fn from(value: &BinTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[BinTransformExtentVariant0Item; 2usize]> for BinTransformExtent {
    fn from(value: [BinTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformExtentVariant0Item {
    fn from(value: &BinTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for BinTransformField {
    fn from(value: &BinTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for BinTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for BinTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for BinTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`BinTransformInterval`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformInterval {
    fn from(value: &BinTransformInterval) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformInterval {
    fn default() -> Self {
        BinTransformInterval::Variant0(true)
    }
}
impl ::std::convert::From<bool> for BinTransformInterval {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformInterval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformMaxbins`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 20,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformMaxbins {
    fn from(value: &BinTransformMaxbins) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformMaxbins {
    fn default() -> Self {
        BinTransformMaxbins::Variant0(20_f64)
    }
}
impl ::std::convert::From<f64> for BinTransformMaxbins {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformMaxbins {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformMinstep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformMinstep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformMinstep {
    fn from(value: &BinTransformMinstep) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformMinstep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformMinstep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformName {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformName {
    fn from(value: &BinTransformName) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for BinTransformName {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformNice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformNice {
    fn from(value: &BinTransformNice) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for BinTransformNice {
    fn default() -> Self {
        BinTransformNice::Variant0(true)
    }
}
impl ::std::convert::From<bool> for BinTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformSpan`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformSpan {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformSpan {
    fn from(value: &BinTransformSpan) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformSpan {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformSpan {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformStep {
    fn from(value: &BinTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformSteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformSteps {
    Variant0(::std::vec::Vec<BinTransformStepsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformSteps {
    fn from(value: &BinTransformSteps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<BinTransformStepsVariant0Item>> for BinTransformSteps {
    fn from(value: ::std::vec::Vec<BinTransformStepsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformStepsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BinTransformStepsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BinTransformStepsVariant0Item {
    fn from(value: &BinTransformStepsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for BinTransformStepsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BinTransformStepsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BinTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"bin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BinTransformType {
    #[serde(rename = "bin")]
    Bin,
}
impl ::std::convert::From<&Self> for BinTransformType {
    fn from(value: &BinTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BinTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Bin => write!(f, "bin"),
        }
    }
}
impl ::std::str::FromStr for BinTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "bin" => Ok(Self::Bin),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Bind`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"checkbox\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\","]
#[doc = "        \"options\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"radio\","]
#[doc = "            \"select\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"options\": {"]
#[doc = "          \"type\": \"array\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"range\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"max\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"min\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"not\": {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"checkbox\","]
#[doc = "              \"radio\","]
#[doc = "              \"range\","]
#[doc = "              \"select\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"element\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Bind {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        element: ::std::option::Option<Element>,
        input: BindVariant0Input,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        name: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        element: ::std::option::Option<Element>,
        input: BindVariant1Input,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        labels: ::std::vec::Vec<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        name: ::std::option::Option<::std::string::String>,
        options: ::std::vec::Vec<::serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        element: ::std::option::Option<Element>,
        input: BindVariant2Input,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        max: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        min: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        step: ::std::option::Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        element: ::std::option::Option<Element>,
        input: BindVariant3Input,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        name: ::std::option::Option<::std::string::String>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        element: Element,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        event: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for Bind {
    fn from(value: &Bind) -> Self {
        value.clone()
    }
}
#[doc = "`BindVariant0Input`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"checkbox\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BindVariant0Input {
    #[serde(rename = "checkbox")]
    Checkbox,
}
impl ::std::convert::From<&Self> for BindVariant0Input {
    fn from(value: &BindVariant0Input) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BindVariant0Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Checkbox => write!(f, "checkbox"),
        }
    }
}
impl ::std::str::FromStr for BindVariant0Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "checkbox" => Ok(Self::Checkbox),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BindVariant1Input`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"radio\","]
#[doc = "    \"select\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BindVariant1Input {
    #[serde(rename = "radio")]
    Radio,
    #[serde(rename = "select")]
    Select,
}
impl ::std::convert::From<&Self> for BindVariant1Input {
    fn from(value: &BindVariant1Input) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BindVariant1Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Radio => write!(f, "radio"),
            Self::Select => write!(f, "select"),
        }
    }
}
impl ::std::str::FromStr for BindVariant1Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "radio" => Ok(Self::Radio),
            "select" => Ok(Self::Select),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BindVariant2Input`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"range\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BindVariant2Input {
    #[serde(rename = "range")]
    Range,
}
impl ::std::convert::From<&Self> for BindVariant2Input {
    fn from(value: &BindVariant2Input) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BindVariant2Input {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Range => write!(f, "range"),
        }
    }
}
impl ::std::str::FromStr for BindVariant2Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "range" => Ok(Self::Range),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BindVariant3Input`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"not\": {"]
#[doc = "    \"enum\": ["]
#[doc = "      \"checkbox\","]
#[doc = "      \"radio\","]
#[doc = "      \"range\","]
#[doc = "      \"select\""]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct BindVariant3Input(::std::string::String);
impl ::std::ops::Deref for BindVariant3Input {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<BindVariant3Input> for ::std::string::String {
    fn from(value: BindVariant3Input) -> Self {
        value.0
    }
}
impl ::std::convert::From<&BindVariant3Input> for BindVariant3Input {
    fn from(value: &BindVariant3Input) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BindVariant3Input {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        if [
            "checkbox".to_string(),
            "radio".to_string(),
            "range".to_string(),
            "select".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for BindVariant3Input {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<::std::string::String>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`BlendValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              null,"]
#[doc = "                              \"multiply\","]
#[doc = "                              \"screen\","]
#[doc = "                              \"overlay\","]
#[doc = "                              \"darken\","]
#[doc = "                              \"lighten\","]
#[doc = "                              \"color-dodge\","]
#[doc = "                              \"color-burn\","]
#[doc = "                              \"hard-light\","]
#[doc = "                              \"soft-light\","]
#[doc = "                              \"difference\","]
#[doc = "                              \"exclusion\","]
#[doc = "                              \"hue\","]
#[doc = "                              \"saturation\","]
#[doc = "                              \"color\","]
#[doc = "                              \"luminosity\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"multiply\","]
#[doc = "                        \"screen\","]
#[doc = "                        \"overlay\","]
#[doc = "                        \"darken\","]
#[doc = "                        \"lighten\","]
#[doc = "                        \"color-dodge\","]
#[doc = "                        \"color-burn\","]
#[doc = "                        \"hard-light\","]
#[doc = "                        \"soft-light\","]
#[doc = "                        \"difference\","]
#[doc = "                        \"exclusion\","]
#[doc = "                        \"hue\","]
#[doc = "                        \"saturation\","]
#[doc = "                        \"color\","]
#[doc = "                        \"luminosity\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValue {
    Variant0(::std::vec::Vec<BlendValueVariant0Item>),
    Variant1(BlendValueVariant1),
}
impl ::std::convert::From<&Self> for BlendValue {
    fn from(value: &BlendValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<BlendValueVariant0Item>> for BlendValue {
    fn from(value: ::std::vec::Vec<BlendValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BlendValueVariant1> for BlendValue {
    fn from(value: BlendValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BlendValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"multiply\","]
#[doc = "                        \"screen\","]
#[doc = "                        \"overlay\","]
#[doc = "                        \"darken\","]
#[doc = "                        \"lighten\","]
#[doc = "                        \"color-dodge\","]
#[doc = "                        \"color-burn\","]
#[doc = "                        \"hard-light\","]
#[doc = "                        \"soft-light\","]
#[doc = "                        \"difference\","]
#[doc = "                        \"exclusion\","]
#[doc = "                        \"hue\","]
#[doc = "                        \"saturation\","]
#[doc = "                        \"color\","]
#[doc = "                        \"luminosity\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant0Item {
    Variant0(BlendValueVariant0ItemVariant0),
    Variant1(BlendValueVariant0ItemVariant1),
    Variant2(BlendValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BlendValueVariant0Item {
    fn from(value: &BlendValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlendValueVariant0ItemVariant0> for BlendValueVariant0Item {
    fn from(value: BlendValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BlendValueVariant0ItemVariant1> for BlendValueVariant0Item {
    fn from(value: BlendValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BlendValueVariant0ItemVariant2> for BlendValueVariant0Item {
    fn from(value: BlendValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BlendValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"multiply\","]
#[doc = "                \"screen\","]
#[doc = "                \"overlay\","]
#[doc = "                \"darken\","]
#[doc = "                \"lighten\","]
#[doc = "                \"color-dodge\","]
#[doc = "                \"color-burn\","]
#[doc = "                \"hard-light\","]
#[doc = "                \"soft-light\","]
#[doc = "                \"difference\","]
#[doc = "                \"exclusion\","]
#[doc = "                \"hue\","]
#[doc = "                \"saturation\","]
#[doc = "                \"color\","]
#[doc = "                \"luminosity\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: ::std::option::Option<BlendValueVariant0ItemVariant0Variant1Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: BlendValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BlendValueVariant0ItemVariant0 {
    fn from(value: &BlendValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`BlendValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"multiply\","]
#[doc = "    \"screen\","]
#[doc = "    \"overlay\","]
#[doc = "    \"darken\","]
#[doc = "    \"lighten\","]
#[doc = "    \"color-dodge\","]
#[doc = "    \"color-burn\","]
#[doc = "    \"hard-light\","]
#[doc = "    \"soft-light\","]
#[doc = "    \"difference\","]
#[doc = "    \"exclusion\","]
#[doc = "    \"hue\","]
#[doc = "    \"saturation\","]
#[doc = "    \"color\","]
#[doc = "    \"luminosity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlendValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl ::std::convert::From<&Self> for BlendValueVariant0ItemVariant0Variant1Value {
    fn from(value: &BlendValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlendValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Multiply => write!(f, "multiply"),
            Self::Screen => write!(f, "screen"),
            Self::Overlay => write!(f, "overlay"),
            Self::Darken => write!(f, "darken"),
            Self::Lighten => write!(f, "lighten"),
            Self::ColorDodge => write!(f, "color-dodge"),
            Self::ColorBurn => write!(f, "color-burn"),
            Self::HardLight => write!(f, "hard-light"),
            Self::SoftLight => write!(f, "soft-light"),
            Self::Difference => write!(f, "difference"),
            Self::Exclusion => write!(f, "exclusion"),
            Self::Hue => write!(f, "hue"),
            Self::Saturation => write!(f, "saturation"),
            Self::Color => write!(f, "color"),
            Self::Luminosity => write!(f, "luminosity"),
        }
    }
}
impl ::std::str::FromStr for BlendValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlendValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BlendValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BlendValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BlendValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BlendValueVariant0ItemVariant0Variant3Range {
    fn from(value: &BlendValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BlendValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlendValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BlendValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BlendValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BlendValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BlendValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BlendValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BlendValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"multiply\","]
#[doc = "                  \"screen\","]
#[doc = "                  \"overlay\","]
#[doc = "                  \"darken\","]
#[doc = "                  \"lighten\","]
#[doc = "                  \"color-dodge\","]
#[doc = "                  \"color-burn\","]
#[doc = "                  \"hard-light\","]
#[doc = "                  \"soft-light\","]
#[doc = "                  \"difference\","]
#[doc = "                  \"exclusion\","]
#[doc = "                  \"hue\","]
#[doc = "                  \"saturation\","]
#[doc = "                  \"color\","]
#[doc = "                  \"luminosity\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BlendValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for BlendValueVariant0ItemVariant1 {
    fn from(value: &BlendValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`BlendValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"multiply\","]
#[doc = "                  \"screen\","]
#[doc = "                  \"overlay\","]
#[doc = "                  \"darken\","]
#[doc = "                  \"lighten\","]
#[doc = "                  \"color-dodge\","]
#[doc = "                  \"color-burn\","]
#[doc = "                  \"hard-light\","]
#[doc = "                  \"soft-light\","]
#[doc = "                  \"difference\","]
#[doc = "                  \"exclusion\","]
#[doc = "                  \"hue\","]
#[doc = "                  \"saturation\","]
#[doc = "                  \"color\","]
#[doc = "                  \"luminosity\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BlendValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for BlendValueVariant0ItemVariant2 {
    fn from(value: &BlendValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`BlendValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    null,"]
#[doc = "                    \"multiply\","]
#[doc = "                    \"screen\","]
#[doc = "                    \"overlay\","]
#[doc = "                    \"darken\","]
#[doc = "                    \"lighten\","]
#[doc = "                    \"color-dodge\","]
#[doc = "                    \"color-burn\","]
#[doc = "                    \"hard-light\","]
#[doc = "                    \"soft-light\","]
#[doc = "                    \"difference\","]
#[doc = "                    \"exclusion\","]
#[doc = "                    \"hue\","]
#[doc = "                    \"saturation\","]
#[doc = "                    \"color\","]
#[doc = "                    \"luminosity\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant1 {
    Variant0(BlendValueVariant1Variant0),
    Variant1(BlendValueVariant1Variant1),
    Variant2(BlendValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for BlendValueVariant1 {
    fn from(value: &BlendValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlendValueVariant1Variant0> for BlendValueVariant1 {
    fn from(value: BlendValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BlendValueVariant1Variant1> for BlendValueVariant1 {
    fn from(value: BlendValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BlendValueVariant1Variant2> for BlendValueVariant1 {
    fn from(value: BlendValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BlendValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"multiply\","]
#[doc = "                \"screen\","]
#[doc = "                \"overlay\","]
#[doc = "                \"darken\","]
#[doc = "                \"lighten\","]
#[doc = "                \"color-dodge\","]
#[doc = "                \"color-burn\","]
#[doc = "                \"hard-light\","]
#[doc = "                \"soft-light\","]
#[doc = "                \"difference\","]
#[doc = "                \"exclusion\","]
#[doc = "                \"hue\","]
#[doc = "                \"saturation\","]
#[doc = "                \"color\","]
#[doc = "                \"luminosity\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: ::std::option::Option<BlendValueVariant1Variant0Variant1Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: BlendValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for BlendValueVariant1Variant0 {
    fn from(value: &BlendValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`BlendValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"multiply\","]
#[doc = "    \"screen\","]
#[doc = "    \"overlay\","]
#[doc = "    \"darken\","]
#[doc = "    \"lighten\","]
#[doc = "    \"color-dodge\","]
#[doc = "    \"color-burn\","]
#[doc = "    \"hard-light\","]
#[doc = "    \"soft-light\","]
#[doc = "    \"difference\","]
#[doc = "    \"exclusion\","]
#[doc = "    \"hue\","]
#[doc = "    \"saturation\","]
#[doc = "    \"color\","]
#[doc = "    \"luminosity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum BlendValueVariant1Variant0Variant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl ::std::convert::From<&Self> for BlendValueVariant1Variant0Variant1Value {
    fn from(value: &BlendValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for BlendValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Multiply => write!(f, "multiply"),
            Self::Screen => write!(f, "screen"),
            Self::Overlay => write!(f, "overlay"),
            Self::Darken => write!(f, "darken"),
            Self::Lighten => write!(f, "lighten"),
            Self::ColorDodge => write!(f, "color-dodge"),
            Self::ColorBurn => write!(f, "color-burn"),
            Self::HardLight => write!(f, "hard-light"),
            Self::SoftLight => write!(f, "soft-light"),
            Self::Difference => write!(f, "difference"),
            Self::Exclusion => write!(f, "exclusion"),
            Self::Hue => write!(f, "hue"),
            Self::Saturation => write!(f, "saturation"),
            Self::Color => write!(f, "color"),
            Self::Luminosity => write!(f, "luminosity"),
        }
    }
}
impl ::std::str::FromStr for BlendValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlendValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlendValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlendValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BlendValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlendValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BlendValueVariant1Variant0Variant3Range {
    fn from(value: &BlendValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BlendValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlendValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlendValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlendValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BlendValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BlendValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BlendValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BlendValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"multiply\","]
#[doc = "                  \"screen\","]
#[doc = "                  \"overlay\","]
#[doc = "                  \"darken\","]
#[doc = "                  \"lighten\","]
#[doc = "                  \"color-dodge\","]
#[doc = "                  \"color-burn\","]
#[doc = "                  \"hard-light\","]
#[doc = "                  \"soft-light\","]
#[doc = "                  \"difference\","]
#[doc = "                  \"exclusion\","]
#[doc = "                  \"hue\","]
#[doc = "                  \"saturation\","]
#[doc = "                  \"color\","]
#[doc = "                  \"luminosity\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BlendValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for BlendValueVariant1Variant1 {
    fn from(value: &BlendValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`BlendValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"multiply\","]
#[doc = "                  \"screen\","]
#[doc = "                  \"overlay\","]
#[doc = "                  \"darken\","]
#[doc = "                  \"lighten\","]
#[doc = "                  \"color-dodge\","]
#[doc = "                  \"color-burn\","]
#[doc = "                  \"hard-light\","]
#[doc = "                  \"soft-light\","]
#[doc = "                  \"difference\","]
#[doc = "                  \"exclusion\","]
#[doc = "                  \"hue\","]
#[doc = "                  \"saturation\","]
#[doc = "                  \"color\","]
#[doc = "                  \"luminosity\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BlendValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for BlendValueVariant1Variant2 {
    fn from(value: &BlendValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanOrSignal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanOrSignal {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for BooleanOrSignal {
    fn from(value: &BooleanOrSignal) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for BooleanOrSignal {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for BooleanOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BooleanValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"boolean\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValue {
    Variant0(::std::vec::Vec<BooleanValueVariant0Item>),
    Variant1(BooleanValueVariant1),
}
impl ::std::convert::From<&Self> for BooleanValue {
    fn from(value: &BooleanValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<BooleanValueVariant0Item>> for BooleanValue {
    fn from(value: ::std::vec::Vec<BooleanValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BooleanValueVariant1> for BooleanValue {
    fn from(value: BooleanValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BooleanValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant0Item {
    Variant0(BooleanValueVariant0ItemVariant0),
    Variant1(BooleanValueVariant0ItemVariant1),
    Variant2(BooleanValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BooleanValueVariant0Item {
    fn from(value: &BooleanValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BooleanValueVariant0ItemVariant0> for BooleanValueVariant0Item {
    fn from(value: BooleanValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BooleanValueVariant0ItemVariant1> for BooleanValueVariant0Item {
    fn from(value: BooleanValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BooleanValueVariant0ItemVariant2> for BooleanValueVariant0Item {
    fn from(value: BooleanValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BooleanValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: bool,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: BooleanValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for BooleanValueVariant0ItemVariant0 {
    fn from(value: &BooleanValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BooleanValueVariant0ItemVariant0Variant3Range {
    fn from(value: &BooleanValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BooleanValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BooleanValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for BooleanValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for BooleanValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BooleanValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BooleanValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BooleanValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BooleanValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"boolean\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BooleanValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for BooleanValueVariant0ItemVariant1 {
    fn from(value: &BooleanValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"boolean\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BooleanValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for BooleanValueVariant0ItemVariant2 {
    fn from(value: &BooleanValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant1 {
    Variant0(BooleanValueVariant1Variant0),
    Variant1(BooleanValueVariant1Variant1),
    Variant2(BooleanValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for BooleanValueVariant1 {
    fn from(value: &BooleanValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BooleanValueVariant1Variant0> for BooleanValueVariant1 {
    fn from(value: BooleanValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BooleanValueVariant1Variant1> for BooleanValueVariant1 {
    fn from(value: BooleanValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<BooleanValueVariant1Variant2> for BooleanValueVariant1 {
    fn from(value: BooleanValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`BooleanValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: bool,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: BooleanValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for BooleanValueVariant1Variant0 {
    fn from(value: &BooleanValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BooleanValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for BooleanValueVariant1Variant0Variant3Range {
    fn from(value: &BooleanValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BooleanValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BooleanValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BooleanValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BooleanValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BooleanValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for BooleanValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for BooleanValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`BooleanValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"boolean\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BooleanValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for BooleanValueVariant1Variant1 {
    fn from(value: &BooleanValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`BooleanValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"boolean\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum BooleanValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for BooleanValueVariant1Variant2 {
    fn from(value: &BooleanValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`CollectTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"collect\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CollectTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: CollectTransformType,
}
impl ::std::convert::From<&CollectTransform> for CollectTransform {
    fn from(value: &CollectTransform) -> Self {
        value.clone()
    }
}
#[doc = "`CollectTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"collect\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CollectTransformType {
    #[serde(rename = "collect")]
    Collect,
}
impl ::std::convert::From<&Self> for CollectTransformType {
    fn from(value: &CollectTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CollectTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Collect => write!(f, "collect"),
        }
    }
}
impl ::std::str::FromStr for CollectTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "collect" => Ok(Self::Collect),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ColorHcl`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"c\","]
#[doc = "    \"h\","]
#[doc = "    \"l\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"c\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"h\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ColorHcl {
    pub c: NumberValue,
    pub h: NumberValue,
    pub l: NumberValue,
}
impl ::std::convert::From<&ColorHcl> for ColorHcl {
    fn from(value: &ColorHcl) -> Self {
        value.clone()
    }
}
#[doc = "`ColorHsl`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"h\","]
#[doc = "    \"l\","]
#[doc = "    \"s\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"h\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"s\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ColorHsl {
    pub h: NumberValue,
    pub l: NumberValue,
    pub s: NumberValue,
}
impl ::std::convert::From<&ColorHsl> for ColorHsl {
    fn from(value: &ColorHsl) -> Self {
        value.clone()
    }
}
#[doc = "`ColorLab`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"a\","]
#[doc = "    \"b\","]
#[doc = "    \"l\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"a\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"b\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ColorLab {
    pub a: NumberValue,
    pub b: NumberValue,
    pub l: NumberValue,
}
impl ::std::convert::From<&ColorLab> for ColorLab {
    fn from(value: &ColorLab) -> Self {
        value.clone()
    }
}
#[doc = "`ColorRgb`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"b\","]
#[doc = "    \"g\","]
#[doc = "    \"r\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"b\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"g\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"r\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ColorRgb {
    pub b: NumberValue,
    pub g: NumberValue,
    pub r: NumberValue,
}
impl ::std::convert::From<&ColorRgb> for ColorRgb {
    fn from(value: &ColorRgb) -> Self {
        value.clone()
    }
}
#[doc = "`Compare`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Compare {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        field: ::std::option::Option<CompareVariant0Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        field: ::std::vec::Vec<CompareVariant1FieldItem>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        order: ::std::vec::Vec<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for Compare {
    fn from(value: &Compare) -> Self {
        value.clone()
    }
}
#[doc = "`CompareVariant0Field`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CompareVariant0Field {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for CompareVariant0Field {
    fn from(value: &CompareVariant0Field) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for CompareVariant0Field {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<Expr> for CompareVariant0Field {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`CompareVariant1FieldItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CompareVariant1FieldItem {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for CompareVariant1FieldItem {
    fn from(value: &CompareVariant1FieldItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for CompareVariant1FieldItem {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<Expr> for CompareVariant1FieldItem {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ContourTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cellSize\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"count\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"thresholds\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"contour\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"weight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ContourTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bandwidth: ::std::option::Option<ContourTransformBandwidth>,
    #[serde(
        rename = "cellSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cell_size: ::std::option::Option<ContourTransformCellSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<ContourTransformCount>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub nice: ::std::option::Option<ContourTransformNice>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    pub size: ContourTransformSize,
    #[serde(default = "defaults::contour_transform_smooth")]
    pub smooth: ContourTransformSmooth,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub thresholds: ::std::option::Option<ContourTransformThresholds>,
    #[serde(rename = "type")]
    pub type_: ContourTransformType,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub values: ::std::option::Option<ContourTransformValues>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub weight: ::std::option::Option<ContourTransformWeight>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x: ::std::option::Option<ContourTransformX>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y: ::std::option::Option<ContourTransformY>,
}
impl ::std::convert::From<&ContourTransform> for ContourTransform {
    fn from(value: &ContourTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ContourTransformBandwidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformBandwidth {
    fn from(value: &ContourTransformBandwidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformCellSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformCellSize {
    fn from(value: &ContourTransformCellSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformCellSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformCellSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformCount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformCount {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformCount {
    fn from(value: &ContourTransformCount) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformCount {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformCount {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformNice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformNice {
    fn from(value: &ContourTransformNice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ContourTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformSize {
    Variant0([ContourTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformSize {
    fn from(value: &ContourTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[ContourTransformSizeVariant0Item; 2usize]> for ContourTransformSize {
    fn from(value: [ContourTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformSizeVariant0Item {
    fn from(value: &ContourTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformSmooth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformSmooth {
    fn from(value: &ContourTransformSmooth) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ContourTransformSmooth {
    fn default() -> Self {
        ContourTransformSmooth::Variant0(true)
    }
}
impl ::std::convert::From<bool> for ContourTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformThresholds`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformThresholds {
    Variant0(::std::vec::Vec<ContourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformThresholds {
    fn from(value: &ContourTransformThresholds) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ContourTransformThresholdsVariant0Item>>
    for ContourTransformThresholds
{
    fn from(value: ::std::vec::Vec<ContourTransformThresholdsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformThresholds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformThresholdsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformThresholdsVariant0Item {
    fn from(value: &ContourTransformThresholdsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformThresholdsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformThresholdsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"contour\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContourTransformType {
    #[serde(rename = "contour")]
    Contour,
}
impl ::std::convert::From<&Self> for ContourTransformType {
    fn from(value: &ContourTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContourTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Contour => write!(f, "contour"),
        }
    }
}
impl ::std::str::FromStr for ContourTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contour" => Ok(Self::Contour),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContourTransformValues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformValues {
    Variant0(::std::vec::Vec<ContourTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformValues {
    fn from(value: &ContourTransformValues) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ContourTransformValuesVariant0Item>>
    for ContourTransformValues
{
    fn from(value: ::std::vec::Vec<ContourTransformValuesVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformValues {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformValuesVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformValuesVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ContourTransformValuesVariant0Item {
    fn from(value: &ContourTransformValuesVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ContourTransformValuesVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ContourTransformValuesVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ContourTransformWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ContourTransformWeight {
    fn from(value: &ContourTransformWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ContourTransformWeight {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ContourTransformWeight {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ContourTransformWeight {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ContourTransformX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ContourTransformX {
    fn from(value: &ContourTransformX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ContourTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ContourTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ContourTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ContourTransformY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ContourTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ContourTransformY {
    fn from(value: &ContourTransformY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ContourTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ContourTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ContourTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`CountpatternTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"text\","]
#[doc = "        \"count\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"case\": {"]
#[doc = "      \"default\": \"mixed\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"upper\","]
#[doc = "            \"lower\","]
#[doc = "            \"mixed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pattern\": {"]
#[doc = "      \"default\": \"[\\\\w\\\"]+\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stopwords\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"countpattern\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CountpatternTransform {
    #[serde(rename = "as", default = "defaults::countpattern_transform_as")]
    pub as_: CountpatternTransformAs,
    #[serde(default = "defaults::countpattern_transform_case")]
    pub case: CountpatternTransformCase,
    pub field: CountpatternTransformField,
    #[serde(default = "defaults::countpattern_transform_pattern")]
    pub pattern: CountpatternTransformPattern,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stopwords: ::std::option::Option<CountpatternTransformStopwords>,
    #[serde(rename = "type")]
    pub type_: CountpatternTransformType,
}
impl ::std::convert::From<&CountpatternTransform> for CountpatternTransform {
    fn from(value: &CountpatternTransform) -> Self {
        value.clone()
    }
}
#[doc = "`CountpatternTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"text\","]
#[doc = "    \"count\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformAs {
    Variant0([CountpatternTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CountpatternTransformAs {
    fn from(value: &CountpatternTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CountpatternTransformAs {
    fn default() -> Self {
        CountpatternTransformAs::Variant0([
            CountpatternTransformAsVariant0Item::Variant0("text".to_string()),
            CountpatternTransformAsVariant0Item::Variant0("count".to_string()),
        ])
    }
}
impl ::std::convert::From<[CountpatternTransformAsVariant0Item; 2usize]>
    for CountpatternTransformAs
{
    fn from(value: [CountpatternTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for CountpatternTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CountpatternTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CountpatternTransformAsVariant0Item {
    fn from(value: &CountpatternTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for CountpatternTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CountpatternTransformCase`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"mixed\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"upper\","]
#[doc = "        \"lower\","]
#[doc = "        \"mixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformCase {
    Variant0(CountpatternTransformCaseVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CountpatternTransformCase {
    fn from(value: &CountpatternTransformCase) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CountpatternTransformCase {
    fn default() -> Self {
        CountpatternTransformCase::Variant0(CountpatternTransformCaseVariant0::Mixed)
    }
}
impl ::std::convert::From<CountpatternTransformCaseVariant0> for CountpatternTransformCase {
    fn from(value: CountpatternTransformCaseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for CountpatternTransformCase {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CountpatternTransformCaseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"upper\","]
#[doc = "    \"lower\","]
#[doc = "    \"mixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CountpatternTransformCaseVariant0 {
    #[serde(rename = "upper")]
    Upper,
    #[serde(rename = "lower")]
    Lower,
    #[serde(rename = "mixed")]
    Mixed,
}
impl ::std::convert::From<&Self> for CountpatternTransformCaseVariant0 {
    fn from(value: &CountpatternTransformCaseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CountpatternTransformCaseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Upper => write!(f, "upper"),
            Self::Lower => write!(f, "lower"),
            Self::Mixed => write!(f, "mixed"),
        }
    }
}
impl ::std::str::FromStr for CountpatternTransformCaseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "upper" => Ok(Self::Upper),
            "lower" => Ok(Self::Lower),
            "mixed" => Ok(Self::Mixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CountpatternTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for CountpatternTransformField {
    fn from(value: &CountpatternTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for CountpatternTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for CountpatternTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for CountpatternTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`CountpatternTransformPattern`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"[\\\\w\\\"]+\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformPattern {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CountpatternTransformPattern {
    fn from(value: &CountpatternTransformPattern) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CountpatternTransformPattern {
    fn default() -> Self {
        CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
}
impl ::std::convert::From<SignalRef> for CountpatternTransformPattern {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CountpatternTransformStopwords`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CountpatternTransformStopwords {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CountpatternTransformStopwords {
    fn from(value: &CountpatternTransformStopwords) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for CountpatternTransformStopwords {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CountpatternTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"countpattern\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CountpatternTransformType {
    #[serde(rename = "countpattern")]
    Countpattern,
}
impl ::std::convert::From<&Self> for CountpatternTransformType {
    fn from(value: &CountpatternTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CountpatternTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Countpattern => write!(f, "countpattern"),
        }
    }
}
impl ::std::str::FromStr for CountpatternTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "countpattern" => Ok(Self::Countpattern),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CrossTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"a\","]
#[doc = "        \"b\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"filter\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"cross\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CrossTransform {
    #[serde(rename = "as", default = "defaults::cross_transform_as")]
    pub as_: CrossTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub filter: ::std::option::Option<ExprString>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: CrossTransformType,
}
impl ::std::convert::From<&CrossTransform> for CrossTransform {
    fn from(value: &CrossTransform) -> Self {
        value.clone()
    }
}
#[doc = "`CrossTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"a\","]
#[doc = "    \"b\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CrossTransformAs {
    Variant0([CrossTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CrossTransformAs {
    fn from(value: &CrossTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CrossTransformAs {
    fn default() -> Self {
        CrossTransformAs::Variant0([
            CrossTransformAsVariant0Item::Variant0("a".to_string()),
            CrossTransformAsVariant0Item::Variant0("b".to_string()),
        ])
    }
}
impl ::std::convert::From<[CrossTransformAsVariant0Item; 2usize]> for CrossTransformAs {
    fn from(value: [CrossTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for CrossTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CrossTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CrossTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CrossTransformAsVariant0Item {
    fn from(value: &CrossTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for CrossTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CrossTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"cross\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CrossTransformType {
    #[serde(rename = "cross")]
    Cross,
}
impl ::std::convert::From<&Self> for CrossTransformType {
    fn from(value: &CrossTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CrossTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Cross => write!(f, "cross"),
        }
    }
}
impl ::std::str::FromStr for CrossTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "cross" => Ok(Self::Cross),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CrossfilterTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"query\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"query\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"crossfilter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CrossfilterTransform {
    pub fields: CrossfilterTransformFields,
    pub query: CrossfilterTransformQuery,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: CrossfilterTransformType,
}
impl ::std::convert::From<&CrossfilterTransform> for CrossfilterTransform {
    fn from(value: &CrossfilterTransform) -> Self {
        value.clone()
    }
}
#[doc = "`CrossfilterTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CrossfilterTransformFields {
    Variant0(::std::vec::Vec<CrossfilterTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CrossfilterTransformFields {
    fn from(value: &CrossfilterTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<CrossfilterTransformFieldsVariant0Item>>
    for CrossfilterTransformFields
{
    fn from(value: ::std::vec::Vec<CrossfilterTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for CrossfilterTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CrossfilterTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CrossfilterTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: &CrossfilterTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`CrossfilterTransformQuery`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CrossfilterTransformQuery {
    Variant0(::std::vec::Vec<::serde_json::Value>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for CrossfilterTransformQuery {
    fn from(value: &CrossfilterTransformQuery) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for CrossfilterTransformQuery {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for CrossfilterTransformQuery {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`CrossfilterTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"crossfilter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CrossfilterTransformType {
    #[serde(rename = "crossfilter")]
    Crossfilter,
}
impl ::std::convert::From<&Self> for CrossfilterTransformType {
    fn from(value: &CrossfilterTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CrossfilterTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Crossfilter => write!(f, "crossfilter"),
        }
    }
}
impl ::std::str::FromStr for CrossfilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "crossfilter" => Ok(Self::Crossfilter),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Data`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"source\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"source\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"async\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"copy\": {"]
#[doc = "                      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"property\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"json\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"csv\","]
#[doc = "                        \"tsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"delimiter\","]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"delimiter\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"dsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"feature\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"feature\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"mesh\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"filter\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"interior\","]
#[doc = "                            \"exterior\","]
#[doc = "                            null"]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        \"mesh\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"values\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"async\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"copy\": {"]
#[doc = "                      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"property\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"json\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"csv\","]
#[doc = "                        \"tsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"delimiter\","]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"delimiter\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"dsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"feature\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"feature\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"mesh\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"filter\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"interior\","]
#[doc = "                            \"exterior\","]
#[doc = "                            null"]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        \"mesh\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"values\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {},"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Data {
    Variant0 {
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        transform: ::std::vec::Vec<Transform>,
    },
    Variant1 {
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnTrigger>,
        source: DataVariant1Source,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        transform: ::std::vec::Vec<Transform>,
    },
    Variant2 {
        #[serde(
            rename = "async",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        async_: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<DataVariant2Format>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        transform: ::std::vec::Vec<Transform>,
        url: StringOrSignal,
    },
    Variant3 {
        #[serde(
            rename = "async",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        async_: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<DataVariant3Format>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        transform: ::std::vec::Vec<Transform>,
        values: DataVariant3Values,
    },
}
impl ::std::convert::From<&Self> for Data {
    fn from(value: &Data) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant1Source`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant1Source {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for DataVariant1Source {
    fn from(value: &DataVariant1Source) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for DataVariant1Source {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"copy\": {"]
#[doc = "              \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"property\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"csv\","]
#[doc = "                \"tsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delimiter\","]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delimiter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"dsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"feature\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"feature\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"mesh\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"filter\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"interior\","]
#[doc = "                    \"exterior\","]
#[doc = "                    null"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"mesh\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2Format {
    Variant0 {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_0: ::std::option::Option<DataVariant2FormatVariant0Subtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_1: ::std::option::Option<DataVariant2FormatVariant0Subtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_2: ::std::option::Option<DataVariant2FormatVariant0Subtype2>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_3: ::std::option::Option<DataVariant2FormatVariant0Subtype3>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_4: ::std::option::Option<DataVariant2FormatVariant0Subtype4>,
    },
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant2Format {
    fn from(value: &DataVariant2Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for DataVariant2Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataVariant2FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant2FormatVariant0Subtype0Parse>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<StringOrSignal>,
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype0>
    for DataVariant2FormatVariant0Subtype0
{
    fn from(value: &DataVariant2FormatVariant0Subtype0) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DataVariant2FormatVariant0Subtype0 {
    fn default() -> Self {
        Self {
            parse: Default::default(),
            type_: Default::default(),
        }
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0Parse {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype0ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype0Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype0Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype0ParseVariant0>
    for DataVariant2FormatVariant0Subtype0Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype0ParseVariant1Value,
        >,
    > for DataVariant2FormatVariant0Subtype0Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype0ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant2FormatVariant0Subtype0Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"copy\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"property\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub copy: ::std::option::Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant2FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub property: ::std::option::Option<StringOrSignal>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<DataVariant2FormatVariant0Subtype1Type>,
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype1>
    for DataVariant2FormatVariant0Subtype1
{
    fn from(value: &DataVariant2FormatVariant0Subtype1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DataVariant2FormatVariant0Subtype1 {
    fn default() -> Self {
        Self {
            copy: Default::default(),
            parse: Default::default(),
            property: Default::default(),
            type_: Default::default(),
        }
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1Parse {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype1ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype1Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype1Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype1ParseVariant0>
    for DataVariant2FormatVariant0Subtype1Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype1ParseVariant1Value,
        >,
    > for DataVariant2FormatVariant0Subtype1Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype1ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant2FormatVariant0Subtype1Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype1Type {
    fn from(value: &DataVariant2FormatVariant0Subtype1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Json => write!(f, "json"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"csv\","]
#[doc = "        \"tsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub header: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant2FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype2Type,
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype2>
    for DataVariant2FormatVariant0Subtype2
{
    fn from(value: &DataVariant2FormatVariant0Subtype2) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2Parse {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype2ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype2Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype2Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype2ParseVariant0>
    for DataVariant2FormatVariant0Subtype2Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype2ParseVariant1Value,
        >,
    > for DataVariant2FormatVariant0Subtype2Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype2ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant2FormatVariant0Subtype2Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype2Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"csv\","]
#[doc = "    \"tsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype2Type {
    fn from(value: &DataVariant2FormatVariant0Subtype2Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype2Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Csv => write!(f, "csv"),
            Self::Tsv => write!(f, "tsv"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delimiter\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delimiter\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype3 {
    pub delimiter: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub header: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant2FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype3Type,
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype3>
    for DataVariant2FormatVariant0Subtype3
{
    fn from(value: &DataVariant2FormatVariant0Subtype3) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3Parse {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype3ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype3Parse {
    fn from(value: &DataVariant2FormatVariant0Subtype3Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype3ParseVariant0>
    for DataVariant2FormatVariant0Subtype3Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype3ParseVariant1Value,
        >,
    > for DataVariant2FormatVariant0Subtype3Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant2FormatVariant0Subtype3ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant2FormatVariant0Subtype3Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype3Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype3Type {
    fn from(value: &DataVariant2FormatVariant0Subtype3Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype3Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dsv => write!(f, "dsv"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype4`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"feature\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"feature\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"mesh\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"filter\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"interior\","]
#[doc = "            \"exterior\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mesh\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        property: ::std::option::Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        filter: ::std::option::Option<DataVariant2FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        property: ::std::option::Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant1Type,
    },
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype4 {
    fn from(value: &DataVariant2FormatVariant0Subtype4) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype4Variant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Topojson => write!(f, "topojson"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype4Variant1Filter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"interior\","]
#[doc = "    \"exterior\","]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant1Filter) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Interior => write!(f, "interior"),
            Self::Exterior => write!(f, "exterior"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant1Filter
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant1Filter
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant2FormatVariant0Subtype4Variant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl ::std::convert::From<&Self> for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn from(value: &DataVariant2FormatVariant0Subtype4Variant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Topojson => write!(f, "topojson"),
        }
    }
}
impl ::std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant2FormatVariant0Subtype4Variant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"copy\": {"]
#[doc = "              \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"property\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"csv\","]
#[doc = "                \"tsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delimiter\","]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delimiter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"dsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"feature\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"feature\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"mesh\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"filter\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"interior\","]
#[doc = "                    \"exterior\","]
#[doc = "                    null"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"mesh\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3Format {
    Variant0 {
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_0: ::std::option::Option<DataVariant3FormatVariant0Subtype0>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_1: ::std::option::Option<DataVariant3FormatVariant0Subtype1>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_2: ::std::option::Option<DataVariant3FormatVariant0Subtype2>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_3: ::std::option::Option<DataVariant3FormatVariant0Subtype3>,
        #[serde(
            flatten,
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtype_4: ::std::option::Option<DataVariant3FormatVariant0Subtype4>,
    },
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3Format {
    fn from(value: &DataVariant3Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataVariant3FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant3FormatVariant0Subtype0Parse>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<StringOrSignal>,
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype0>
    for DataVariant3FormatVariant0Subtype0
{
    fn from(value: &DataVariant3FormatVariant0Subtype0) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DataVariant3FormatVariant0Subtype0 {
    fn default() -> Self {
        Self {
            parse: Default::default(),
            type_: Default::default(),
        }
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0Parse {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype0ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype0Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype0Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype0ParseVariant0>
    for DataVariant3FormatVariant0Subtype0Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype0ParseVariant1Value,
        >,
    > for DataVariant3FormatVariant0Subtype0Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype0ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3FormatVariant0Subtype0Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"copy\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"property\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub copy: ::std::option::Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant3FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub property: ::std::option::Option<StringOrSignal>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<DataVariant3FormatVariant0Subtype1Type>,
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype1>
    for DataVariant3FormatVariant0Subtype1
{
    fn from(value: &DataVariant3FormatVariant0Subtype1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DataVariant3FormatVariant0Subtype1 {
    fn default() -> Self {
        Self {
            copy: Default::default(),
            parse: Default::default(),
            property: Default::default(),
            type_: Default::default(),
        }
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1Parse {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype1ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype1Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype1Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype1ParseVariant0>
    for DataVariant3FormatVariant0Subtype1Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype1ParseVariant1Value,
        >,
    > for DataVariant3FormatVariant0Subtype1Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype1ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3FormatVariant0Subtype1Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype1Type {
    fn from(value: &DataVariant3FormatVariant0Subtype1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Json => write!(f, "json"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"csv\","]
#[doc = "        \"tsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub header: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant3FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype2Type,
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype2>
    for DataVariant3FormatVariant0Subtype2
{
    fn from(value: &DataVariant3FormatVariant0Subtype2) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2Parse {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype2ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype2Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype2Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype2ParseVariant0>
    for DataVariant3FormatVariant0Subtype2Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype2ParseVariant1Value,
        >,
    > for DataVariant3FormatVariant0Subtype2Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype2ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3FormatVariant0Subtype2Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype2Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"csv\","]
#[doc = "    \"tsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype2Type {
    fn from(value: &DataVariant3FormatVariant0Subtype2Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype2Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Csv => write!(f, "csv"),
            Self::Tsv => write!(f, "tsv"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delimiter\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delimiter\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype3 {
    pub delimiter: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub header: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parse: ::std::option::Option<DataVariant3FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype3Type,
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype3>
    for DataVariant3FormatVariant0Subtype3
{
    fn from(value: &DataVariant3FormatVariant0Subtype3) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3Parse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3Parse {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant0),
    Variant1(
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype3ParseVariant1Value,
        >,
    ),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype3Parse {
    fn from(value: &DataVariant3FormatVariant0Subtype3Parse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype3ParseVariant0>
    for DataVariant3FormatVariant0Subtype3Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl
    ::std::convert::From<
        ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype3ParseVariant1Value,
        >,
    > for DataVariant3FormatVariant0Subtype3Parse
{
    fn from(
        value: ::std::collections::HashMap<
            ::std::string::String,
            DataVariant3FormatVariant0Subtype3ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3FormatVariant0Subtype3Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3ParseVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Auto => write!(f, "auto"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3ParseVariant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1),
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1Value) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Boolean => write!(f, "boolean"),
            Self::Number => write!(f, "number"),
            Self::Date => write!(f, "date"),
            Self::String => write!(f, "string"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1(::std::string::String);
impl ::std::ops::Deref for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for ::std::string::String
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    fn from(value: &DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^(date|utc):.*$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype3Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype3Type {
    fn from(value: &DataVariant3FormatVariant0Subtype3Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype3Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dsv => write!(f, "dsv"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype4`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"feature\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"feature\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"mesh\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"filter\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"interior\","]
#[doc = "            \"exterior\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mesh\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        property: ::std::option::Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        filter: ::std::option::Option<DataVariant3FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        property: ::std::option::Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant1Type,
    },
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype4 {
    fn from(value: &DataVariant3FormatVariant0Subtype4) -> Self {
        value.clone()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype4Variant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Topojson => write!(f, "topojson"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype4Variant1Filter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"interior\","]
#[doc = "    \"exterior\","]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant1Filter) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Interior => write!(f, "interior"),
            Self::Exterior => write!(f, "exterior"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant1Filter
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant1Filter
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3FormatVariant0Subtype4Variant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl ::std::convert::From<&Self> for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn from(value: &DataVariant3FormatVariant0Subtype4Variant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Topojson => write!(f, "topojson"),
        }
    }
}
impl ::std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DataVariant3FormatVariant0Subtype4Variant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataVariant3Values`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {},"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DataVariant3Values {
    Variant0(::serde_json::Value),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DataVariant3Values {
    fn from(value: &DataVariant3Values) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Value> for DataVariant3Values {
    fn from(value: ::serde_json::Value) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DataVariant3Values {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"value\","]
#[doc = "        \"density\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"distribution\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"normal\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"mean\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"stdev\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"lognormal\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"mean\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"stdev\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"uniform\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"max\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"min\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\","]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"bandwidth\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/paramField\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/expr\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"kde\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"distributions\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {}"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"mixture\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"weights\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"anyOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"type\": \"number\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxsteps\": {"]
#[doc = "      \"default\": 200,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"pdf\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minsteps\": {"]
#[doc = "      \"default\": 25,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"density\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DensityTransform {
    #[serde(rename = "as", default = "defaults::density_transform_as")]
    pub as_: DensityTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub distribution: ::std::option::Option<DensityTransformDistribution>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<DensityTransformExtent>,
    #[serde(default = "defaults::density_transform_maxsteps")]
    pub maxsteps: DensityTransformMaxsteps,
    #[serde(default = "defaults::density_transform_method")]
    pub method: DensityTransformMethod,
    #[serde(default = "defaults::density_transform_minsteps")]
    pub minsteps: DensityTransformMinsteps,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub steps: ::std::option::Option<DensityTransformSteps>,
    #[serde(rename = "type")]
    pub type_: DensityTransformType,
}
impl ::std::convert::From<&DensityTransform> for DensityTransform {
    fn from(value: &DensityTransform) -> Self {
        value.clone()
    }
}
#[doc = "`DensityTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"value\","]
#[doc = "    \"density\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformAs {
    Variant0(::std::vec::Vec<DensityTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformAs {
    fn from(value: &DensityTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformAs {
    fn default() -> Self {
        DensityTransformAs::Variant0(vec![
            DensityTransformAsVariant0Item::Variant0("value".to_string()),
            DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<DensityTransformAsVariant0Item>> for DensityTransformAs {
    fn from(value: ::std::vec::Vec<DensityTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformAsVariant0Item {
    fn from(value: &DensityTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistribution`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"normal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mean\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"stdev\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"lognormal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mean\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"stdev\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"uniform\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"max\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"min\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bandwidth\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"kde\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distributions\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"mixture\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"weights\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "function", deny_unknown_fields)]
pub enum DensityTransformDistribution {
    #[serde(rename = "normal")]
    Normal {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mean: ::std::option::Option<DensityTransformDistributionMean>,
        #[serde(default = "defaults::density_transform_distribution_normal_stdev")]
        stdev: DensityTransformDistributionStdev,
    },
    #[serde(rename = "lognormal")]
    Lognormal {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mean: ::std::option::Option<DensityTransformDistributionMean>,
        #[serde(default = "defaults::density_transform_distribution_lognormal_stdev")]
        stdev: DensityTransformDistributionStdev,
    },
    #[serde(rename = "uniform")]
    Uniform {
        #[serde(default = "defaults::density_transform_distribution_uniform_max")]
        max: DensityTransformDistributionMax,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        min: ::std::option::Option<DensityTransformDistributionMin>,
    },
    #[serde(rename = "kde")]
    Kde {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bandwidth: ::std::option::Option<DensityTransformDistributionBandwidth>,
        field: DensityTransformDistributionField,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        from: ::std::option::Option<::std::string::String>,
    },
    #[serde(rename = "mixture")]
    Mixture {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        distributions: ::std::option::Option<DensityTransformDistributionDistributions>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        weights: ::std::option::Option<DensityTransformDistributionWeights>,
    },
}
impl ::std::convert::From<&Self> for DensityTransformDistribution {
    fn from(value: &DensityTransformDistribution) -> Self {
        value.clone()
    }
}
#[doc = "`DensityTransformDistributionBandwidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionBandwidth {
    fn from(value: &DensityTransformDistributionBandwidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionDistributions`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionDistributions {
    Variant0(::std::vec::Vec<::serde_json::Value>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionDistributions {
    fn from(value: &DensityTransformDistributionDistributions) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>>
    for DensityTransformDistributionDistributions
{
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionDistributions {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionField {
    fn from(value: &DensityTransformDistributionField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for DensityTransformDistributionField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for DensityTransformDistributionField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for DensityTransformDistributionField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`DensityTransformDistributionMax`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionMax {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionMax {
    fn from(value: &DensityTransformDistributionMax) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformDistributionMax {
    fn default() -> Self {
        DensityTransformDistributionMax::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionMax {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionMax {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionMean`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionMean {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionMean {
    fn from(value: &DensityTransformDistributionMean) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionMean {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionMean {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionMin`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionMin {
    fn from(value: &DensityTransformDistributionMin) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionStdev`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionStdev {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionStdev {
    fn from(value: &DensityTransformDistributionStdev) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformDistributionStdev {
    fn default() -> Self {
        DensityTransformDistributionStdev::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionStdev {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionStdev {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionWeights`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionWeights {
    Variant0(::std::vec::Vec<DensityTransformDistributionWeightsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionWeights {
    fn from(value: &DensityTransformDistributionWeights) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<DensityTransformDistributionWeightsVariant0Item>>
    for DensityTransformDistributionWeights
{
    fn from(value: ::std::vec::Vec<DensityTransformDistributionWeightsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionWeights {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformDistributionWeightsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformDistributionWeightsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: &DensityTransformDistributionWeightsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformExtent {
    Variant0([DensityTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformExtent {
    fn from(value: &DensityTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[DensityTransformExtentVariant0Item; 2usize]> for DensityTransformExtent {
    fn from(value: [DensityTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformExtentVariant0Item {
    fn from(value: &DensityTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformMaxsteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 200,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformMaxsteps {
    fn from(value: &DensityTransformMaxsteps) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformMaxsteps {
    fn default() -> Self {
        DensityTransformMaxsteps::Variant0(200_f64)
    }
}
impl ::std::convert::From<f64> for DensityTransformMaxsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformMaxsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pdf\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformMethod {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformMethod {
    fn from(value: &DensityTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformMethod {
    fn default() -> Self {
        DensityTransformMethod::Variant0("pdf".to_string())
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformMinsteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 25,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformMinsteps {
    fn from(value: &DensityTransformMinsteps) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DensityTransformMinsteps {
    fn default() -> Self {
        DensityTransformMinsteps::Variant0(25_f64)
    }
}
impl ::std::convert::From<f64> for DensityTransformMinsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformMinsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformSteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DensityTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DensityTransformSteps {
    fn from(value: &DensityTransformSteps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DensityTransformSteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DensityTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DensityTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"density\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DensityTransformType {
    #[serde(rename = "density")]
    Density,
}
impl ::std::convert::From<&Self> for DensityTransformType {
    fn from(value: &DensityTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DensityTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Density => write!(f, "density"),
        }
    }
}
impl ::std::str::FromStr for DensityTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "density" => Ok(Self::Density),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DirectionValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"horizontal\","]
#[doc = "                              \"vertical\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"horizontal\","]
#[doc = "                        \"vertical\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValue {
    Variant0(::std::vec::Vec<DirectionValueVariant0Item>),
    Variant1(DirectionValueVariant1),
}
impl ::std::convert::From<&Self> for DirectionValue {
    fn from(value: &DirectionValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<DirectionValueVariant0Item>> for DirectionValue {
    fn from(value: ::std::vec::Vec<DirectionValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DirectionValueVariant1> for DirectionValue {
    fn from(value: DirectionValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DirectionValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"horizontal\","]
#[doc = "                        \"vertical\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant0Item {
    Variant0(DirectionValueVariant0ItemVariant0),
    Variant1(DirectionValueVariant0ItemVariant1),
    Variant2(DirectionValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for DirectionValueVariant0Item {
    fn from(value: &DirectionValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DirectionValueVariant0ItemVariant0> for DirectionValueVariant0Item {
    fn from(value: DirectionValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DirectionValueVariant0ItemVariant1> for DirectionValueVariant0Item {
    fn from(value: DirectionValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<DirectionValueVariant0ItemVariant2> for DirectionValueVariant0Item {
    fn from(value: DirectionValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DirectionValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"horizontal\","]
#[doc = "                \"vertical\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: DirectionValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: DirectionValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for DirectionValueVariant0ItemVariant0 {
    fn from(value: &DirectionValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`DirectionValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DirectionValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl ::std::convert::From<&Self> for DirectionValueVariant0ItemVariant0Variant1Value {
    fn from(value: &DirectionValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DirectionValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Horizontal => write!(f, "horizontal"),
            Self::Vertical => write!(f, "vertical"),
        }
    }
}
impl ::std::str::FromStr for DirectionValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DirectionValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DirectionValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DirectionValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DirectionValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for DirectionValueVariant0ItemVariant0Variant3Range {
    fn from(value: &DirectionValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DirectionValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DirectionValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DirectionValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DirectionValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DirectionValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for DirectionValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for DirectionValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DirectionValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"horizontal\","]
#[doc = "                  \"vertical\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum DirectionValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for DirectionValueVariant0ItemVariant1 {
    fn from(value: &DirectionValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`DirectionValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"horizontal\","]
#[doc = "                  \"vertical\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum DirectionValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for DirectionValueVariant0ItemVariant2 {
    fn from(value: &DirectionValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`DirectionValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"horizontal\","]
#[doc = "                    \"vertical\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant1 {
    Variant0(DirectionValueVariant1Variant0),
    Variant1(DirectionValueVariant1Variant1),
    Variant2(DirectionValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for DirectionValueVariant1 {
    fn from(value: &DirectionValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DirectionValueVariant1Variant0> for DirectionValueVariant1 {
    fn from(value: DirectionValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<DirectionValueVariant1Variant1> for DirectionValueVariant1 {
    fn from(value: DirectionValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<DirectionValueVariant1Variant2> for DirectionValueVariant1 {
    fn from(value: DirectionValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`DirectionValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"horizontal\","]
#[doc = "                \"vertical\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: DirectionValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: DirectionValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for DirectionValueVariant1Variant0 {
    fn from(value: &DirectionValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`DirectionValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DirectionValueVariant1Variant0Variant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl ::std::convert::From<&Self> for DirectionValueVariant1Variant0Variant1Value {
    fn from(value: &DirectionValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DirectionValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Horizontal => write!(f, "horizontal"),
            Self::Vertical => write!(f, "vertical"),
        }
    }
}
impl ::std::str::FromStr for DirectionValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DirectionValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DirectionValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DirectionValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DirectionValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DirectionValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for DirectionValueVariant1Variant0Variant3Range {
    fn from(value: &DirectionValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DirectionValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for DirectionValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for DirectionValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for DirectionValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for DirectionValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for DirectionValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for DirectionValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DirectionValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"horizontal\","]
#[doc = "                  \"vertical\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum DirectionValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for DirectionValueVariant1Variant1 {
    fn from(value: &DirectionValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`DirectionValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"horizontal\","]
#[doc = "                  \"vertical\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum DirectionValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for DirectionValueVariant1Variant2 {
    fn from(value: &DirectionValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`DotbinTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"bin\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dotbin\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct DotbinTransform {
    #[serde(rename = "as", default = "defaults::dotbin_transform_as")]
    pub as_: DotbinTransformAs,
    pub field: DotbinTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<DotbinTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub smooth: ::std::option::Option<DotbinTransformSmooth>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub step: ::std::option::Option<DotbinTransformStep>,
    #[serde(rename = "type")]
    pub type_: DotbinTransformType,
}
impl ::std::convert::From<&DotbinTransform> for DotbinTransform {
    fn from(value: &DotbinTransform) -> Self {
        value.clone()
    }
}
#[doc = "`DotbinTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"bin\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DotbinTransformAs {
    fn from(value: &DotbinTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for DotbinTransformAs {
    fn default() -> Self {
        DotbinTransformAs::Variant0("bin".to_string())
    }
}
impl ::std::convert::From<SignalRef> for DotbinTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DotbinTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for DotbinTransformField {
    fn from(value: &DotbinTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for DotbinTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for DotbinTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for DotbinTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`DotbinTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformGroupby {
    Variant0(::std::vec::Vec<DotbinTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DotbinTransformGroupby {
    fn from(value: &DotbinTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<DotbinTransformGroupbyVariant0Item>>
    for DotbinTransformGroupby
{
    fn from(value: ::std::vec::Vec<DotbinTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DotbinTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DotbinTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for DotbinTransformGroupbyVariant0Item {
    fn from(value: &DotbinTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for DotbinTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for DotbinTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for DotbinTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`DotbinTransformSmooth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DotbinTransformSmooth {
    fn from(value: &DotbinTransformSmooth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for DotbinTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DotbinTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DotbinTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DotbinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for DotbinTransformStep {
    fn from(value: &DotbinTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for DotbinTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for DotbinTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`DotbinTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dotbin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DotbinTransformType {
    #[serde(rename = "dotbin")]
    Dotbin,
}
impl ::std::convert::From<&Self> for DotbinTransformType {
    fn from(value: &DotbinTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DotbinTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Dotbin => write!(f, "dotbin"),
        }
    }
}
impl ::std::str::FromStr for DotbinTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "dotbin" => Ok(Self::Dotbin),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Element`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Element(pub ::std::string::String);
impl ::std::ops::Deref for Element {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Element> for ::std::string::String {
    fn from(value: Element) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Element> for Element {
    fn from(value: &Element) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Element {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Element {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Element {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"patternProperties\": {"]
#[doc = "    \"^.+$\": {"]
#[doc = "      \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct Encode(pub ::std::collections::HashMap<EncodeKey, EncodeEntry>);
impl ::std::ops::Deref for Encode {
    type Target = ::std::collections::HashMap<EncodeKey, EncodeEntry>;
    fn deref(&self) -> &::std::collections::HashMap<EncodeKey, EncodeEntry> {
        &self.0
    }
}
impl ::std::convert::From<Encode> for ::std::collections::HashMap<EncodeKey, EncodeEntry> {
    fn from(value: Encode) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Encode> for Encode {
    fn from(value: &Encode) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::collections::HashMap<EncodeKey, EncodeEntry>> for Encode {
    fn from(value: ::std::collections::HashMap<EncodeKey, EncodeEntry>) -> Self {
        Self(value)
    }
}
#[doc = "`EncodeEntry`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"align\": {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    },"]
#[doc = "    \"angle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"aria\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"ariaRole\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"ariaRoleDescription\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"aspect\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"baseline\": {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    },"]
#[doc = "    \"blend\": {"]
#[doc = "      \"$ref\": \"#/definitions/blendValue\""]
#[doc = "    },"]
#[doc = "    \"clip\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusBottomLeft\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusBottomRight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusTopLeft\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusTopRight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cursor\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"defined\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"dir\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"dx\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"dy\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"ellipsis\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"endAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"fill\": {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    },"]
#[doc = "    \"fillOpacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"font\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"fontSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"fontStyle\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"fontWeight\": {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"innerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"interpolate\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"limit\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"lineBreak\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"lineHeight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"opacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"$ref\": \"#/definitions/directionValue\""]
#[doc = "    },"]
#[doc = "    \"outerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"padAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"radius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"scaleX\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"scaleY\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"shape\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"startAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"stroke\": {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    },"]
#[doc = "    \"strokeCap\": {"]
#[doc = "      \"$ref\": \"#/definitions/strokeCapValue\""]
#[doc = "    },"]
#[doc = "    \"strokeDash\": {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    },"]
#[doc = "    \"strokeDashOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeForeground\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"strokeJoin\": {"]
#[doc = "      \"$ref\": \"#/definitions/strokeJoinValue\""]
#[doc = "    },"]
#[doc = "    \"strokeMiterLimit\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeOpacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeWidth\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"tension\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"$ref\": \"#/definitions/textValue\""]
#[doc = "    },"]
#[doc = "    \"theta\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"tooltip\": {"]
#[doc = "      \"$ref\": \"#/definitions/anyValue\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"width\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"xc\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"yc\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"zindex\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EncodeEntry {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub align: ::std::option::Option<AlignValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub angle: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aria: ::std::option::Option<BooleanValue>,
    #[serde(
        rename = "ariaRole",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub aria_role: ::std::option::Option<StringValue>,
    #[serde(
        rename = "ariaRoleDescription",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub aria_role_description: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aspect: ::std::option::Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub baseline: ::std::option::Option<BaselineValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub blend: ::std::option::Option<BlendValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub clip: ::std::option::Option<BooleanValue>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub corner_radius: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomLeft",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub corner_radius_bottom_left: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomRight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub corner_radius_bottom_right: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopLeft",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub corner_radius_top_left: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopRight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub corner_radius_top_right: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cursor: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub defined: ::std::option::Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dir: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dx: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dy: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ellipsis: ::std::option::Option<StringValue>,
    #[serde(
        rename = "endAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub end_angle: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fill: ::std::option::Option<ColorValue>,
    #[serde(
        rename = "fillOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub fill_opacity: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub font: ::std::option::Option<StringValue>,
    #[serde(
        rename = "fontSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub font_size: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "fontStyle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub font_style: ::std::option::Option<StringValue>,
    #[serde(
        rename = "fontWeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub font_weight: ::std::option::Option<FontWeightValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub height: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "innerRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub inner_radius: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub interpolate: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub limit: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "lineBreak",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub line_break: ::std::option::Option<StringValue>,
    #[serde(
        rename = "lineHeight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub line_height: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub opacity: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub orient: ::std::option::Option<DirectionValue>,
    #[serde(
        rename = "outerRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub outer_radius: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "padAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub pad_angle: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub path: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub radius: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "scaleX",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub scale_x: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "scaleY",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub scale_y: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub shape: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub smooth: ::std::option::Option<BooleanValue>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_angle: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub stroke: ::std::option::Option<ColorValue>,
    #[serde(
        rename = "strokeCap",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_cap: ::std::option::Option<StrokeCapValue>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_dash: ::std::option::Option<ArrayValue>,
    #[serde(
        rename = "strokeDashOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_dash_offset: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "strokeForeground",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_foreground: ::std::option::Option<BooleanValue>,
    #[serde(
        rename = "strokeJoin",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_join: ::std::option::Option<StrokeJoinValue>,
    #[serde(
        rename = "strokeMiterLimit",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_miter_limit: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "strokeOffset",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_offset: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "strokeOpacity",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_opacity: ::std::option::Option<NumberValue>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub stroke_width: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tension: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<TextValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub theta: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub tooltip: ::std::option::Option<AnyValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub url: ::std::option::Option<StringValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub width: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x2: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub xc: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y2: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub yc: ::std::option::Option<NumberValue>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub zindex: ::std::option::Option<NumberValue>,
}
impl ::std::convert::From<&EncodeEntry> for EncodeEntry {
    fn from(value: &EncodeEntry) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EncodeEntry {
    fn default() -> Self {
        Self {
            align: Default::default(),
            angle: Default::default(),
            aria: Default::default(),
            aria_role: Default::default(),
            aria_role_description: Default::default(),
            aspect: Default::default(),
            baseline: Default::default(),
            blend: Default::default(),
            clip: Default::default(),
            corner_radius: Default::default(),
            corner_radius_bottom_left: Default::default(),
            corner_radius_bottom_right: Default::default(),
            corner_radius_top_left: Default::default(),
            corner_radius_top_right: Default::default(),
            cursor: Default::default(),
            defined: Default::default(),
            description: Default::default(),
            dir: Default::default(),
            dx: Default::default(),
            dy: Default::default(),
            ellipsis: Default::default(),
            end_angle: Default::default(),
            fill: Default::default(),
            fill_opacity: Default::default(),
            font: Default::default(),
            font_size: Default::default(),
            font_style: Default::default(),
            font_weight: Default::default(),
            height: Default::default(),
            inner_radius: Default::default(),
            interpolate: Default::default(),
            limit: Default::default(),
            line_break: Default::default(),
            line_height: Default::default(),
            opacity: Default::default(),
            orient: Default::default(),
            outer_radius: Default::default(),
            pad_angle: Default::default(),
            path: Default::default(),
            radius: Default::default(),
            scale_x: Default::default(),
            scale_y: Default::default(),
            shape: Default::default(),
            size: Default::default(),
            smooth: Default::default(),
            start_angle: Default::default(),
            stroke: Default::default(),
            stroke_cap: Default::default(),
            stroke_dash: Default::default(),
            stroke_dash_offset: Default::default(),
            stroke_foreground: Default::default(),
            stroke_join: Default::default(),
            stroke_miter_limit: Default::default(),
            stroke_offset: Default::default(),
            stroke_opacity: Default::default(),
            stroke_width: Default::default(),
            tension: Default::default(),
            text: Default::default(),
            theta: Default::default(),
            tooltip: Default::default(),
            url: Default::default(),
            width: Default::default(),
            x: Default::default(),
            x2: Default::default(),
            xc: Default::default(),
            y: Default::default(),
            y2: Default::default(),
            yc: Default::default(),
            zindex: Default::default(),
        }
    }
}
#[doc = "`EncodeKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^.+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct EncodeKey(::std::string::String);
impl ::std::ops::Deref for EncodeKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<EncodeKey> for ::std::string::String {
    fn from(value: EncodeKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EncodeKey> for EncodeKey {
    fn from(value: &EncodeKey) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for EncodeKey {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| ::regress::Regex::new("^.+$").unwrap());
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^.+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for EncodeKey {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EncodeKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EncodeKey {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for EncodeKey {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`Everything`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Everything\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scope\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"properties\": {"]
#[doc = "        \"$schema\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"autosize\": {"]
#[doc = "          \"$ref\": \"#/definitions/autosize\""]
#[doc = "        },"]
#[doc = "        \"background\": {"]
#[doc = "          \"$ref\": \"#/definitions/background\""]
#[doc = "        },"]
#[doc = "        \"config\": {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"height\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/padding\""]
#[doc = "        },"]
#[doc = "        \"style\": {"]
#[doc = "          \"$ref\": \"#/definitions/style\""]
#[doc = "        },"]
#[doc = "        \"width\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Everything {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub autosize: ::std::option::Option<Autosize>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub axes: ::std::vec::Vec<Axis>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub background: ::std::option::Option<Background>,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub config: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<Data>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<Encode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub height: ::std::option::Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub layout: ::std::option::Option<Layout>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub legends: ::std::vec::Vec<Legend>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub marks: ::std::vec::Vec<EverythingMarksItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<Padding>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub projections: ::std::vec::Vec<Projection>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scales: ::std::vec::Vec<Scale>,
    #[serde(
        rename = "$schema",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub schema: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub signals: ::std::vec::Vec<Signal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub style: ::std::option::Option<Style>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<Title>,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub usermeta: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub width: ::std::option::Option<NumberOrSignal>,
}
impl ::std::convert::From<&Everything> for Everything {
    fn from(value: &Everything) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Everything {
    fn default() -> Self {
        Self {
            autosize: Default::default(),
            axes: Default::default(),
            background: Default::default(),
            config: Default::default(),
            data: Default::default(),
            description: Default::default(),
            encode: Default::default(),
            height: Default::default(),
            layout: Default::default(),
            legends: Default::default(),
            marks: Default::default(),
            padding: Default::default(),
            projections: Default::default(),
            scales: Default::default(),
            schema: Default::default(),
            signals: Default::default(),
            style: Default::default(),
            title: Default::default(),
            usermeta: Default::default(),
            width: Default::default(),
        }
    }
}
#[doc = "`EverythingMarksItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EverythingMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl ::std::convert::From<&Self> for EverythingMarksItem {
    fn from(value: &EverythingMarksItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MarkGroup> for EverythingMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl ::std::convert::From<MarkVisual> for EverythingMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "`Expr`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expr\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"expr\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Expr {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<::std::string::String>,
    pub expr: ::std::string::String,
}
impl ::std::convert::From<&Expr> for Expr {
    fn from(value: &Expr) -> Self {
        value.clone()
    }
}
#[doc = "`ExprString`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct ExprString(pub ::std::string::String);
impl ::std::ops::Deref for ExprString {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ExprString> for ::std::string::String {
    fn from(value: ExprString) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ExprString> for ExprString {
    fn from(value: &ExprString) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for ExprString {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for ExprString {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for ExprString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`ExtentTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"extent\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ExtentTransform {
    pub field: ExtentTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ExtentTransformType,
}
impl ::std::convert::From<&ExtentTransform> for ExtentTransform {
    fn from(value: &ExtentTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ExtentTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ExtentTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ExtentTransformField {
    fn from(value: &ExtentTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ExtentTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ExtentTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ExtentTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ExtentTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"extent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExtentTransformType {
    #[serde(rename = "extent")]
    Extent,
}
impl ::std::convert::From<&Self> for ExtentTransformType {
    fn from(value: &ExtentTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExtentTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Extent => write!(f, "extent"),
        }
    }
}
impl ::std::str::FromStr for ExtentTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Facet`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"facet\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"facet\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"field\","]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"groupby\","]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"aggregate\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"as\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"cross\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"fields\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"ops\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"groupby\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Facet {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::std::string::String>,
    pub facet: FacetFacet,
}
impl ::std::convert::From<&Facet> for Facet {
    fn from(value: &Facet) -> Self {
        value.clone()
    }
}
#[doc = "`FacetFacet`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"groupby\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"aggregate\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"as\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"cross\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"ops\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"groupby\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum FacetFacet {
    Variant0 {
        data: ::std::string::String,
        field: ::std::string::String,
        name: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aggregate: ::std::option::Option<FacetFacetVariant1Aggregate>,
        data: ::std::string::String,
        groupby: FacetFacetVariant1Groupby,
        name: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for FacetFacet {
    fn from(value: &FacetFacet) -> Self {
        value.clone()
    }
}
#[doc = "`FacetFacetVariant1Aggregate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"cross\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FacetFacetVariant1Aggregate {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::vec::Vec::is_empty"
    )]
    pub as_: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cross: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub fields: ::std::vec::Vec<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub ops: ::std::vec::Vec<::std::string::String>,
}
impl ::std::convert::From<&FacetFacetVariant1Aggregate> for FacetFacetVariant1Aggregate {
    fn from(value: &FacetFacetVariant1Aggregate) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for FacetFacetVariant1Aggregate {
    fn default() -> Self {
        Self {
            as_: Default::default(),
            cross: Default::default(),
            fields: Default::default(),
            ops: Default::default(),
        }
    }
}
#[doc = "`FacetFacetVariant1Groupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FacetFacetVariant1Groupby {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for FacetFacetVariant1Groupby {
    fn from(value: &FacetFacetVariant1Groupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for FacetFacetVariant1Groupby {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Field`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"datum\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"datum\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"group\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"group\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"level\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"parent\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"level\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"parent\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Field {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2 {
        datum: ::std::boxed::Box<Field>,
    },
    Variant3 {
        group: ::std::boxed::Box<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        level: ::std::option::Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        level: ::std::option::Option<f64>,
        parent: ::std::boxed::Box<Field>,
    },
}
impl ::std::convert::From<&Self> for Field {
    fn from(value: &Field) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for Field {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FilterTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expr\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expr\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"filter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FilterTransform {
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: FilterTransformType,
}
impl ::std::convert::From<&FilterTransform> for FilterTransform {
    fn from(value: &FilterTransform) -> Self {
        value.clone()
    }
}
#[doc = "`FilterTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"filter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FilterTransformType {
    #[serde(rename = "filter")]
    Filter,
}
impl ::std::convert::From<&Self> for FilterTransformType {
    fn from(value: &FilterTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FilterTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Filter => write!(f, "filter"),
        }
    }
}
impl ::std::str::FromStr for FilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "filter" => Ok(Self::Filter),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`FlattenTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"index\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"flatten\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FlattenTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<FlattenTransformAs>,
    pub fields: FlattenTransformFields,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub index: ::std::option::Option<FlattenTransformIndex>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: FlattenTransformType,
}
impl ::std::convert::From<&FlattenTransform> for FlattenTransform {
    fn from(value: &FlattenTransform) -> Self {
        value.clone()
    }
}
#[doc = "`FlattenTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FlattenTransformAs {
    Variant0(::std::vec::Vec<FlattenTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FlattenTransformAs {
    fn from(value: &FlattenTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<FlattenTransformAsVariant0Item>> for FlattenTransformAs {
    fn from(value: ::std::vec::Vec<FlattenTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for FlattenTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FlattenTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FlattenTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FlattenTransformAsVariant0Item {
    fn from(value: &FlattenTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for FlattenTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FlattenTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FlattenTransformFields {
    Variant0(::std::vec::Vec<FlattenTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FlattenTransformFields {
    fn from(value: &FlattenTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<FlattenTransformFieldsVariant0Item>>
    for FlattenTransformFields
{
    fn from(value: ::std::vec::Vec<FlattenTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for FlattenTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FlattenTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FlattenTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for FlattenTransformFieldsVariant0Item {
    fn from(value: &FlattenTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for FlattenTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for FlattenTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for FlattenTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`FlattenTransformIndex`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FlattenTransformIndex {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FlattenTransformIndex {
    fn from(value: &FlattenTransformIndex) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for FlattenTransformIndex {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FlattenTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"flatten\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FlattenTransformType {
    #[serde(rename = "flatten")]
    Flatten,
}
impl ::std::convert::From<&Self> for FlattenTransformType {
    fn from(value: &FlattenTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FlattenTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Flatten => write!(f, "flatten"),
        }
    }
}
impl ::std::str::FromStr for FlattenTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "flatten" => Ok(Self::Flatten),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`FoldTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"key\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"fold\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FoldTransform {
    #[serde(rename = "as", default = "defaults::fold_transform_as")]
    pub as_: FoldTransformAs,
    pub fields: FoldTransformFields,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: FoldTransformType,
}
impl ::std::convert::From<&FoldTransform> for FoldTransform {
    fn from(value: &FoldTransform) -> Self {
        value.clone()
    }
}
#[doc = "`FoldTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"key\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FoldTransformAs {
    Variant0([FoldTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FoldTransformAs {
    fn from(value: &FoldTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for FoldTransformAs {
    fn default() -> Self {
        FoldTransformAs::Variant0([
            FoldTransformAsVariant0Item::Variant0("key".to_string()),
            FoldTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
}
impl ::std::convert::From<[FoldTransformAsVariant0Item; 2usize]> for FoldTransformAs {
    fn from(value: [FoldTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for FoldTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FoldTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FoldTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FoldTransformAsVariant0Item {
    fn from(value: &FoldTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for FoldTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FoldTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FoldTransformFields {
    Variant0(::std::vec::Vec<FoldTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FoldTransformFields {
    fn from(value: &FoldTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<FoldTransformFieldsVariant0Item>>
    for FoldTransformFields
{
    fn from(value: ::std::vec::Vec<FoldTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for FoldTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FoldTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FoldTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for FoldTransformFieldsVariant0Item {
    fn from(value: &FoldTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for FoldTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for FoldTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for FoldTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`FoldTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"fold\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FoldTransformType {
    #[serde(rename = "fold")]
    Fold,
}
impl ::std::convert::From<&Self> for FoldTransformType {
    fn from(value: &FoldTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FoldTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Fold => write!(f, "fold"),
        }
    }
}
impl ::std::str::FromStr for FoldTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "fold" => Ok(Self::Fold),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`FontWeightValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              null,"]
#[doc = "                              \"normal\","]
#[doc = "                              \"bold\","]
#[doc = "                              \"lighter\","]
#[doc = "                              \"bolder\","]
#[doc = "                              \"100\","]
#[doc = "                              \"200\","]
#[doc = "                              \"300\","]
#[doc = "                              \"400\","]
#[doc = "                              \"500\","]
#[doc = "                              \"600\","]
#[doc = "                              \"700\","]
#[doc = "                              \"800\","]
#[doc = "                              \"900\","]
#[doc = "                              100,"]
#[doc = "                              200,"]
#[doc = "                              300,"]
#[doc = "                              400,"]
#[doc = "                              500,"]
#[doc = "                              600,"]
#[doc = "                              700,"]
#[doc = "                              800,"]
#[doc = "                              900"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"normal\","]
#[doc = "                        \"bold\","]
#[doc = "                        \"lighter\","]
#[doc = "                        \"bolder\","]
#[doc = "                        \"100\","]
#[doc = "                        \"200\","]
#[doc = "                        \"300\","]
#[doc = "                        \"400\","]
#[doc = "                        \"500\","]
#[doc = "                        \"600\","]
#[doc = "                        \"700\","]
#[doc = "                        \"800\","]
#[doc = "                        \"900\","]
#[doc = "                        100,"]
#[doc = "                        200,"]
#[doc = "                        300,"]
#[doc = "                        400,"]
#[doc = "                        500,"]
#[doc = "                        600,"]
#[doc = "                        700,"]
#[doc = "                        800,"]
#[doc = "                        900"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValue {
    Variant0(::std::vec::Vec<FontWeightValueVariant0Item>),
    Variant1(FontWeightValueVariant1),
}
impl ::std::convert::From<&Self> for FontWeightValue {
    fn from(value: &FontWeightValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<FontWeightValueVariant0Item>> for FontWeightValue {
    fn from(value: ::std::vec::Vec<FontWeightValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValueVariant1> for FontWeightValue {
    fn from(value: FontWeightValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FontWeightValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"normal\","]
#[doc = "                        \"bold\","]
#[doc = "                        \"lighter\","]
#[doc = "                        \"bolder\","]
#[doc = "                        \"100\","]
#[doc = "                        \"200\","]
#[doc = "                        \"300\","]
#[doc = "                        \"400\","]
#[doc = "                        \"500\","]
#[doc = "                        \"600\","]
#[doc = "                        \"700\","]
#[doc = "                        \"800\","]
#[doc = "                        \"900\","]
#[doc = "                        100,"]
#[doc = "                        200,"]
#[doc = "                        300,"]
#[doc = "                        400,"]
#[doc = "                        500,"]
#[doc = "                        600,"]
#[doc = "                        700,"]
#[doc = "                        800,"]
#[doc = "                        900"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant0Item {
    Variant0(FontWeightValueVariant0ItemVariant0),
    Variant1(FontWeightValueVariant0ItemVariant1),
    Variant2(FontWeightValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for FontWeightValueVariant0Item {
    fn from(value: &FontWeightValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<FontWeightValueVariant0ItemVariant0> for FontWeightValueVariant0Item {
    fn from(value: FontWeightValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValueVariant0ItemVariant1> for FontWeightValueVariant0Item {
    fn from(value: FontWeightValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<FontWeightValueVariant0ItemVariant2> for FontWeightValueVariant0Item {
    fn from(value: FontWeightValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`FontWeightValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: MyEnum,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: FontWeightValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for FontWeightValueVariant0ItemVariant0 {
    fn from(value: &FontWeightValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`FontWeightValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for FontWeightValueVariant0ItemVariant0Variant3Range {
    fn from(value: &FontWeightValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for FontWeightValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for FontWeightValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for FontWeightValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for FontWeightValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for FontWeightValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for FontWeightValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for FontWeightValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FontWeightValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"normal\","]
#[doc = "                  \"bold\","]
#[doc = "                  \"lighter\","]
#[doc = "                  \"bolder\","]
#[doc = "                  \"100\","]
#[doc = "                  \"200\","]
#[doc = "                  \"300\","]
#[doc = "                  \"400\","]
#[doc = "                  \"500\","]
#[doc = "                  \"600\","]
#[doc = "                  \"700\","]
#[doc = "                  \"800\","]
#[doc = "                  \"900\","]
#[doc = "                  100,"]
#[doc = "                  200,"]
#[doc = "                  300,"]
#[doc = "                  400,"]
#[doc = "                  500,"]
#[doc = "                  600,"]
#[doc = "                  700,"]
#[doc = "                  800,"]
#[doc = "                  900"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum FontWeightValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for FontWeightValueVariant0ItemVariant1 {
    fn from(value: &FontWeightValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`FontWeightValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"normal\","]
#[doc = "                  \"bold\","]
#[doc = "                  \"lighter\","]
#[doc = "                  \"bolder\","]
#[doc = "                  \"100\","]
#[doc = "                  \"200\","]
#[doc = "                  \"300\","]
#[doc = "                  \"400\","]
#[doc = "                  \"500\","]
#[doc = "                  \"600\","]
#[doc = "                  \"700\","]
#[doc = "                  \"800\","]
#[doc = "                  \"900\","]
#[doc = "                  100,"]
#[doc = "                  200,"]
#[doc = "                  300,"]
#[doc = "                  400,"]
#[doc = "                  500,"]
#[doc = "                  600,"]
#[doc = "                  700,"]
#[doc = "                  800,"]
#[doc = "                  900"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum FontWeightValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for FontWeightValueVariant0ItemVariant2 {
    fn from(value: &FontWeightValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`FontWeightValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    null,"]
#[doc = "                    \"normal\","]
#[doc = "                    \"bold\","]
#[doc = "                    \"lighter\","]
#[doc = "                    \"bolder\","]
#[doc = "                    \"100\","]
#[doc = "                    \"200\","]
#[doc = "                    \"300\","]
#[doc = "                    \"400\","]
#[doc = "                    \"500\","]
#[doc = "                    \"600\","]
#[doc = "                    \"700\","]
#[doc = "                    \"800\","]
#[doc = "                    \"900\","]
#[doc = "                    100,"]
#[doc = "                    200,"]
#[doc = "                    300,"]
#[doc = "                    400,"]
#[doc = "                    500,"]
#[doc = "                    600,"]
#[doc = "                    700,"]
#[doc = "                    800,"]
#[doc = "                    900"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant1 {
    Variant0(FontWeightValueVariant1Variant0),
    Variant1(FontWeightValueVariant1Variant1),
    Variant2(FontWeightValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for FontWeightValueVariant1 {
    fn from(value: &FontWeightValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<FontWeightValueVariant1Variant0> for FontWeightValueVariant1 {
    fn from(value: FontWeightValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValueVariant1Variant1> for FontWeightValueVariant1 {
    fn from(value: FontWeightValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<FontWeightValueVariant1Variant2> for FontWeightValueVariant1 {
    fn from(value: FontWeightValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`FontWeightValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: MyEnum,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: FontWeightValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for FontWeightValueVariant1Variant0 {
    fn from(value: &FontWeightValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`FontWeightValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for FontWeightValueVariant1Variant0Variant3Range {
    fn from(value: &FontWeightValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for FontWeightValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for FontWeightValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for FontWeightValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for FontWeightValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for FontWeightValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for FontWeightValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for FontWeightValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FontWeightValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"normal\","]
#[doc = "                  \"bold\","]
#[doc = "                  \"lighter\","]
#[doc = "                  \"bolder\","]
#[doc = "                  \"100\","]
#[doc = "                  \"200\","]
#[doc = "                  \"300\","]
#[doc = "                  \"400\","]
#[doc = "                  \"500\","]
#[doc = "                  \"600\","]
#[doc = "                  \"700\","]
#[doc = "                  \"800\","]
#[doc = "                  \"900\","]
#[doc = "                  100,"]
#[doc = "                  200,"]
#[doc = "                  300,"]
#[doc = "                  400,"]
#[doc = "                  500,"]
#[doc = "                  600,"]
#[doc = "                  700,"]
#[doc = "                  800,"]
#[doc = "                  900"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum FontWeightValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for FontWeightValueVariant1Variant1 {
    fn from(value: &FontWeightValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`FontWeightValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  null,"]
#[doc = "                  \"normal\","]
#[doc = "                  \"bold\","]
#[doc = "                  \"lighter\","]
#[doc = "                  \"bolder\","]
#[doc = "                  \"100\","]
#[doc = "                  \"200\","]
#[doc = "                  \"300\","]
#[doc = "                  \"400\","]
#[doc = "                  \"500\","]
#[doc = "                  \"600\","]
#[doc = "                  \"700\","]
#[doc = "                  \"800\","]
#[doc = "                  \"900\","]
#[doc = "                  100,"]
#[doc = "                  200,"]
#[doc = "                  300,"]
#[doc = "                  400,"]
#[doc = "                  500,"]
#[doc = "                  600,"]
#[doc = "                  700,"]
#[doc = "                  800,"]
#[doc = "                  900"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum FontWeightValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for FontWeightValueVariant1Variant2 {
    fn from(value: &FontWeightValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`ForceTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"alpha\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alphaMin\": {"]
#[doc = "      \"default\": 0.001,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alphaTarget\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"vx\","]
#[doc = "        \"vy\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"forces\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"x\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"y\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"collide\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"iterations\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"radius\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.7,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"distanceMax\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"distanceMin\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"nbody\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": -30,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"theta\": {"]
#[doc = "                \"default\": 0.9,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"distance\": {"]
#[doc = "                \"default\": 30,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"link\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"id\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"iterations\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"links\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"x\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"x\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"y\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"y\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"iterations\": {"]
#[doc = "      \"default\": 300,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"restart\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"static\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"force\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"velocityDecay\": {"]
#[doc = "      \"default\": 0.4,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ForceTransform {
    #[serde(default = "defaults::force_transform_alpha")]
    pub alpha: ForceTransformAlpha,
    #[serde(rename = "alphaMin", default = "defaults::force_transform_alpha_min")]
    pub alpha_min: ForceTransformAlphaMin,
    #[serde(
        rename = "alphaTarget",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub alpha_target: ::std::option::Option<ForceTransformAlphaTarget>,
    #[serde(rename = "as", default = "defaults::force_transform_as")]
    pub as_: ForceTransformAs,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub forces: ::std::vec::Vec<ForceTransformForcesItem>,
    #[serde(default = "defaults::force_transform_iterations")]
    pub iterations: ForceTransformIterations,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub restart: ::std::option::Option<ForceTransformRestart>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(
        rename = "static",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub static_: ::std::option::Option<ForceTransformStatic>,
    #[serde(rename = "type")]
    pub type_: ForceTransformType,
    #[serde(
        rename = "velocityDecay",
        default = "defaults::force_transform_velocity_decay"
    )]
    pub velocity_decay: ForceTransformVelocityDecay,
}
impl ::std::convert::From<&ForceTransform> for ForceTransform {
    fn from(value: &ForceTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ForceTransformAlpha`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformAlpha {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformAlpha {
    fn from(value: &ForceTransformAlpha) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformAlpha {
    fn default() -> Self {
        ForceTransformAlpha::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformAlpha {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformAlpha {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformAlphaMin`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.001,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformAlphaMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformAlphaMin {
    fn from(value: &ForceTransformAlphaMin) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformAlphaMin {
    fn default() -> Self {
        ForceTransformAlphaMin::Variant0(0.001_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformAlphaMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformAlphaMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformAlphaTarget`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformAlphaTarget {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformAlphaTarget {
    fn from(value: &ForceTransformAlphaTarget) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ForceTransformAlphaTarget {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformAlphaTarget {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"vx\","]
#[doc = "    \"vy\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformAs {
    Variant0(::std::vec::Vec<ForceTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformAs {
    fn from(value: &ForceTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformAs {
    fn default() -> Self {
        ForceTransformAs::Variant0(vec![
            ForceTransformAsVariant0Item::Variant0("x".to_string()),
            ForceTransformAsVariant0Item::Variant0("y".to_string()),
            ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<ForceTransformAsVariant0Item>> for ForceTransformAs {
    fn from(value: ::std::vec::Vec<ForceTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformAsVariant0Item {
    fn from(value: &ForceTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"x\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"y\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"collide\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"iterations\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"radius\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.7,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distanceMax\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"distanceMin\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"nbody\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": -30,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"theta\": {"]
#[doc = "          \"default\": 0.9,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distance\": {"]
#[doc = "          \"default\": 30,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"link\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"iterations\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"links\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"x\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"x\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"y\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"y\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "force", deny_unknown_fields)]
pub enum ForceTransformForcesItem {
    #[serde(rename = "center")]
    Center {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        x: ::std::option::Option<ForceTransformForcesItemX>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        y: ::std::option::Option<ForceTransformForcesItemY>,
    },
    #[serde(rename = "collide")]
    Collide {
        #[serde(default = "defaults::force_transform_forces_item_collide_iterations")]
        iterations: ForceTransformForcesItemIterations,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        radius: ::std::option::Option<ForceTransformForcesItemRadius>,
        #[serde(default = "defaults::force_transform_forces_item_collide_strength")]
        strength: ForceTransformForcesItemStrength,
    },
    #[serde(rename = "nbody")]
    Nbody {
        #[serde(
            rename = "distanceMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        distance_max: ::std::option::Option<ForceTransformForcesItemDistanceMax>,
        #[serde(
            rename = "distanceMin",
            default = "defaults::force_transform_forces_item_nbody_distance_min"
        )]
        distance_min: ForceTransformForcesItemDistanceMin,
        #[serde(default = "defaults::force_transform_forces_item_nbody_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default = "defaults::force_transform_forces_item_nbody_theta")]
        theta: ForceTransformForcesItemTheta,
    },
    #[serde(rename = "link")]
    Link {
        #[serde(default = "defaults::force_transform_forces_item_link_distance")]
        distance: ForceTransformForcesItemDistance,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        id: ::std::option::Option<ForceTransformForcesItemId>,
        #[serde(default = "defaults::force_transform_forces_item_link_iterations")]
        iterations: ForceTransformForcesItemIterations,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        links: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        strength: ::std::option::Option<ForceTransformForcesItemStrength>,
    },
    #[serde(rename = "x")]
    X {
        #[serde(default = "defaults::force_transform_forces_item_x_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        x: ::std::option::Option<ForceTransformForcesItemX>,
    },
    #[serde(rename = "y")]
    Y {
        #[serde(default = "defaults::force_transform_forces_item_y_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        y: ::std::option::Option<ForceTransformForcesItemY>,
    },
}
impl ::std::convert::From<&Self> for ForceTransformForcesItem {
    fn from(value: &ForceTransformForcesItem) -> Self {
        value.clone()
    }
}
#[doc = "`ForceTransformForcesItemDistance`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 30,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistance {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemDistance {
    fn from(value: &ForceTransformForcesItemDistance) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformForcesItemDistance {
    fn default() -> Self {
        ForceTransformForcesItemDistance::Variant0(30_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemDistance {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemDistance {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for ForceTransformForcesItemDistance {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for ForceTransformForcesItemDistance {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ForceTransformForcesItemDistanceMax`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistanceMax {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemDistanceMax {
    fn from(value: &ForceTransformForcesItemDistanceMax) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemDistanceMax {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemDistanceMax {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemDistanceMin`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistanceMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemDistanceMin {
    fn from(value: &ForceTransformForcesItemDistanceMin) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformForcesItemDistanceMin {
    fn default() -> Self {
        ForceTransformForcesItemDistanceMin::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemDistanceMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemDistanceMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemId`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemId {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemId {
    fn from(value: &ForceTransformForcesItemId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ForceTransformForcesItemId {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ForceTransformForcesItemId {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ForceTransformForcesItemId {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ForceTransformForcesItemIterations`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemIterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemIterations {
    fn from(value: &ForceTransformForcesItemIterations) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformForcesItemIterations {
    fn default() -> Self {
        ForceTransformForcesItemIterations::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemIterations {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemIterations {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemRadius {
    fn from(value: &ForceTransformForcesItemRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for ForceTransformForcesItemRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for ForceTransformForcesItemRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ForceTransformForcesItemStrength`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.7,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemStrength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemStrength {
    fn from(value: &ForceTransformForcesItemStrength) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformForcesItemStrength {
    fn default() -> Self {
        ForceTransformForcesItemStrength::Variant0(0.7_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemStrength {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemStrength {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemTheta`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.9,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemTheta {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemTheta {
    fn from(value: &ForceTransformForcesItemTheta) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformForcesItemTheta {
    fn default() -> Self {
        ForceTransformForcesItemTheta::Variant0(0.9_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemTheta {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemTheta {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemX {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemX {
    fn from(value: &ForceTransformForcesItemX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemX {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformForcesItemY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformForcesItemY {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformForcesItemY {
    fn from(value: &ForceTransformForcesItemY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ForceTransformForcesItemY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformForcesItemY {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformIterations`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 300,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformIterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformIterations {
    fn from(value: &ForceTransformIterations) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformIterations {
    fn default() -> Self {
        ForceTransformIterations::Variant0(300_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformIterations {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformIterations {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformRestart`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformRestart {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformRestart {
    fn from(value: &ForceTransformRestart) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ForceTransformRestart {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformRestart {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformStatic`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformStatic {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformStatic {
    fn from(value: &ForceTransformStatic) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ForceTransformStatic {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformStatic {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ForceTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"force\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ForceTransformType {
    #[serde(rename = "force")]
    Force,
}
impl ::std::convert::From<&Self> for ForceTransformType {
    fn from(value: &ForceTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ForceTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Force => write!(f, "force"),
        }
    }
}
impl ::std::str::FromStr for ForceTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "force" => Ok(Self::Force),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ForceTransformVelocityDecay`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.4,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ForceTransformVelocityDecay {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ForceTransformVelocityDecay {
    fn from(value: &ForceTransformVelocityDecay) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ForceTransformVelocityDecay {
    fn default() -> Self {
        ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
}
impl ::std::convert::From<f64> for ForceTransformVelocityDecay {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ForceTransformVelocityDecay {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FormulaTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"as\","]
#[doc = "    \"expr\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"expr\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"initonly\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"formula\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct FormulaTransform {
    #[serde(rename = "as")]
    pub as_: FormulaTransformAs,
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub initonly: ::std::option::Option<FormulaTransformInitonly>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: FormulaTransformType,
}
impl ::std::convert::From<&FormulaTransform> for FormulaTransform {
    fn from(value: &FormulaTransform) -> Self {
        value.clone()
    }
}
#[doc = "`FormulaTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FormulaTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FormulaTransformAs {
    fn from(value: &FormulaTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for FormulaTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FormulaTransformInitonly`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum FormulaTransformInitonly {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for FormulaTransformInitonly {
    fn from(value: &FormulaTransformInitonly) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for FormulaTransformInitonly {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for FormulaTransformInitonly {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`FormulaTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"formula\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FormulaTransformType {
    #[serde(rename = "formula")]
    Formula,
}
impl ::std::convert::From<&Self> for FormulaTransformType {
    fn from(value: &FormulaTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FormulaTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Formula => write!(f, "formula"),
        }
    }
}
impl ::std::str::FromStr for FormulaTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "formula" => Ok(Self::Formula),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`From`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct From {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub data: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&From> for From {
    fn from(value: &From) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for From {
    fn default() -> Self {
        Self {
            data: Default::default(),
        }
    }
}
#[doc = "`GeojsonTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"geojson\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geojson\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GeojsonTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<GeojsonTransformFields>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub geojson: ::std::option::Option<GeojsonTransformGeojson>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: GeojsonTransformType,
}
impl ::std::convert::From<&GeojsonTransform> for GeojsonTransform {
    fn from(value: &GeojsonTransform) -> Self {
        value.clone()
    }
}
#[doc = "`GeojsonTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeojsonTransformFields {
    Variant0([GeojsonTransformFieldsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeojsonTransformFields {
    fn from(value: &GeojsonTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[GeojsonTransformFieldsVariant0Item; 2usize]> for GeojsonTransformFields {
    fn from(value: [GeojsonTransformFieldsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GeojsonTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeojsonTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeojsonTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for GeojsonTransformFieldsVariant0Item {
    fn from(value: &GeojsonTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for GeojsonTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for GeojsonTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for GeojsonTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`GeojsonTransformGeojson`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeojsonTransformGeojson {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for GeojsonTransformGeojson {
    fn from(value: &GeojsonTransformGeojson) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for GeojsonTransformGeojson {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for GeojsonTransformGeojson {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for GeojsonTransformGeojson {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`GeojsonTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GeojsonTransformType {
    #[serde(rename = "geojson")]
    Geojson,
}
impl ::std::convert::From<&Self> for GeojsonTransformType {
    fn from(value: &GeojsonTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GeojsonTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Geojson => write!(f, "geojson"),
        }
    }
}
impl ::std::str::FromStr for GeojsonTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "geojson" => Ok(Self::Geojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GeopathTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geopath\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GeopathTransform {
    #[serde(rename = "as", default = "defaults::geopath_transform_as")]
    pub as_: GeopathTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<GeopathTransformField>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_radius: ::std::option::Option<GeopathTransformPointRadius>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub projection: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: GeopathTransformType,
}
impl ::std::convert::From<&GeopathTransform> for GeopathTransform {
    fn from(value: &GeopathTransform) -> Self {
        value.clone()
    }
}
#[doc = "`GeopathTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopathTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeopathTransformAs {
    fn from(value: &GeopathTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GeopathTransformAs {
    fn default() -> Self {
        GeopathTransformAs::Variant0("path".to_string())
    }
}
impl ::std::convert::From<SignalRef> for GeopathTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeopathTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopathTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for GeopathTransformField {
    fn from(value: &GeopathTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for GeopathTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for GeopathTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for GeopathTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`GeopathTransformPointRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopathTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for GeopathTransformPointRadius {
    fn from(value: &GeopathTransformPointRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for GeopathTransformPointRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GeopathTransformPointRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for GeopathTransformPointRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for GeopathTransformPointRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`GeopathTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geopath\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GeopathTransformType {
    #[serde(rename = "geopath")]
    Geopath,
}
impl ::std::convert::From<&Self> for GeopathTransformType {
    fn from(value: &GeopathTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GeopathTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Geopath => write!(f, "geopath"),
        }
    }
}
impl ::std::str::FromStr for GeopathTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "geopath" => Ok(Self::Geopath),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GeopointTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"projection\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geopoint\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GeopointTransform {
    #[serde(rename = "as", default = "defaults::geopoint_transform_as")]
    pub as_: GeopointTransformAs,
    pub fields: GeopointTransformFields,
    pub projection: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: GeopointTransformType,
}
impl ::std::convert::From<&GeopointTransform> for GeopointTransform {
    fn from(value: &GeopointTransform) -> Self {
        value.clone()
    }
}
#[doc = "`GeopointTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopointTransformAs {
    Variant0([GeopointTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeopointTransformAs {
    fn from(value: &GeopointTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GeopointTransformAs {
    fn default() -> Self {
        GeopointTransformAs::Variant0([
            GeopointTransformAsVariant0Item::Variant0("x".to_string()),
            GeopointTransformAsVariant0Item::Variant0("y".to_string()),
        ])
    }
}
impl ::std::convert::From<[GeopointTransformAsVariant0Item; 2usize]> for GeopointTransformAs {
    fn from(value: [GeopointTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GeopointTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeopointTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopointTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeopointTransformAsVariant0Item {
    fn from(value: &GeopointTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for GeopointTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeopointTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopointTransformFields {
    Variant0([GeopointTransformFieldsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeopointTransformFields {
    fn from(value: &GeopointTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[GeopointTransformFieldsVariant0Item; 2usize]>
    for GeopointTransformFields
{
    fn from(value: [GeopointTransformFieldsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GeopointTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeopointTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeopointTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for GeopointTransformFieldsVariant0Item {
    fn from(value: &GeopointTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for GeopointTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for GeopointTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for GeopointTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`GeopointTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geopoint\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GeopointTransformType {
    #[serde(rename = "geopoint")]
    Geopoint,
}
impl ::std::convert::From<&Self> for GeopointTransformType {
    fn from(value: &GeopointTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GeopointTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Geopoint => write!(f, "geopoint"),
        }
    }
}
impl ::std::str::FromStr for GeopointTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "geopoint" => Ok(Self::Geopoint),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GeoshapeTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"shape\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"default\": \"datum\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geoshape\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GeoshapeTransform {
    #[serde(rename = "as", default = "defaults::geoshape_transform_as")]
    pub as_: GeoshapeTransformAs,
    #[serde(default = "defaults::geoshape_transform_field")]
    pub field: GeoshapeTransformField,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_radius: ::std::option::Option<GeoshapeTransformPointRadius>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub projection: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: GeoshapeTransformType,
}
impl ::std::convert::From<&GeoshapeTransform> for GeoshapeTransform {
    fn from(value: &GeoshapeTransform) -> Self {
        value.clone()
    }
}
#[doc = "`GeoshapeTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"shape\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeoshapeTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GeoshapeTransformAs {
    fn from(value: &GeoshapeTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GeoshapeTransformAs {
    fn default() -> Self {
        GeoshapeTransformAs::Variant0("shape".to_string())
    }
}
impl ::std::convert::From<SignalRef> for GeoshapeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GeoshapeTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"datum\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeoshapeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for GeoshapeTransformField {
    fn from(value: &GeoshapeTransformField) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GeoshapeTransformField {
    fn default() -> Self {
        GeoshapeTransformField::ScaleField(ScaleField(StringOrSignal::Variant0(
            "datum".to_string(),
        )))
    }
}
impl ::std::convert::From<ScaleField> for GeoshapeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for GeoshapeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for GeoshapeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`GeoshapeTransformPointRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GeoshapeTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for GeoshapeTransformPointRadius {
    fn from(value: &GeoshapeTransformPointRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for GeoshapeTransformPointRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GeoshapeTransformPointRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for GeoshapeTransformPointRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for GeoshapeTransformPointRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`GeoshapeTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geoshape\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GeoshapeTransformType {
    #[serde(rename = "geoshape")]
    Geoshape,
}
impl ::std::convert::From<&Self> for GeoshapeTransformType {
    fn from(value: &GeoshapeTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GeoshapeTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Geoshape => write!(f, "geoshape"),
        }
    }
}
impl ::std::str::FromStr for GeoshapeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "geoshape" => Ok(Self::Geoshape),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GradientStops`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"color\","]
#[doc = "      \"offset\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"color\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      },"]
#[doc = "      \"offset\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct GradientStops(pub ::std::vec::Vec<GradientStopsItem>);
impl ::std::ops::Deref for GradientStops {
    type Target = ::std::vec::Vec<GradientStopsItem>;
    fn deref(&self) -> &::std::vec::Vec<GradientStopsItem> {
        &self.0
    }
}
impl ::std::convert::From<GradientStops> for ::std::vec::Vec<GradientStopsItem> {
    fn from(value: GradientStops) -> Self {
        value.0
    }
}
impl ::std::convert::From<&GradientStops> for GradientStops {
    fn from(value: &GradientStops) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<GradientStopsItem>> for GradientStops {
    fn from(value: ::std::vec::Vec<GradientStopsItem>) -> Self {
        Self(value)
    }
}
#[doc = "`GradientStopsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"color\","]
#[doc = "    \"offset\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"color\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GradientStopsItem {
    pub color: ::std::string::String,
    pub offset: f64,
}
impl ::std::convert::From<&GradientStopsItem> for GradientStopsItem {
    fn from(value: &GradientStopsItem) -> Self {
        value.clone()
    }
}
#[doc = "`GraticuleTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extentMajor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extentMinor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"precision\": {"]
#[doc = "      \"default\": 2.5,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stepMajor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        90,"]
#[doc = "        360"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stepMinor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        10,"]
#[doc = "        10"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"graticule\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GraticuleTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<GraticuleTransformExtent>,
    #[serde(
        rename = "extentMajor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub extent_major: ::std::option::Option<GraticuleTransformExtentMajor>,
    #[serde(
        rename = "extentMinor",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub extent_minor: ::std::option::Option<GraticuleTransformExtentMinor>,
    #[serde(default = "defaults::graticule_transform_precision")]
    pub precision: GraticuleTransformPrecision,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub step: ::std::option::Option<GraticuleTransformStep>,
    #[serde(
        rename = "stepMajor",
        default = "defaults::graticule_transform_step_major"
    )]
    pub step_major: GraticuleTransformStepMajor,
    #[serde(
        rename = "stepMinor",
        default = "defaults::graticule_transform_step_minor"
    )]
    pub step_minor: GraticuleTransformStepMinor,
    #[serde(rename = "type")]
    pub type_: GraticuleTransformType,
}
impl ::std::convert::From<&GraticuleTransform> for GraticuleTransform {
    fn from(value: &GraticuleTransform) -> Self {
        value.clone()
    }
}
#[doc = "`GraticuleTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformExtent {
    Variant0([::serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformExtent {
    fn from(value: &GraticuleTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[::serde_json::Value; 2usize]> for GraticuleTransformExtent {
    fn from(value: [::serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformExtentMajor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMajor {
    Variant0([::serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformExtentMajor {
    fn from(value: &GraticuleTransformExtentMajor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[::serde_json::Value; 2usize]> for GraticuleTransformExtentMajor {
    fn from(value: [::serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformExtentMajor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformExtentMinor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMinor {
    Variant0([::serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformExtentMinor {
    fn from(value: &GraticuleTransformExtentMinor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[::serde_json::Value; 2usize]> for GraticuleTransformExtentMinor {
    fn from(value: [::serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformExtentMinor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformPrecision`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 2.5,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformPrecision {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformPrecision {
    fn from(value: &GraticuleTransformPrecision) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GraticuleTransformPrecision {
    fn default() -> Self {
        GraticuleTransformPrecision::Variant0(2.5_f64)
    }
}
impl ::std::convert::From<f64> for GraticuleTransformPrecision {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformPrecision {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStep {
    Variant0([GraticuleTransformStepVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStep {
    fn from(value: &GraticuleTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[GraticuleTransformStepVariant0Item; 2usize]> for GraticuleTransformStep {
    fn from(value: [GraticuleTransformStepVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStepMajor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    90,"]
#[doc = "    360"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajor {
    Variant0([GraticuleTransformStepMajorVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStepMajor {
    fn from(value: &GraticuleTransformStepMajor) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GraticuleTransformStepMajor {
    fn default() -> Self {
        GraticuleTransformStepMajor::Variant0([
            GraticuleTransformStepMajorVariant0Item::Variant0(90_f64),
            GraticuleTransformStepMajorVariant0Item::Variant0(360_f64),
        ])
    }
}
impl ::std::convert::From<[GraticuleTransformStepMajorVariant0Item; 2usize]>
    for GraticuleTransformStepMajor
{
    fn from(value: [GraticuleTransformStepMajorVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStepMajor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStepMajorVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajorVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: &GraticuleTransformStepMajorVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStepMinor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    10,"]
#[doc = "    10"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinor {
    Variant0([GraticuleTransformStepMinorVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStepMinor {
    fn from(value: &GraticuleTransformStepMinor) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GraticuleTransformStepMinor {
    fn default() -> Self {
        GraticuleTransformStepMinor::Variant0([
            GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
            GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
        ])
    }
}
impl ::std::convert::From<[GraticuleTransformStepMinorVariant0Item; 2usize]>
    for GraticuleTransformStepMinor
{
    fn from(value: [GraticuleTransformStepMinorVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStepMinor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStepMinorVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinorVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: &GraticuleTransformStepMinorVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformStepVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum GraticuleTransformStepVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for GraticuleTransformStepVariant0Item {
    fn from(value: &GraticuleTransformStepVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for GraticuleTransformStepVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for GraticuleTransformStepVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`GraticuleTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"graticule\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GraticuleTransformType {
    #[serde(rename = "graticule")]
    Graticule,
}
impl ::std::convert::From<&Self> for GraticuleTransformType {
    fn from(value: &GraticuleTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GraticuleTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Graticule => write!(f, "graticule"),
        }
    }
}
impl ::std::str::FromStr for GraticuleTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "graticule" => Ok(Self::Graticule),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GuideEncode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"interactive\": {"]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"style\": {"]
#[doc = "      \"$ref\": \"#/definitions/style\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"patternProperties\": {"]
#[doc = "    \"^(?!interactive|name|style).+$\": {"]
#[doc = "      \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct GuideEncode {
    #[serde(default)]
    pub interactive: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub style: ::std::option::Option<Style>,
}
impl ::std::convert::From<&GuideEncode> for GuideEncode {
    fn from(value: &GuideEncode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GuideEncode {
    fn default() -> Self {
        Self {
            interactive: Default::default(),
            name: Default::default(),
            style: Default::default(),
        }
    }
}
#[doc = "`HeatmapTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"image\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"color\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"opacity\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct HeatmapTransform {
    #[serde(rename = "as", default = "defaults::heatmap_transform_as")]
    pub as_: HeatmapTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub color: ::std::option::Option<HeatmapTransformColor>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<HeatmapTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub opacity: ::std::option::Option<HeatmapTransformOpacity>,
    #[serde(default = "defaults::heatmap_transform_resolve")]
    pub resolve: HeatmapTransformResolve,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: HeatmapTransformType,
}
impl ::std::convert::From<&HeatmapTransform> for HeatmapTransform {
    fn from(value: &HeatmapTransform) -> Self {
        value.clone()
    }
}
#[doc = "`HeatmapTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"image\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum HeatmapTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for HeatmapTransformAs {
    fn from(value: &HeatmapTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for HeatmapTransformAs {
    fn default() -> Self {
        HeatmapTransformAs::Variant0("image".to_string())
    }
}
impl ::std::convert::From<SignalRef> for HeatmapTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`HeatmapTransformColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum HeatmapTransformColor {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for HeatmapTransformColor {
    fn from(value: &HeatmapTransformColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for HeatmapTransformColor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for HeatmapTransformColor {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for HeatmapTransformColor {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`HeatmapTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum HeatmapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for HeatmapTransformField {
    fn from(value: &HeatmapTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for HeatmapTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for HeatmapTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for HeatmapTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`HeatmapTransformOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum HeatmapTransformOpacity {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for HeatmapTransformOpacity {
    fn from(value: &HeatmapTransformOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for HeatmapTransformOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for HeatmapTransformOpacity {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for HeatmapTransformOpacity {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for HeatmapTransformOpacity {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`HeatmapTransformResolve`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum HeatmapTransformResolve {
    Variant0(HeatmapTransformResolveVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for HeatmapTransformResolve {
    fn from(value: &HeatmapTransformResolve) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for HeatmapTransformResolve {
    fn default() -> Self {
        HeatmapTransformResolve::Variant0(HeatmapTransformResolveVariant0::Independent)
    }
}
impl ::std::convert::From<HeatmapTransformResolveVariant0> for HeatmapTransformResolve {
    fn from(value: HeatmapTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for HeatmapTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`HeatmapTransformResolveVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HeatmapTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ::std::convert::From<&Self> for HeatmapTransformResolveVariant0 {
    fn from(value: &HeatmapTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HeatmapTransformResolveVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Shared => write!(f, "shared"),
            Self::Independent => write!(f, "independent"),
        }
    }
}
impl ::std::str::FromStr for HeatmapTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`HeatmapTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum HeatmapTransformType {
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for HeatmapTransformType {
    fn from(value: &HeatmapTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for HeatmapTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for HeatmapTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IdentifierTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"as\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IdentifierTransform {
    #[serde(rename = "as")]
    pub as_: IdentifierTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: IdentifierTransformType,
}
impl ::std::convert::From<&IdentifierTransform> for IdentifierTransform {
    fn from(value: &IdentifierTransform) -> Self {
        value.clone()
    }
}
#[doc = "`IdentifierTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IdentifierTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IdentifierTransformAs {
    fn from(value: &IdentifierTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for IdentifierTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IdentifierTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IdentifierTransformType {
    #[serde(rename = "identifier")]
    Identifier,
}
impl ::std::convert::From<&Self> for IdentifierTransformType {
    fn from(value: &IdentifierTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IdentifierTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Identifier => write!(f, "identifier"),
        }
    }
}
impl ::std::str::FromStr for IdentifierTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "identifier" => Ok(Self::Identifier),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ImputeTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"key\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"keyvals\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"value\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"value\","]
#[doc = "            \"mean\","]
#[doc = "            \"median\","]
#[doc = "            \"max\","]
#[doc = "            \"min\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"impute\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"value\": {}"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ImputeTransform {
    pub field: ImputeTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<ImputeTransformGroupby>,
    pub key: ImputeTransformKey,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub keyvals: ::std::option::Option<ImputeTransformKeyvals>,
    #[serde(default = "defaults::impute_transform_method")]
    pub method: ImputeTransformMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ImputeTransformType,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub value: ::std::option::Option<::serde_json::Value>,
}
impl ::std::convert::From<&ImputeTransform> for ImputeTransform {
    fn from(value: &ImputeTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ImputeTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ImputeTransformField {
    fn from(value: &ImputeTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ImputeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ImputeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ImputeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ImputeTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformGroupby {
    Variant0(::std::vec::Vec<ImputeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ImputeTransformGroupby {
    fn from(value: &ImputeTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ImputeTransformGroupbyVariant0Item>>
    for ImputeTransformGroupby
{
    fn from(value: ::std::vec::Vec<ImputeTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ImputeTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ImputeTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ImputeTransformGroupbyVariant0Item {
    fn from(value: &ImputeTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ImputeTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ImputeTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ImputeTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ImputeTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ImputeTransformKey {
    fn from(value: &ImputeTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ImputeTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ImputeTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ImputeTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ImputeTransformKeyvals`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformKeyvals {
    Variant0(::std::vec::Vec<::serde_json::Value>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ImputeTransformKeyvals {
    fn from(value: &ImputeTransformKeyvals) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ImputeTransformKeyvals {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ImputeTransformKeyvals {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ImputeTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"value\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"value\","]
#[doc = "        \"mean\","]
#[doc = "        \"median\","]
#[doc = "        \"max\","]
#[doc = "        \"min\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ImputeTransformMethod {
    Variant0(ImputeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ImputeTransformMethod {
    fn from(value: &ImputeTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for ImputeTransformMethod {
    fn default() -> Self {
        ImputeTransformMethod::Variant0(ImputeTransformMethodVariant0::Value)
    }
}
impl ::std::convert::From<ImputeTransformMethodVariant0> for ImputeTransformMethod {
    fn from(value: ImputeTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ImputeTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ImputeTransformMethodVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"value\","]
#[doc = "    \"mean\","]
#[doc = "    \"median\","]
#[doc = "    \"max\","]
#[doc = "    \"min\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ImputeTransformMethodVariant0 {
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "min")]
    Min,
}
impl ::std::convert::From<&Self> for ImputeTransformMethodVariant0 {
    fn from(value: &ImputeTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ImputeTransformMethodVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Value => write!(f, "value"),
            Self::Mean => write!(f, "mean"),
            Self::Median => write!(f, "median"),
            Self::Max => write!(f, "max"),
            Self::Min => write!(f, "min"),
        }
    }
}
impl ::std::str::FromStr for ImputeTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "value" => Ok(Self::Value),
            "mean" => Ok(Self::Mean),
            "median" => Ok(Self::Median),
            "max" => Ok(Self::Max),
            "min" => Ok(Self::Min),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ImputeTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"impute\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ImputeTransformType {
    #[serde(rename = "impute")]
    Impute,
}
impl ::std::convert::From<&Self> for ImputeTransformType {
    fn from(value: &ImputeTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ImputeTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Impute => write!(f, "impute"),
        }
    }
}
impl ::std::str::FromStr for ImputeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "impute" => Ok(Self::Impute),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IsocontourTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"contour\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"levels\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"thresholds\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"isocontour\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"zero\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct IsocontourTransform {
    #[serde(rename = "as", default = "defaults::isocontour_transform_as")]
    pub as_: IsocontourTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<IsocontourTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub levels: ::std::option::Option<IsocontourTransformLevels>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub nice: ::std::option::Option<IsocontourTransformNice>,
    #[serde(default = "defaults::isocontour_transform_resolve")]
    pub resolve: IsocontourTransformResolve,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub scale: ::std::option::Option<IsocontourTransformScale>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default = "defaults::isocontour_transform_smooth")]
    pub smooth: IsocontourTransformSmooth,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub thresholds: ::std::option::Option<IsocontourTransformThresholds>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub translate: ::std::option::Option<IsocontourTransformTranslate>,
    #[serde(rename = "type")]
    pub type_: IsocontourTransformType,
    #[serde(default = "defaults::isocontour_transform_zero")]
    pub zero: IsocontourTransformZero,
}
impl ::std::convert::From<&IsocontourTransform> for IsocontourTransform {
    fn from(value: &IsocontourTransform) -> Self {
        value.clone()
    }
}
#[doc = "`IsocontourTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"contour\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for IsocontourTransformAs {
    fn from(value: &IsocontourTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IsocontourTransformAs {
    fn default() -> Self {
        IsocontourTransformAs::Variant0("contour".to_string())
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for IsocontourTransformField {
    fn from(value: &IsocontourTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for IsocontourTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for IsocontourTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for IsocontourTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`IsocontourTransformLevels`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformLevels {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformLevels {
    fn from(value: &IsocontourTransformLevels) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for IsocontourTransformLevels {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformLevels {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformNice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformNice {
    fn from(value: &IsocontourTransformNice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for IsocontourTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformResolve`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformResolve {
    Variant0(IsocontourTransformResolveVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformResolve {
    fn from(value: &IsocontourTransformResolve) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IsocontourTransformResolve {
    fn default() -> Self {
        IsocontourTransformResolve::Variant0(IsocontourTransformResolveVariant0::Independent)
    }
}
impl ::std::convert::From<IsocontourTransformResolveVariant0> for IsocontourTransformResolve {
    fn from(value: IsocontourTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformResolveVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IsocontourTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ::std::convert::From<&Self> for IsocontourTransformResolveVariant0 {
    fn from(value: &IsocontourTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IsocontourTransformResolveVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Shared => write!(f, "shared"),
            Self::Independent => write!(f, "independent"),
        }
    }
}
impl ::std::str::FromStr for IsocontourTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IsocontourTransformScale`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformScale {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for IsocontourTransformScale {
    fn from(value: &IsocontourTransformScale) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for IsocontourTransformScale {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformScale {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for IsocontourTransformScale {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for IsocontourTransformScale {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`IsocontourTransformSmooth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformSmooth {
    fn from(value: &IsocontourTransformSmooth) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IsocontourTransformSmooth {
    fn default() -> Self {
        IsocontourTransformSmooth::Variant0(true)
    }
}
impl ::std::convert::From<bool> for IsocontourTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformThresholds`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformThresholds {
    Variant0(::std::vec::Vec<IsocontourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformThresholds {
    fn from(value: &IsocontourTransformThresholds) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<IsocontourTransformThresholdsVariant0Item>>
    for IsocontourTransformThresholds
{
    fn from(value: ::std::vec::Vec<IsocontourTransformThresholdsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformThresholds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformThresholdsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: &IsocontourTransformThresholdsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformTranslate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformTranslate {
    Variant0(::std::vec::Vec<IsocontourTransformTranslateVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformTranslate {
    fn from(value: &IsocontourTransformTranslate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<IsocontourTransformTranslateVariant0Item>>
    for IsocontourTransformTranslate
{
    fn from(value: ::std::vec::Vec<IsocontourTransformTranslateVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformTranslate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`IsocontourTransformTranslateVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformTranslateVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for IsocontourTransformTranslateVariant0Item {
    fn from(value: &IsocontourTransformTranslateVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for IsocontourTransformTranslateVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformTranslateVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for IsocontourTransformTranslateVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for IsocontourTransformTranslateVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`IsocontourTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"isocontour\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum IsocontourTransformType {
    #[serde(rename = "isocontour")]
    Isocontour,
}
impl ::std::convert::From<&Self> for IsocontourTransformType {
    fn from(value: &IsocontourTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for IsocontourTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Isocontour => write!(f, "isocontour"),
        }
    }
}
impl ::std::str::FromStr for IsocontourTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "isocontour" => Ok(Self::Isocontour),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`IsocontourTransformZero`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum IsocontourTransformZero {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for IsocontourTransformZero {
    fn from(value: &IsocontourTransformZero) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for IsocontourTransformZero {
    fn default() -> Self {
        IsocontourTransformZero::Variant0(true)
    }
}
impl ::std::convert::From<bool> for IsocontourTransformZero {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for IsocontourTransformZero {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"joinaggregate\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct JoinaggregateTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<JoinaggregateTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<JoinaggregateTransformFields>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<JoinaggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<JoinaggregateTransformKey>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ops: ::std::option::Option<JoinaggregateTransformOps>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: JoinaggregateTransformType,
}
impl ::std::convert::From<&JoinaggregateTransform> for JoinaggregateTransform {
    fn from(value: &JoinaggregateTransform) -> Self {
        value.clone()
    }
}
#[doc = "`JoinaggregateTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformAs {
    Variant0(::std::vec::Vec<JoinaggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformAs {
    fn from(value: &JoinaggregateTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<JoinaggregateTransformAsVariant0Item>>
    for JoinaggregateTransformAs
{
    fn from(value: ::std::vec::Vec<JoinaggregateTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for JoinaggregateTransformAsVariant0Item {
    fn from(value: &JoinaggregateTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformFields {
    Variant0(::std::vec::Vec<JoinaggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformFields {
    fn from(value: &JoinaggregateTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<JoinaggregateTransformFieldsVariant0Item>>
    for JoinaggregateTransformFields
{
    fn from(value: ::std::vec::Vec<JoinaggregateTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl ::std::convert::From<&Self> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: &JoinaggregateTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ParamField> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`JoinaggregateTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupby {
    Variant0(::std::vec::Vec<JoinaggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformGroupby {
    fn from(value: &JoinaggregateTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<JoinaggregateTransformGroupbyVariant0Item>>
    for JoinaggregateTransformGroupby
{
    fn from(value: ::std::vec::Vec<JoinaggregateTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: &JoinaggregateTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`JoinaggregateTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformKey {
    fn from(value: &JoinaggregateTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for JoinaggregateTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for JoinaggregateTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for JoinaggregateTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`JoinaggregateTransformOps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformOps {
    Variant0(::std::vec::Vec<JoinaggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformOps {
    fn from(value: &JoinaggregateTransformOps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<JoinaggregateTransformOpsVariant0Item>>
    for JoinaggregateTransformOps
{
    fn from(value: ::std::vec::Vec<JoinaggregateTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformOpsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JoinaggregateTransformOpsVariant0Item {
    Variant0(JoinaggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: &JoinaggregateTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<JoinaggregateTransformOpsVariant0ItemVariant0>
    for JoinaggregateTransformOpsVariant0Item
{
    fn from(value: JoinaggregateTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`JoinaggregateTransformOpsVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JoinaggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    XXcountXx,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ::std::convert::From<&Self> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn from(value: &JoinaggregateTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Values => write!(f, "values"),
            Self::Count => write!(f, "count"),
            Self::XXcountXx => write!(f, "__count__"),
            Self::Missing => write!(f, "missing"),
            Self::Valid => write!(f, "valid"),
            Self::Sum => write!(f, "sum"),
            Self::Product => write!(f, "product"),
            Self::Mean => write!(f, "mean"),
            Self::Average => write!(f, "average"),
            Self::Variance => write!(f, "variance"),
            Self::Variancep => write!(f, "variancep"),
            Self::Stdev => write!(f, "stdev"),
            Self::Stdevp => write!(f, "stdevp"),
            Self::Stderr => write!(f, "stderr"),
            Self::Distinct => write!(f, "distinct"),
            Self::Ci0 => write!(f, "ci0"),
            Self::Ci1 => write!(f, "ci1"),
            Self::Median => write!(f, "median"),
            Self::Q1 => write!(f, "q1"),
            Self::Q3 => write!(f, "q3"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
            Self::Argmin => write!(f, "argmin"),
            Self::Argmax => write!(f, "argmax"),
        }
    }
}
impl ::std::str::FromStr for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::XXcountXx),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JoinaggregateTransformOpsVariant0ItemVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JoinaggregateTransformOpsVariant0ItemVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JoinaggregateTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"joinaggregate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JoinaggregateTransformType {
    #[serde(rename = "joinaggregate")]
    Joinaggregate,
}
impl ::std::convert::From<&Self> for JoinaggregateTransformType {
    fn from(value: &JoinaggregateTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JoinaggregateTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Joinaggregate => write!(f, "joinaggregate"),
        }
    }
}
impl ::std::str::FromStr for JoinaggregateTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "joinaggregate" => Ok(Self::Joinaggregate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Kde2dTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"grid\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cellSize\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"counts\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"kde2d\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"weight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct Kde2dTransform {
    #[serde(rename = "as", default = "defaults::kde2d_transform_as")]
    pub as_: Kde2dTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bandwidth: ::std::option::Option<Kde2dTransformBandwidth>,
    #[serde(
        rename = "cellSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub cell_size: ::std::option::Option<Kde2dTransformCellSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub counts: ::std::option::Option<Kde2dTransformCounts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<Kde2dTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    pub size: Kde2dTransformSize,
    #[serde(rename = "type")]
    pub type_: Kde2dTransformType,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub weight: ::std::option::Option<Kde2dTransformWeight>,
    pub x: Kde2dTransformX,
    pub y: Kde2dTransformY,
}
impl ::std::convert::From<&Kde2dTransform> for Kde2dTransform {
    fn from(value: &Kde2dTransform) -> Self {
        value.clone()
    }
}
#[doc = "`Kde2dTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"grid\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformAs {
    fn from(value: &Kde2dTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Kde2dTransformAs {
    fn default() -> Self {
        Kde2dTransformAs::Variant0("grid".to_string())
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformBandwidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidth {
    Variant0([Kde2dTransformBandwidthVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformBandwidth {
    fn from(value: &Kde2dTransformBandwidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[Kde2dTransformBandwidthVariant0Item; 2usize]>
    for Kde2dTransformBandwidth
{
    fn from(value: [Kde2dTransformBandwidthVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformBandwidthVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidthVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: &Kde2dTransformBandwidthVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformCellSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformCellSize {
    fn from(value: &Kde2dTransformCellSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for Kde2dTransformCellSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformCellSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformCounts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformCounts {
    fn from(value: &Kde2dTransformCounts) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for Kde2dTransformCounts {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformCounts {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformGroupby {
    Variant0(::std::vec::Vec<Kde2dTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformGroupby {
    fn from(value: &Kde2dTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<Kde2dTransformGroupbyVariant0Item>>
    for Kde2dTransformGroupby
{
    fn from(value: ::std::vec::Vec<Kde2dTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: &Kde2dTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`Kde2dTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformSize {
    Variant0([Kde2dTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformSize {
    fn from(value: &Kde2dTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[Kde2dTransformSizeVariant0Item; 2usize]> for Kde2dTransformSize {
    fn from(value: [Kde2dTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Kde2dTransformSizeVariant0Item {
    fn from(value: &Kde2dTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for Kde2dTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Kde2dTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Kde2dTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"kde2d\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Kde2dTransformType {
    #[serde(rename = "kde2d")]
    Kde2d,
}
impl ::std::convert::From<&Self> for Kde2dTransformType {
    fn from(value: &Kde2dTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Kde2dTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Kde2d => write!(f, "kde2d"),
        }
    }
}
impl ::std::str::FromStr for Kde2dTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "kde2d" => Ok(Self::Kde2d),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Kde2dTransformWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for Kde2dTransformWeight {
    fn from(value: &Kde2dTransformWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for Kde2dTransformWeight {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for Kde2dTransformWeight {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for Kde2dTransformWeight {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`Kde2dTransformX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for Kde2dTransformX {
    fn from(value: &Kde2dTransformX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for Kde2dTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for Kde2dTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for Kde2dTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`Kde2dTransformY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Kde2dTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for Kde2dTransformY {
    fn from(value: &Kde2dTransformY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for Kde2dTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for Kde2dTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for Kde2dTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`KdeTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"value\","]
#[doc = "        \"density\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"counts\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cumulative\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxsteps\": {"]
#[doc = "      \"default\": 200,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minsteps\": {"]
#[doc = "      \"default\": 25,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"kde\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct KdeTransform {
    #[serde(rename = "as", default = "defaults::kde_transform_as")]
    pub as_: KdeTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bandwidth: ::std::option::Option<KdeTransformBandwidth>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub counts: ::std::option::Option<KdeTransformCounts>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cumulative: ::std::option::Option<KdeTransformCumulative>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<KdeTransformExtent>,
    pub field: KdeTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<KdeTransformGroupby>,
    #[serde(default = "defaults::kde_transform_maxsteps")]
    pub maxsteps: KdeTransformMaxsteps,
    #[serde(default = "defaults::kde_transform_minsteps")]
    pub minsteps: KdeTransformMinsteps,
    #[serde(default = "defaults::kde_transform_resolve")]
    pub resolve: KdeTransformResolve,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub steps: ::std::option::Option<KdeTransformSteps>,
    #[serde(rename = "type")]
    pub type_: KdeTransformType,
}
impl ::std::convert::From<&KdeTransform> for KdeTransform {
    fn from(value: &KdeTransform) -> Self {
        value.clone()
    }
}
#[doc = "`KdeTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"value\","]
#[doc = "    \"density\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformAs {
    Variant0(::std::vec::Vec<KdeTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformAs {
    fn from(value: &KdeTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for KdeTransformAs {
    fn default() -> Self {
        KdeTransformAs::Variant0(vec![
            KdeTransformAsVariant0Item::Variant0("value".to_string()),
            KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<KdeTransformAsVariant0Item>> for KdeTransformAs {
    fn from(value: ::std::vec::Vec<KdeTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformAsVariant0Item {
    fn from(value: &KdeTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformBandwidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformBandwidth {
    fn from(value: &KdeTransformBandwidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for KdeTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformCounts`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformCounts {
    fn from(value: &KdeTransformCounts) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for KdeTransformCounts {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformCounts {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformCumulative`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformCumulative {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformCumulative {
    fn from(value: &KdeTransformCumulative) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for KdeTransformCumulative {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformCumulative {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformExtent {
    Variant0([KdeTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformExtent {
    fn from(value: &KdeTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[KdeTransformExtentVariant0Item; 2usize]> for KdeTransformExtent {
    fn from(value: [KdeTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformExtentVariant0Item {
    fn from(value: &KdeTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for KdeTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for KdeTransformField {
    fn from(value: &KdeTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for KdeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for KdeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for KdeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`KdeTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformGroupby {
    Variant0(::std::vec::Vec<KdeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformGroupby {
    fn from(value: &KdeTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<KdeTransformGroupbyVariant0Item>>
    for KdeTransformGroupby
{
    fn from(value: ::std::vec::Vec<KdeTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for KdeTransformGroupbyVariant0Item {
    fn from(value: &KdeTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for KdeTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for KdeTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for KdeTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`KdeTransformMaxsteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 200,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformMaxsteps {
    fn from(value: &KdeTransformMaxsteps) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for KdeTransformMaxsteps {
    fn default() -> Self {
        KdeTransformMaxsteps::Variant0(200_f64)
    }
}
impl ::std::convert::From<f64> for KdeTransformMaxsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformMaxsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformMinsteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 25,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformMinsteps {
    fn from(value: &KdeTransformMinsteps) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for KdeTransformMinsteps {
    fn default() -> Self {
        KdeTransformMinsteps::Variant0(25_f64)
    }
}
impl ::std::convert::From<f64> for KdeTransformMinsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformMinsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformResolve`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformResolve {
    Variant0(KdeTransformResolveVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformResolve {
    fn from(value: &KdeTransformResolve) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for KdeTransformResolve {
    fn default() -> Self {
        KdeTransformResolve::Variant0(KdeTransformResolveVariant0::Independent)
    }
}
impl ::std::convert::From<KdeTransformResolveVariant0> for KdeTransformResolve {
    fn from(value: KdeTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformResolveVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum KdeTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl ::std::convert::From<&Self> for KdeTransformResolveVariant0 {
    fn from(value: &KdeTransformResolveVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for KdeTransformResolveVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Shared => write!(f, "shared"),
            Self::Independent => write!(f, "independent"),
        }
    }
}
impl ::std::str::FromStr for KdeTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`KdeTransformSteps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum KdeTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for KdeTransformSteps {
    fn from(value: &KdeTransformSteps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for KdeTransformSteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for KdeTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`KdeTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"kde\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum KdeTransformType {
    #[serde(rename = "kde")]
    Kde,
}
impl ::std::convert::From<&Self> for KdeTransformType {
    fn from(value: &KdeTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for KdeTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Kde => write!(f, "kde"),
        }
    }
}
impl ::std::str::FromStr for KdeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LabelOverlap`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"parity\","]
#[doc = "        \"greedy\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelOverlap {
    Variant0(bool),
    Variant1(LabelOverlapVariant1),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LabelOverlap {
    fn from(value: &LabelOverlap) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for LabelOverlap {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<LabelOverlapVariant1> for LabelOverlap {
    fn from(value: LabelOverlapVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelOverlap {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LabelOverlapVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"parity\","]
#[doc = "    \"greedy\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LabelOverlapVariant1 {
    #[serde(rename = "parity")]
    Parity,
    #[serde(rename = "greedy")]
    Greedy,
}
impl ::std::convert::From<&Self> for LabelOverlapVariant1 {
    fn from(value: &LabelOverlapVariant1) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LabelOverlapVariant1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Parity => write!(f, "parity"),
            Self::Greedy => write!(f, "greedy"),
        }
    }
}
impl ::std::str::FromStr for LabelOverlapVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "parity" => Ok(Self::Parity),
            "greedy" => Ok(Self::Greedy),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LabelTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"anchor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"top-left\","]
#[doc = "        \"left\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-right\","]
#[doc = "        \"right\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"opacity\","]
#[doc = "        \"align\","]
#[doc = "        \"baseline\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 5,"]
#[doc = "          \"minItems\": 5"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"avoidBaseMark\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"avoidMarks\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"lineAnchor\": {"]
#[doc = "      \"default\": \"end\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"markIndex\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"naive\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"default\": ["]
#[doc = "        1"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"label\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LabelTransform {
    #[serde(default = "defaults::label_transform_anchor")]
    pub anchor: LabelTransformAnchor,
    #[serde(rename = "as", default = "defaults::label_transform_as")]
    pub as_: LabelTransformAs,
    #[serde(
        rename = "avoidBaseMark",
        default = "defaults::label_transform_avoid_base_mark"
    )]
    pub avoid_base_mark: LabelTransformAvoidBaseMark,
    #[serde(
        rename = "avoidMarks",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub avoid_marks: ::std::option::Option<LabelTransformAvoidMarks>,
    #[serde(
        rename = "lineAnchor",
        default = "defaults::label_transform_line_anchor"
    )]
    pub line_anchor: LabelTransformLineAnchor,
    #[serde(
        rename = "markIndex",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub mark_index: ::std::option::Option<LabelTransformMarkIndex>,
    #[serde(default = "defaults::label_transform_method")]
    pub method: LabelTransformMethod,
    #[serde(default = "defaults::label_transform_offset")]
    pub offset: LabelTransformOffset,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<LabelTransformPadding>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    pub size: LabelTransformSize,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: LabelTransformType,
}
impl ::std::convert::From<&LabelTransform> for LabelTransform {
    fn from(value: &LabelTransform) -> Self {
        value.clone()
    }
}
#[doc = "`LabelTransformAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"top-left\","]
#[doc = "    \"left\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-right\","]
#[doc = "    \"right\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAnchor {
    Variant0(::std::vec::Vec<LabelTransformAnchorVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAnchor {
    fn from(value: &LabelTransformAnchor) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformAnchor {
    fn default() -> Self {
        LabelTransformAnchor::Variant0(vec![
            LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<LabelTransformAnchorVariant0Item>>
    for LabelTransformAnchor
{
    fn from(value: ::std::vec::Vec<LabelTransformAnchorVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformAnchorVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAnchorVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAnchorVariant0Item {
    fn from(value: &LabelTransformAnchorVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAnchorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"opacity\","]
#[doc = "    \"align\","]
#[doc = "    \"baseline\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 5,"]
#[doc = "      \"minItems\": 5"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAs {
    Variant0([LabelTransformAsVariant0Item; 5usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAs {
    fn from(value: &LabelTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformAs {
    fn default() -> Self {
        LabelTransformAs::Variant0([
            LabelTransformAsVariant0Item::Variant0("x".to_string()),
            LabelTransformAsVariant0Item::Variant0("y".to_string()),
            LabelTransformAsVariant0Item::Variant0("opacity".to_string()),
            LabelTransformAsVariant0Item::Variant0("align".to_string()),
            LabelTransformAsVariant0Item::Variant0("baseline".to_string()),
        ])
    }
}
impl ::std::convert::From<[LabelTransformAsVariant0Item; 5usize]> for LabelTransformAs {
    fn from(value: [LabelTransformAsVariant0Item; 5usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAsVariant0Item {
    fn from(value: &LabelTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformAvoidBaseMark`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAvoidBaseMark {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAvoidBaseMark {
    fn from(value: &LabelTransformAvoidBaseMark) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformAvoidBaseMark {
    fn default() -> Self {
        LabelTransformAvoidBaseMark::Variant0(true)
    }
}
impl ::std::convert::From<bool> for LabelTransformAvoidBaseMark {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAvoidBaseMark {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformAvoidMarks`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformAvoidMarks {
    Variant0(::std::vec::Vec<::std::string::String>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformAvoidMarks {
    fn from(value: &LabelTransformAvoidMarks) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for LabelTransformAvoidMarks {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformAvoidMarks {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformLineAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"end\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformLineAnchor {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformLineAnchor {
    fn from(value: &LabelTransformLineAnchor) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformLineAnchor {
    fn default() -> Self {
        LabelTransformLineAnchor::Variant0("end".to_string())
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformLineAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformMarkIndex`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformMarkIndex {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformMarkIndex {
    fn from(value: &LabelTransformMarkIndex) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LabelTransformMarkIndex {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformMarkIndex {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"naive\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformMethod {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformMethod {
    fn from(value: &LabelTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformMethod {
    fn default() -> Self {
        LabelTransformMethod::Variant0("naive".to_string())
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    1"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformOffset {
    Variant0(::std::vec::Vec<LabelTransformOffsetVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformOffset {
    fn from(value: &LabelTransformOffset) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LabelTransformOffset {
    fn default() -> Self {
        LabelTransformOffset::Variant0(vec![LabelTransformOffsetVariant0Item::Variant0(1_f64)])
    }
}
impl ::std::convert::From<::std::vec::Vec<LabelTransformOffsetVariant0Item>>
    for LabelTransformOffset
{
    fn from(value: ::std::vec::Vec<LabelTransformOffsetVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformOffset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformOffsetVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformOffsetVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformOffsetVariant0Item {
    fn from(value: &LabelTransformOffsetVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LabelTransformOffsetVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformOffsetVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for LabelTransformPadding {
    fn from(value: &LabelTransformPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LabelTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformSize {
    Variant0([LabelTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformSize {
    fn from(value: &LabelTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[LabelTransformSizeVariant0Item; 2usize]> for LabelTransformSize {
    fn from(value: [LabelTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LabelTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LabelTransformSizeVariant0Item {
    fn from(value: &LabelTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LabelTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LabelTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LabelTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"label\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LabelTransformType {
    #[serde(rename = "label")]
    Label,
}
impl ::std::convert::From<&Self> for LabelTransformType {
    fn from(value: &LabelTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LabelTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Label => write!(f, "label"),
        }
    }
}
impl ::std::str::FromStr for LabelTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "label" => Ok(Self::Label),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Layout`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"all\","]
#[doc = "                    \"each\","]
#[doc = "                    \"none\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"all\","]
#[doc = "                        \"each\","]
#[doc = "                        \"none\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"all\","]
#[doc = "                        \"each\","]
#[doc = "                        \"none\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"bounds\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"full\","]
#[doc = "                \"flush\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"center\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"columns\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"footerBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"headerBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"columnFooter\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"columnHeader\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"columnTitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowFooter\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowHeader\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowTitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleAnchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"start\","]
#[doc = "                    \"end\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Layout {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        align: ::std::option::Option<LayoutVariant0Align>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bounds: ::std::option::Option<LayoutVariant0Bounds>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        center: ::std::option::Option<LayoutVariant0Center>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "footerBand",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        footer_band: ::std::option::Option<LayoutVariant0FooterBand>,
        #[serde(
            rename = "headerBand",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        header_band: ::std::option::Option<LayoutVariant0HeaderBand>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LayoutVariant0Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LayoutVariant0Padding>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LayoutVariant0TitleAnchor>,
        #[serde(
            rename = "titleBand",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_band: ::std::option::Option<LayoutVariant0TitleBand>,
    },
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for Layout {
    fn from(value: &Layout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for Layout {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0Align`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"all\","]
#[doc = "            \"each\","]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Align {
    Variant0(LayoutVariant0AlignVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<LayoutVariant0AlignVariant1Column>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<LayoutVariant0AlignVariant1Row>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0Align {
    fn from(value: &LayoutVariant0Align) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0AlignVariant0> for LayoutVariant0Align {
    fn from(value: LayoutVariant0AlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`LayoutVariant0AlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant0 {
    Variant0(LayoutVariant0AlignVariant0Variant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant0 {
    fn from(value: &LayoutVariant0AlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0AlignVariant0Variant0> for LayoutVariant0AlignVariant0 {
    fn from(value: LayoutVariant0AlignVariant0Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0AlignVariant0 {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0AlignVariant0Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0AlignVariant0Variant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant0Variant0 {
    fn from(value: &LayoutVariant0AlignVariant0Variant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0AlignVariant0Variant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0AlignVariant0Variant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0AlignVariant1Column`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Column {
    Variant0(LayoutVariant0AlignVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant1Column {
    fn from(value: &LayoutVariant0AlignVariant1Column) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0AlignVariant1ColumnVariant0>
    for LayoutVariant0AlignVariant1Column
{
    fn from(value: LayoutVariant0AlignVariant1ColumnVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0AlignVariant1Column {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0AlignVariant1ColumnVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0AlignVariant1ColumnVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn from(value: &LayoutVariant0AlignVariant1ColumnVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0AlignVariant1Row`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Row {
    Variant0(LayoutVariant0AlignVariant1RowVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant1Row {
    fn from(value: &LayoutVariant0AlignVariant1Row) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0AlignVariant1RowVariant0>
    for LayoutVariant0AlignVariant1Row
{
    fn from(value: LayoutVariant0AlignVariant1RowVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0AlignVariant1Row {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0AlignVariant1RowVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0AlignVariant1RowVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LayoutVariant0AlignVariant1RowVariant0 {
    fn from(value: &LayoutVariant0AlignVariant1RowVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0AlignVariant1RowVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0AlignVariant1RowVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0Bounds`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"full\","]
#[doc = "        \"flush\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0Bounds {
    Variant0(LayoutVariant0BoundsVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0Bounds {
    fn from(value: &LayoutVariant0Bounds) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0BoundsVariant0> for LayoutVariant0Bounds {
    fn from(value: LayoutVariant0BoundsVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0Bounds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0BoundsVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"full\","]
#[doc = "    \"flush\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0BoundsVariant0 {
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "flush")]
    Flush,
}
impl ::std::convert::From<&Self> for LayoutVariant0BoundsVariant0 {
    fn from(value: &LayoutVariant0BoundsVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0BoundsVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Full => write!(f, "full"),
            Self::Flush => write!(f, "flush"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0BoundsVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "full" => Ok(Self::Full),
            "flush" => Ok(Self::Flush),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0Center`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Center {
    Variant0(bool),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<BooleanOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0Center {
    fn from(value: &LayoutVariant0Center) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for LayoutVariant0Center {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0Center {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0FooterBand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0FooterBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0FooterBand {
    fn from(value: &LayoutVariant0FooterBand) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<NumberOrSignal> for LayoutVariant0FooterBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`LayoutVariant0HeaderBand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0HeaderBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0HeaderBand {
    fn from(value: &LayoutVariant0HeaderBand) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<NumberOrSignal> for LayoutVariant0HeaderBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`LayoutVariant0Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"columnFooter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnHeader\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnTitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowFooter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowHeader\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowTitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Offset {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(
            rename = "columnFooter",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_footer: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnHeader",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_header: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnTitle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_title: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "rowFooter",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_footer: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "rowHeader",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_header: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "rowTitle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_title: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0Offset {
    fn from(value: &LayoutVariant0Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LayoutVariant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0Offset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Padding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0Padding {
    fn from(value: &LayoutVariant0Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LayoutVariant0Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0Padding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"start\","]
#[doc = "            \"end\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleAnchor {
    Variant0(LayoutVariant0TitleAnchorVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<LayoutVariant0TitleAnchorVariant1Column>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<LayoutVariant0TitleAnchorVariant1Row>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchor {
    fn from(value: &LayoutVariant0TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0TitleAnchorVariant0> for LayoutVariant0TitleAnchor {
    fn from(value: LayoutVariant0TitleAnchorVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant0 {
    Variant0(LayoutVariant0TitleAnchorVariant0Variant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: &LayoutVariant0TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0TitleAnchorVariant0Variant0>
    for LayoutVariant0TitleAnchorVariant0
{
    fn from(value: LayoutVariant0TitleAnchorVariant0Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant0Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0TitleAnchorVariant0Variant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn from(value: &LayoutVariant0TitleAnchorVariant0Variant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant1Column`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Column {
    Variant0(LayoutVariant0TitleAnchorVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant1Column {
    fn from(value: &LayoutVariant0TitleAnchorVariant1Column) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0TitleAnchorVariant1ColumnVariant0>
    for LayoutVariant0TitleAnchorVariant1Column
{
    fn from(value: LayoutVariant0TitleAnchorVariant1ColumnVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0TitleAnchorVariant1Column {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant1ColumnVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn from(value: &LayoutVariant0TitleAnchorVariant1ColumnVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for LayoutVariant0TitleAnchorVariant1ColumnVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for LayoutVariant0TitleAnchorVariant1ColumnVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant1Row`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Row {
    Variant0(LayoutVariant0TitleAnchorVariant1RowVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: &LayoutVariant0TitleAnchorVariant1Row) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LayoutVariant0TitleAnchorVariant1RowVariant0>
    for LayoutVariant0TitleAnchorVariant1Row
{
    fn from(value: LayoutVariant0TitleAnchorVariant1RowVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LayoutVariant0TitleAnchorVariant1RowVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LayoutVariant0TitleAnchorVariant1RowVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn from(value: &LayoutVariant0TitleAnchorVariant1RowVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for LayoutVariant0TitleAnchorVariant1RowVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for LayoutVariant0TitleAnchorVariant1RowVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LayoutVariant0TitleBand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        column: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        row: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for LayoutVariant0TitleBand {
    fn from(value: &LayoutVariant0TitleBand) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<NumberOrSignal> for LayoutVariant0TitleBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`Legend`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"aria\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"clipHeight\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnPadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columns\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"cornerRadius\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"direction\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"vertical\","]
#[doc = "            \"horizontal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"encode\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"entries\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"gradient\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"labels\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"legend\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"symbols\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"fill\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fillColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"date\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"day\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"hours\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"milliseconds\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"minutes\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"month\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"quarter\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"seconds\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"week\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"year\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"formatType\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"number\","]
#[doc = "                \"time\","]
#[doc = "                \"utc\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientLength\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"gradientOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientStrokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientStrokeWidth\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientThickness\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"gridAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelBaseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelLimit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOverlap\": {"]
#[doc = "          \"$ref\": \"#/definitions/labelOverlap\""]
#[doc = "        },"]
#[doc = "        \"labelSeparation\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"legendX\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"legendY\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"opacity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"orient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"default\": \"right\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\","]
#[doc = "                \"top-left\","]
#[doc = "                \"top-right\","]
#[doc = "                \"bottom-left\","]
#[doc = "                \"bottom-right\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"rowPadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"shape\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"size\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"stroke\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strokeDash\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strokeWidth\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"symbolDash\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolDashOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolFillColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolLimit\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"symbolOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolStrokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolStrokeWidth\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolType\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tickCount\": {"]
#[doc = "          \"$ref\": \"#/definitions/tickCount\""]
#[doc = "        },"]
#[doc = "        \"tickMinStep\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"titleAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleAnchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleBaseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleLimit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleLineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleOrient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/orientValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titlePadding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"gradient\","]
#[doc = "            \"symbol\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"values\": {"]
#[doc = "          \"$ref\": \"#/definitions/arrayOrSignal\""]
#[doc = "        },"]
#[doc = "        \"zindex\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"size\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"shape\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"fill\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stroke\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"opacity\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"strokeDash\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"strokeWidth\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Legend {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant0CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant0Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant0Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant0FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant0Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant0FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant0GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant0GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant0GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant0GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant0LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant0LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant0LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant0LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant0LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant0LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant0LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant0LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant0LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant0LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant0LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant0LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant0Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant0Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant0Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        size: ::std::string::String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant0StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant0SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant0SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant0SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant0SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant0SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant0SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant0SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant0SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant0SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant0TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant0TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant0TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant0TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant0TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant0TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant0TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant0TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant0TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant0TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant0TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant0TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant0TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant0Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant1CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant1Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant1Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant1FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant1Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant1FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant1GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant1GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant1GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant1GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant1LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant1LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant1LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant1LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant1LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant1LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant1LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant1LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant1LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant1LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant1LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant1LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant1Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant1Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant1Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        shape: ::std::string::String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant1StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant1SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant1SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant1SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant1SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant1SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant1SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant1SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant1SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant1SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant1TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant1TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant1TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant1TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant1TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant1TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant1TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant1TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant1TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant1TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant1TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant1TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant1TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant1Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant2CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant2Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant2Encode>,
        fill: ::std::string::String,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant2FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant2Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant2FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant2GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant2GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant2GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant2GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant2LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant2LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant2LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant2LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant2LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant2LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant2LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant2LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant2LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant2LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant2LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant2LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant2Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant2Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant2Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant2StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant2SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant2SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant2SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant2SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant2SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant2SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant2SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant2SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant2SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant2TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant2TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant2TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant2TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant2TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant2TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant2TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant2TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant2TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant2TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant2TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant2TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant2TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant2Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant3CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant3Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant3Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant3FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant3Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant3FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant3GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant3GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant3GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant3GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant3LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant3LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant3LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant3LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant3LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant3LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant3LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant3LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant3LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant3LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant3LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant3LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant3Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant3Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant3Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        stroke: ::std::string::String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant3StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant3SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant3SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant3SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant3SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant3SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant3SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant3SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant3SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant3SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant3TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant3TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant3TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant3TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant3TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant3TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant3TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant3TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant3TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant3TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant3TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant3TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant3TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant3Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant4CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant4Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant4Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant4FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant4Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant4FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant4GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant4GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant4GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant4GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant4LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant4LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant4LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant4LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant4LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant4LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant4LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant4LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant4LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant4LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant4LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant4LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant4Offset>,
        opacity: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant4Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant4Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant4StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant4SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant4SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant4SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant4SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant4SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant4SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant4SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant4SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant4SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant4TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant4TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant4TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant4TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant4TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant4TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant4TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant4TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant4TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant4TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant4TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant4TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant4TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant4Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant5CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant5Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant5Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant5FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant5Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant5FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant5GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant5GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant5GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant5GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant5LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant5LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant5LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant5LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant5LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant5LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant5LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant5LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant5LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant5LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant5LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant5LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant5Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant5Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant5Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant5StrokeColor>,
        #[serde(rename = "strokeDash")]
        stroke_dash: ::std::string::String,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant5SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant5SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant5SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant5SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant5SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant5SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant5SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant5SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant5SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant5TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant5TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant5TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant5TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant5TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant5TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant5TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant5TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant5TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant5TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant5TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant5TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant5TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant5Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        clip_height: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        column_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        columns: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        corner_radius: ::std::option::Option<LegendVariant6CornerRadius>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        direction: ::std::option::Option<LegendVariant6Direction>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<LegendVariant6Encode>,
        #[serde(
            rename = "fillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        fill_color: ::std::option::Option<LegendVariant6FillColor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        format: ::std::option::Option<LegendVariant6Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        format_type: ::std::option::Option<LegendVariant6FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_length: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_opacity: ::std::option::Option<LegendVariant6GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_color: ::std::option::Option<LegendVariant6GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_stroke_width: ::std::option::Option<LegendVariant6GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        gradient_thickness: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "gridAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        grid_align: ::std::option::Option<LegendVariant6GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_align: ::std::option::Option<LegendVariant6LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_baseline: ::std::option::Option<LegendVariant6LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_color: ::std::option::Option<LegendVariant6LabelColor>,
        #[serde(
            rename = "labelFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font: ::std::option::Option<LegendVariant6LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_size: ::std::option::Option<LegendVariant6LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_style: ::std::option::Option<LegendVariant6LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_font_weight: ::std::option::Option<LegendVariant6LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_limit: ::std::option::Option<LegendVariant6LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_offset: ::std::option::Option<LegendVariant6LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_opacity: ::std::option::Option<LegendVariant6LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_overlap: ::std::option::Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        label_separation: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "legendX",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_x: ::std::option::Option<LegendVariant6LegendX>,
        #[serde(
            rename = "legendY",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        legend_y: ::std::option::Option<LegendVariant6LegendY>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<LegendVariant6Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<LegendVariant6Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<LegendVariant6Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        row_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        stroke_color: ::std::option::Option<LegendVariant6StrokeColor>,
        #[serde(rename = "strokeWidth")]
        stroke_width: ::std::string::String,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash: ::std::option::Option<LegendVariant6SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_dash_offset: ::std::option::Option<LegendVariant6SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_fill_color: ::std::option::Option<LegendVariant6SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_limit: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_offset: ::std::option::Option<LegendVariant6SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_opacity: ::std::option::Option<LegendVariant6SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_size: ::std::option::Option<LegendVariant6SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_color: ::std::option::Option<LegendVariant6SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_stroke_width: ::std::option::Option<LegendVariant6SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        symbol_type: ::std::option::Option<LegendVariant6SymbolType>,
        #[serde(
            rename = "tickCount",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_count: ::std::option::Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        tick_min_step: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        title: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_align: ::std::option::Option<LegendVariant6TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_anchor: ::std::option::Option<LegendVariant6TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_baseline: ::std::option::Option<LegendVariant6TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_color: ::std::option::Option<LegendVariant6TitleColor>,
        #[serde(
            rename = "titleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font: ::std::option::Option<LegendVariant6TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_size: ::std::option::Option<LegendVariant6TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_style: ::std::option::Option<LegendVariant6TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_font_weight: ::std::option::Option<LegendVariant6TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_limit: ::std::option::Option<LegendVariant6TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_line_height: ::std::option::Option<LegendVariant6TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_opacity: ::std::option::Option<LegendVariant6TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_orient: ::std::option::Option<LegendVariant6TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        title_padding: ::std::option::Option<LegendVariant6TitlePadding>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<LegendVariant6Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        values: ::std::option::Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
}
impl ::std::convert::From<&Self> for Legend {
    fn from(value: &Legend) -> Self {
        value.clone()
    }
}
#[doc = "`LegendVariant0CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0CornerRadius {
    fn from(value: &LegendVariant0CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant0Direction {
    fn from(value: &LegendVariant0Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant0Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant0Encode> for LegendVariant0Encode {
    fn from(value: &LegendVariant0Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant0Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant0FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0FillColor {
    fn from(value: &LegendVariant0FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant0Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant0Format {
    fn from(value: &LegendVariant0Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant0Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0FormatType {
    Variant0(LegendVariant0FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant0FormatType {
    fn from(value: &LegendVariant0FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0FormatTypeVariant0> for LegendVariant0FormatType {
    fn from(value: LegendVariant0FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant0FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant0FormatTypeVariant0 {
    fn from(value: &LegendVariant0FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0GradientOpacity {
    fn from(value: &LegendVariant0GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0GradientStrokeColor {
    fn from(value: &LegendVariant0GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0GradientStrokeWidth {
    fn from(value: &LegendVariant0GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0GridAlign {
    Variant0(LegendVariant0GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant0GridAlign {
    fn from(value: &LegendVariant0GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0GridAlignVariant0> for LegendVariant0GridAlign {
    fn from(value: LegendVariant0GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant0GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant0GridAlignVariant0 {
    fn from(value: &LegendVariant0GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelAlign {
    Variant0(LegendVariant0LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelAlign {
    fn from(value: &LegendVariant0LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0LabelAlignVariant0> for LegendVariant0LabelAlign {
    fn from(value: LegendVariant0LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant0LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant0LabelAlignVariant0 {
    fn from(value: &LegendVariant0LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelBaseline {
    Variant0(LegendVariant0LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelBaseline {
    fn from(value: &LegendVariant0LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0LabelBaselineVariant0> for LegendVariant0LabelBaseline {
    fn from(value: LegendVariant0LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant0LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant0LabelBaselineVariant0 {
    fn from(value: &LegendVariant0LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelColor {
    fn from(value: &LegendVariant0LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelFont {
    fn from(value: &LegendVariant0LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant0LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelFontSize {
    fn from(value: &LegendVariant0LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelFontStyle {
    fn from(value: &LegendVariant0LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant0LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelFontWeight {
    fn from(value: &LegendVariant0LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant0LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant0LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelLimit {
    fn from(value: &LegendVariant0LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelOffset {
    fn from(value: &LegendVariant0LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LabelOpacity {
    fn from(value: &LegendVariant0LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LegendX {
    fn from(value: &LegendVariant0LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0LegendY {
    fn from(value: &LegendVariant0LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0Offset {
    fn from(value: &LegendVariant0Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0Orient {
    Variant0(LegendVariant0OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant0Orient {
    fn from(value: &LegendVariant0Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0OrientVariant0> for LegendVariant0Orient {
    fn from(value: LegendVariant0OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant0Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant0OrientVariant0 {
    fn from(value: &LegendVariant0OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0Padding {
    fn from(value: &LegendVariant0Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0StrokeColor {
    fn from(value: &LegendVariant0StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolDash {
    fn from(value: &LegendVariant0SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant0SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant0SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolDashOffset {
    fn from(value: &LegendVariant0SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolFillColor {
    fn from(value: &LegendVariant0SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolOffset {
    fn from(value: &LegendVariant0SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolOpacity {
    fn from(value: &LegendVariant0SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolSize {
    fn from(value: &LegendVariant0SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolStrokeColor {
    fn from(value: &LegendVariant0SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolStrokeWidth {
    fn from(value: &LegendVariant0SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant0SymbolType {
    fn from(value: &LegendVariant0SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant0SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleAlign {
    Variant0(LegendVariant0TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleAlign {
    fn from(value: &LegendVariant0TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0TitleAlignVariant0> for LegendVariant0TitleAlign {
    fn from(value: LegendVariant0TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant0TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant0TitleAlignVariant0 {
    fn from(value: &LegendVariant0TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleAnchor {
    Variant0(::std::option::Option<LegendVariant0TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleAnchor {
    fn from(value: &LegendVariant0TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant0TitleAnchorVariant0>>
    for LegendVariant0TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant0TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant0TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant0TitleAnchorVariant0 {
    fn from(value: &LegendVariant0TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleBaseline {
    Variant0(LegendVariant0TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleBaseline {
    fn from(value: &LegendVariant0TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0TitleBaselineVariant0> for LegendVariant0TitleBaseline {
    fn from(value: LegendVariant0TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant0TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant0TitleBaselineVariant0 {
    fn from(value: &LegendVariant0TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleColor {
    fn from(value: &LegendVariant0TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant0TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant0TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleFont {
    fn from(value: &LegendVariant0TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant0TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleFontSize {
    fn from(value: &LegendVariant0TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleFontStyle {
    fn from(value: &LegendVariant0TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant0TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleFontWeight {
    fn from(value: &LegendVariant0TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant0TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant0TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleLimit {
    fn from(value: &LegendVariant0TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleLineHeight {
    fn from(value: &LegendVariant0TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleOpacity {
    fn from(value: &LegendVariant0TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitleOrient {
    Variant0(LegendVariant0TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitleOrient {
    fn from(value: &LegendVariant0TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant0TitleOrientVariant0> for LegendVariant0TitleOrient {
    fn from(value: LegendVariant0TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant0TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant0TitleOrientVariant0 {
    fn from(value: &LegendVariant0TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant0TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant0TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant0TitlePadding {
    fn from(value: &LegendVariant0TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant0TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant0TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant0Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant0Type {
    fn from(value: &LegendVariant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1CornerRadius {
    fn from(value: &LegendVariant1CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant1Direction {
    fn from(value: &LegendVariant1Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant1Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant1Encode> for LegendVariant1Encode {
    fn from(value: &LegendVariant1Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant1Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant1FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1FillColor {
    fn from(value: &LegendVariant1FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant1Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant1Format {
    fn from(value: &LegendVariant1Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant1Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1FormatType {
    Variant0(LegendVariant1FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant1FormatType {
    fn from(value: &LegendVariant1FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1FormatTypeVariant0> for LegendVariant1FormatType {
    fn from(value: LegendVariant1FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant1FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant1FormatTypeVariant0 {
    fn from(value: &LegendVariant1FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1GradientOpacity {
    fn from(value: &LegendVariant1GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1GradientStrokeColor {
    fn from(value: &LegendVariant1GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1GradientStrokeWidth {
    fn from(value: &LegendVariant1GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1GridAlign {
    Variant0(LegendVariant1GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant1GridAlign {
    fn from(value: &LegendVariant1GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1GridAlignVariant0> for LegendVariant1GridAlign {
    fn from(value: LegendVariant1GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant1GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant1GridAlignVariant0 {
    fn from(value: &LegendVariant1GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelAlign {
    Variant0(LegendVariant1LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelAlign {
    fn from(value: &LegendVariant1LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1LabelAlignVariant0> for LegendVariant1LabelAlign {
    fn from(value: LegendVariant1LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant1LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant1LabelAlignVariant0 {
    fn from(value: &LegendVariant1LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelBaseline {
    Variant0(LegendVariant1LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelBaseline {
    fn from(value: &LegendVariant1LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1LabelBaselineVariant0> for LegendVariant1LabelBaseline {
    fn from(value: LegendVariant1LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant1LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant1LabelBaselineVariant0 {
    fn from(value: &LegendVariant1LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelColor {
    fn from(value: &LegendVariant1LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelFont {
    fn from(value: &LegendVariant1LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant1LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelFontSize {
    fn from(value: &LegendVariant1LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelFontStyle {
    fn from(value: &LegendVariant1LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant1LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelFontWeight {
    fn from(value: &LegendVariant1LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant1LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant1LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelLimit {
    fn from(value: &LegendVariant1LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelOffset {
    fn from(value: &LegendVariant1LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LabelOpacity {
    fn from(value: &LegendVariant1LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LegendX {
    fn from(value: &LegendVariant1LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1LegendY {
    fn from(value: &LegendVariant1LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1Offset {
    fn from(value: &LegendVariant1Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1Orient {
    Variant0(LegendVariant1OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant1Orient {
    fn from(value: &LegendVariant1Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1OrientVariant0> for LegendVariant1Orient {
    fn from(value: LegendVariant1OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant1Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant1OrientVariant0 {
    fn from(value: &LegendVariant1OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1Padding {
    fn from(value: &LegendVariant1Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1StrokeColor {
    fn from(value: &LegendVariant1StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolDash {
    fn from(value: &LegendVariant1SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant1SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant1SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolDashOffset {
    fn from(value: &LegendVariant1SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolFillColor {
    fn from(value: &LegendVariant1SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolOffset {
    fn from(value: &LegendVariant1SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolOpacity {
    fn from(value: &LegendVariant1SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolSize {
    fn from(value: &LegendVariant1SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolStrokeColor {
    fn from(value: &LegendVariant1SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolStrokeWidth {
    fn from(value: &LegendVariant1SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant1SymbolType {
    fn from(value: &LegendVariant1SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant1SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleAlign {
    Variant0(LegendVariant1TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleAlign {
    fn from(value: &LegendVariant1TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1TitleAlignVariant0> for LegendVariant1TitleAlign {
    fn from(value: LegendVariant1TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant1TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant1TitleAlignVariant0 {
    fn from(value: &LegendVariant1TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleAnchor {
    Variant0(::std::option::Option<LegendVariant1TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleAnchor {
    fn from(value: &LegendVariant1TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant1TitleAnchorVariant0>>
    for LegendVariant1TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant1TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant1TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant1TitleAnchorVariant0 {
    fn from(value: &LegendVariant1TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleBaseline {
    Variant0(LegendVariant1TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleBaseline {
    fn from(value: &LegendVariant1TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1TitleBaselineVariant0> for LegendVariant1TitleBaseline {
    fn from(value: LegendVariant1TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant1TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant1TitleBaselineVariant0 {
    fn from(value: &LegendVariant1TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleColor {
    fn from(value: &LegendVariant1TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant1TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant1TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleFont {
    fn from(value: &LegendVariant1TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant1TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleFontSize {
    fn from(value: &LegendVariant1TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleFontStyle {
    fn from(value: &LegendVariant1TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant1TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleFontWeight {
    fn from(value: &LegendVariant1TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant1TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant1TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleLimit {
    fn from(value: &LegendVariant1TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleLineHeight {
    fn from(value: &LegendVariant1TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleOpacity {
    fn from(value: &LegendVariant1TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitleOrient {
    Variant0(LegendVariant1TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitleOrient {
    fn from(value: &LegendVariant1TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant1TitleOrientVariant0> for LegendVariant1TitleOrient {
    fn from(value: LegendVariant1TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant1TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant1TitleOrientVariant0 {
    fn from(value: &LegendVariant1TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant1TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant1TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant1TitlePadding {
    fn from(value: &LegendVariant1TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant1TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant1TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant1Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant1Type {
    fn from(value: &LegendVariant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2CornerRadius {
    fn from(value: &LegendVariant2CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant2Direction {
    fn from(value: &LegendVariant2Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant2Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant2Encode> for LegendVariant2Encode {
    fn from(value: &LegendVariant2Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant2Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant2FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2FillColor {
    fn from(value: &LegendVariant2FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant2Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant2Format {
    fn from(value: &LegendVariant2Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant2Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2FormatType {
    Variant0(LegendVariant2FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant2FormatType {
    fn from(value: &LegendVariant2FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2FormatTypeVariant0> for LegendVariant2FormatType {
    fn from(value: LegendVariant2FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant2FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant2FormatTypeVariant0 {
    fn from(value: &LegendVariant2FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2GradientOpacity {
    fn from(value: &LegendVariant2GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2GradientStrokeColor {
    fn from(value: &LegendVariant2GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2GradientStrokeWidth {
    fn from(value: &LegendVariant2GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2GridAlign {
    Variant0(LegendVariant2GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant2GridAlign {
    fn from(value: &LegendVariant2GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2GridAlignVariant0> for LegendVariant2GridAlign {
    fn from(value: LegendVariant2GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant2GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant2GridAlignVariant0 {
    fn from(value: &LegendVariant2GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelAlign {
    Variant0(LegendVariant2LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelAlign {
    fn from(value: &LegendVariant2LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2LabelAlignVariant0> for LegendVariant2LabelAlign {
    fn from(value: LegendVariant2LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant2LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant2LabelAlignVariant0 {
    fn from(value: &LegendVariant2LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelBaseline {
    Variant0(LegendVariant2LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelBaseline {
    fn from(value: &LegendVariant2LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2LabelBaselineVariant0> for LegendVariant2LabelBaseline {
    fn from(value: LegendVariant2LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant2LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant2LabelBaselineVariant0 {
    fn from(value: &LegendVariant2LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelColor {
    fn from(value: &LegendVariant2LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelFont {
    fn from(value: &LegendVariant2LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant2LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelFontSize {
    fn from(value: &LegendVariant2LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelFontStyle {
    fn from(value: &LegendVariant2LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant2LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelFontWeight {
    fn from(value: &LegendVariant2LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant2LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant2LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelLimit {
    fn from(value: &LegendVariant2LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelOffset {
    fn from(value: &LegendVariant2LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LabelOpacity {
    fn from(value: &LegendVariant2LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LegendX {
    fn from(value: &LegendVariant2LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2LegendY {
    fn from(value: &LegendVariant2LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2Offset {
    fn from(value: &LegendVariant2Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2Orient {
    Variant0(LegendVariant2OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant2Orient {
    fn from(value: &LegendVariant2Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2OrientVariant0> for LegendVariant2Orient {
    fn from(value: LegendVariant2OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant2Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant2OrientVariant0 {
    fn from(value: &LegendVariant2OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2Padding {
    fn from(value: &LegendVariant2Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2StrokeColor {
    fn from(value: &LegendVariant2StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolDash {
    fn from(value: &LegendVariant2SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant2SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant2SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolDashOffset {
    fn from(value: &LegendVariant2SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolFillColor {
    fn from(value: &LegendVariant2SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolOffset {
    fn from(value: &LegendVariant2SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolOpacity {
    fn from(value: &LegendVariant2SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolSize {
    fn from(value: &LegendVariant2SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolStrokeColor {
    fn from(value: &LegendVariant2SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolStrokeWidth {
    fn from(value: &LegendVariant2SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant2SymbolType {
    fn from(value: &LegendVariant2SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant2SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleAlign {
    Variant0(LegendVariant2TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleAlign {
    fn from(value: &LegendVariant2TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2TitleAlignVariant0> for LegendVariant2TitleAlign {
    fn from(value: LegendVariant2TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant2TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant2TitleAlignVariant0 {
    fn from(value: &LegendVariant2TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleAnchor {
    Variant0(::std::option::Option<LegendVariant2TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleAnchor {
    fn from(value: &LegendVariant2TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant2TitleAnchorVariant0>>
    for LegendVariant2TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant2TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant2TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant2TitleAnchorVariant0 {
    fn from(value: &LegendVariant2TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleBaseline {
    Variant0(LegendVariant2TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleBaseline {
    fn from(value: &LegendVariant2TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2TitleBaselineVariant0> for LegendVariant2TitleBaseline {
    fn from(value: LegendVariant2TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant2TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant2TitleBaselineVariant0 {
    fn from(value: &LegendVariant2TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleColor {
    fn from(value: &LegendVariant2TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant2TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant2TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleFont {
    fn from(value: &LegendVariant2TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant2TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleFontSize {
    fn from(value: &LegendVariant2TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleFontStyle {
    fn from(value: &LegendVariant2TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant2TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleFontWeight {
    fn from(value: &LegendVariant2TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant2TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant2TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleLimit {
    fn from(value: &LegendVariant2TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleLineHeight {
    fn from(value: &LegendVariant2TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleOpacity {
    fn from(value: &LegendVariant2TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitleOrient {
    Variant0(LegendVariant2TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitleOrient {
    fn from(value: &LegendVariant2TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant2TitleOrientVariant0> for LegendVariant2TitleOrient {
    fn from(value: LegendVariant2TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant2TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant2TitleOrientVariant0 {
    fn from(value: &LegendVariant2TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant2TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant2TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant2TitlePadding {
    fn from(value: &LegendVariant2TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant2TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant2TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant2Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant2Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant2Type {
    fn from(value: &LegendVariant2Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant2Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3CornerRadius {
    fn from(value: &LegendVariant3CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant3Direction {
    fn from(value: &LegendVariant3Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant3Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant3Encode> for LegendVariant3Encode {
    fn from(value: &LegendVariant3Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant3Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant3FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3FillColor {
    fn from(value: &LegendVariant3FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant3Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant3Format {
    fn from(value: &LegendVariant3Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant3Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3FormatType {
    Variant0(LegendVariant3FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant3FormatType {
    fn from(value: &LegendVariant3FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3FormatTypeVariant0> for LegendVariant3FormatType {
    fn from(value: LegendVariant3FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant3FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant3FormatTypeVariant0 {
    fn from(value: &LegendVariant3FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3GradientOpacity {
    fn from(value: &LegendVariant3GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3GradientStrokeColor {
    fn from(value: &LegendVariant3GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3GradientStrokeWidth {
    fn from(value: &LegendVariant3GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3GridAlign {
    Variant0(LegendVariant3GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant3GridAlign {
    fn from(value: &LegendVariant3GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3GridAlignVariant0> for LegendVariant3GridAlign {
    fn from(value: LegendVariant3GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant3GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant3GridAlignVariant0 {
    fn from(value: &LegendVariant3GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelAlign {
    Variant0(LegendVariant3LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelAlign {
    fn from(value: &LegendVariant3LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3LabelAlignVariant0> for LegendVariant3LabelAlign {
    fn from(value: LegendVariant3LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant3LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant3LabelAlignVariant0 {
    fn from(value: &LegendVariant3LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelBaseline {
    Variant0(LegendVariant3LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelBaseline {
    fn from(value: &LegendVariant3LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3LabelBaselineVariant0> for LegendVariant3LabelBaseline {
    fn from(value: LegendVariant3LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant3LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant3LabelBaselineVariant0 {
    fn from(value: &LegendVariant3LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelColor {
    fn from(value: &LegendVariant3LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelFont {
    fn from(value: &LegendVariant3LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant3LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelFontSize {
    fn from(value: &LegendVariant3LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelFontStyle {
    fn from(value: &LegendVariant3LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant3LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelFontWeight {
    fn from(value: &LegendVariant3LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant3LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant3LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelLimit {
    fn from(value: &LegendVariant3LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelOffset {
    fn from(value: &LegendVariant3LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LabelOpacity {
    fn from(value: &LegendVariant3LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LegendX {
    fn from(value: &LegendVariant3LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3LegendY {
    fn from(value: &LegendVariant3LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3Offset {
    fn from(value: &LegendVariant3Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3Orient {
    Variant0(LegendVariant3OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant3Orient {
    fn from(value: &LegendVariant3Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3OrientVariant0> for LegendVariant3Orient {
    fn from(value: LegendVariant3OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant3Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant3OrientVariant0 {
    fn from(value: &LegendVariant3OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3Padding {
    fn from(value: &LegendVariant3Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3StrokeColor {
    fn from(value: &LegendVariant3StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolDash {
    fn from(value: &LegendVariant3SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant3SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant3SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolDashOffset {
    fn from(value: &LegendVariant3SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolFillColor {
    fn from(value: &LegendVariant3SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolOffset {
    fn from(value: &LegendVariant3SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolOpacity {
    fn from(value: &LegendVariant3SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolSize {
    fn from(value: &LegendVariant3SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolStrokeColor {
    fn from(value: &LegendVariant3SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolStrokeWidth {
    fn from(value: &LegendVariant3SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant3SymbolType {
    fn from(value: &LegendVariant3SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant3SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleAlign {
    Variant0(LegendVariant3TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleAlign {
    fn from(value: &LegendVariant3TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3TitleAlignVariant0> for LegendVariant3TitleAlign {
    fn from(value: LegendVariant3TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant3TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant3TitleAlignVariant0 {
    fn from(value: &LegendVariant3TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleAnchor {
    Variant0(::std::option::Option<LegendVariant3TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleAnchor {
    fn from(value: &LegendVariant3TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant3TitleAnchorVariant0>>
    for LegendVariant3TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant3TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant3TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant3TitleAnchorVariant0 {
    fn from(value: &LegendVariant3TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleBaseline {
    Variant0(LegendVariant3TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleBaseline {
    fn from(value: &LegendVariant3TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3TitleBaselineVariant0> for LegendVariant3TitleBaseline {
    fn from(value: LegendVariant3TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant3TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant3TitleBaselineVariant0 {
    fn from(value: &LegendVariant3TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleColor {
    fn from(value: &LegendVariant3TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant3TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant3TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleFont {
    fn from(value: &LegendVariant3TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant3TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleFontSize {
    fn from(value: &LegendVariant3TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleFontStyle {
    fn from(value: &LegendVariant3TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant3TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleFontWeight {
    fn from(value: &LegendVariant3TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant3TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant3TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleLimit {
    fn from(value: &LegendVariant3TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleLineHeight {
    fn from(value: &LegendVariant3TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleOpacity {
    fn from(value: &LegendVariant3TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitleOrient {
    Variant0(LegendVariant3TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitleOrient {
    fn from(value: &LegendVariant3TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant3TitleOrientVariant0> for LegendVariant3TitleOrient {
    fn from(value: LegendVariant3TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant3TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant3TitleOrientVariant0 {
    fn from(value: &LegendVariant3TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant3TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant3TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant3TitlePadding {
    fn from(value: &LegendVariant3TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant3TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant3TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant3Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant3Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant3Type {
    fn from(value: &LegendVariant3Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant3Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4CornerRadius {
    fn from(value: &LegendVariant4CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant4Direction {
    fn from(value: &LegendVariant4Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant4Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant4Encode> for LegendVariant4Encode {
    fn from(value: &LegendVariant4Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant4Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant4FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4FillColor {
    fn from(value: &LegendVariant4FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant4Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant4Format {
    fn from(value: &LegendVariant4Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant4Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4FormatType {
    Variant0(LegendVariant4FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant4FormatType {
    fn from(value: &LegendVariant4FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4FormatTypeVariant0> for LegendVariant4FormatType {
    fn from(value: LegendVariant4FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant4FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant4FormatTypeVariant0 {
    fn from(value: &LegendVariant4FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4GradientOpacity {
    fn from(value: &LegendVariant4GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4GradientStrokeColor {
    fn from(value: &LegendVariant4GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4GradientStrokeWidth {
    fn from(value: &LegendVariant4GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4GridAlign {
    Variant0(LegendVariant4GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant4GridAlign {
    fn from(value: &LegendVariant4GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4GridAlignVariant0> for LegendVariant4GridAlign {
    fn from(value: LegendVariant4GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant4GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant4GridAlignVariant0 {
    fn from(value: &LegendVariant4GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelAlign {
    Variant0(LegendVariant4LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelAlign {
    fn from(value: &LegendVariant4LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4LabelAlignVariant0> for LegendVariant4LabelAlign {
    fn from(value: LegendVariant4LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant4LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant4LabelAlignVariant0 {
    fn from(value: &LegendVariant4LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelBaseline {
    Variant0(LegendVariant4LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelBaseline {
    fn from(value: &LegendVariant4LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4LabelBaselineVariant0> for LegendVariant4LabelBaseline {
    fn from(value: LegendVariant4LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant4LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant4LabelBaselineVariant0 {
    fn from(value: &LegendVariant4LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelColor {
    fn from(value: &LegendVariant4LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelFont {
    fn from(value: &LegendVariant4LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant4LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelFontSize {
    fn from(value: &LegendVariant4LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelFontStyle {
    fn from(value: &LegendVariant4LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant4LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelFontWeight {
    fn from(value: &LegendVariant4LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant4LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant4LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelLimit {
    fn from(value: &LegendVariant4LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelOffset {
    fn from(value: &LegendVariant4LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LabelOpacity {
    fn from(value: &LegendVariant4LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LegendX {
    fn from(value: &LegendVariant4LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4LegendY {
    fn from(value: &LegendVariant4LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4Offset {
    fn from(value: &LegendVariant4Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4Orient {
    Variant0(LegendVariant4OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant4Orient {
    fn from(value: &LegendVariant4Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4OrientVariant0> for LegendVariant4Orient {
    fn from(value: LegendVariant4OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant4Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant4OrientVariant0 {
    fn from(value: &LegendVariant4OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4Padding {
    fn from(value: &LegendVariant4Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4StrokeColor {
    fn from(value: &LegendVariant4StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolDash {
    fn from(value: &LegendVariant4SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant4SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant4SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolDashOffset {
    fn from(value: &LegendVariant4SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolFillColor {
    fn from(value: &LegendVariant4SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolOffset {
    fn from(value: &LegendVariant4SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolOpacity {
    fn from(value: &LegendVariant4SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolSize {
    fn from(value: &LegendVariant4SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolStrokeColor {
    fn from(value: &LegendVariant4SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolStrokeWidth {
    fn from(value: &LegendVariant4SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant4SymbolType {
    fn from(value: &LegendVariant4SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant4SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleAlign {
    Variant0(LegendVariant4TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleAlign {
    fn from(value: &LegendVariant4TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4TitleAlignVariant0> for LegendVariant4TitleAlign {
    fn from(value: LegendVariant4TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant4TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant4TitleAlignVariant0 {
    fn from(value: &LegendVariant4TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleAnchor {
    Variant0(::std::option::Option<LegendVariant4TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleAnchor {
    fn from(value: &LegendVariant4TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant4TitleAnchorVariant0>>
    for LegendVariant4TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant4TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant4TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant4TitleAnchorVariant0 {
    fn from(value: &LegendVariant4TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleBaseline {
    Variant0(LegendVariant4TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleBaseline {
    fn from(value: &LegendVariant4TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4TitleBaselineVariant0> for LegendVariant4TitleBaseline {
    fn from(value: LegendVariant4TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant4TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant4TitleBaselineVariant0 {
    fn from(value: &LegendVariant4TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleColor {
    fn from(value: &LegendVariant4TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant4TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant4TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleFont {
    fn from(value: &LegendVariant4TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant4TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleFontSize {
    fn from(value: &LegendVariant4TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleFontStyle {
    fn from(value: &LegendVariant4TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant4TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleFontWeight {
    fn from(value: &LegendVariant4TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant4TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant4TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleLimit {
    fn from(value: &LegendVariant4TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleLineHeight {
    fn from(value: &LegendVariant4TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleOpacity {
    fn from(value: &LegendVariant4TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitleOrient {
    Variant0(LegendVariant4TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitleOrient {
    fn from(value: &LegendVariant4TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant4TitleOrientVariant0> for LegendVariant4TitleOrient {
    fn from(value: LegendVariant4TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant4TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant4TitleOrientVariant0 {
    fn from(value: &LegendVariant4TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant4TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant4TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant4TitlePadding {
    fn from(value: &LegendVariant4TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant4TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant4TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant4Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant4Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant4Type {
    fn from(value: &LegendVariant4Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant4Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant4Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5CornerRadius {
    fn from(value: &LegendVariant5CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant5Direction {
    fn from(value: &LegendVariant5Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant5Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant5Encode> for LegendVariant5Encode {
    fn from(value: &LegendVariant5Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant5Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant5FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5FillColor {
    fn from(value: &LegendVariant5FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant5Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant5Format {
    fn from(value: &LegendVariant5Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant5Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5FormatType {
    Variant0(LegendVariant5FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant5FormatType {
    fn from(value: &LegendVariant5FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5FormatTypeVariant0> for LegendVariant5FormatType {
    fn from(value: LegendVariant5FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant5FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant5FormatTypeVariant0 {
    fn from(value: &LegendVariant5FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5GradientOpacity {
    fn from(value: &LegendVariant5GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5GradientStrokeColor {
    fn from(value: &LegendVariant5GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5GradientStrokeWidth {
    fn from(value: &LegendVariant5GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5GridAlign {
    Variant0(LegendVariant5GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant5GridAlign {
    fn from(value: &LegendVariant5GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5GridAlignVariant0> for LegendVariant5GridAlign {
    fn from(value: LegendVariant5GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant5GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant5GridAlignVariant0 {
    fn from(value: &LegendVariant5GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelAlign {
    Variant0(LegendVariant5LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelAlign {
    fn from(value: &LegendVariant5LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5LabelAlignVariant0> for LegendVariant5LabelAlign {
    fn from(value: LegendVariant5LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant5LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant5LabelAlignVariant0 {
    fn from(value: &LegendVariant5LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelBaseline {
    Variant0(LegendVariant5LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelBaseline {
    fn from(value: &LegendVariant5LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5LabelBaselineVariant0> for LegendVariant5LabelBaseline {
    fn from(value: LegendVariant5LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant5LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant5LabelBaselineVariant0 {
    fn from(value: &LegendVariant5LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelColor {
    fn from(value: &LegendVariant5LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelFont {
    fn from(value: &LegendVariant5LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant5LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelFontSize {
    fn from(value: &LegendVariant5LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelFontStyle {
    fn from(value: &LegendVariant5LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant5LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelFontWeight {
    fn from(value: &LegendVariant5LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant5LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant5LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelLimit {
    fn from(value: &LegendVariant5LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelOffset {
    fn from(value: &LegendVariant5LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LabelOpacity {
    fn from(value: &LegendVariant5LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LegendX {
    fn from(value: &LegendVariant5LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5LegendY {
    fn from(value: &LegendVariant5LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5Offset {
    fn from(value: &LegendVariant5Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5Orient {
    Variant0(LegendVariant5OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant5Orient {
    fn from(value: &LegendVariant5Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5OrientVariant0> for LegendVariant5Orient {
    fn from(value: LegendVariant5OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant5Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant5OrientVariant0 {
    fn from(value: &LegendVariant5OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5Padding {
    fn from(value: &LegendVariant5Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5StrokeColor {
    fn from(value: &LegendVariant5StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolDash {
    fn from(value: &LegendVariant5SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant5SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant5SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolDashOffset {
    fn from(value: &LegendVariant5SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolFillColor {
    fn from(value: &LegendVariant5SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolOffset {
    fn from(value: &LegendVariant5SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolOpacity {
    fn from(value: &LegendVariant5SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolSize {
    fn from(value: &LegendVariant5SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolStrokeColor {
    fn from(value: &LegendVariant5SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolStrokeWidth {
    fn from(value: &LegendVariant5SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant5SymbolType {
    fn from(value: &LegendVariant5SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant5SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleAlign {
    Variant0(LegendVariant5TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleAlign {
    fn from(value: &LegendVariant5TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5TitleAlignVariant0> for LegendVariant5TitleAlign {
    fn from(value: LegendVariant5TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant5TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant5TitleAlignVariant0 {
    fn from(value: &LegendVariant5TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleAnchor {
    Variant0(::std::option::Option<LegendVariant5TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleAnchor {
    fn from(value: &LegendVariant5TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant5TitleAnchorVariant0>>
    for LegendVariant5TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant5TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant5TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant5TitleAnchorVariant0 {
    fn from(value: &LegendVariant5TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleBaseline {
    Variant0(LegendVariant5TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleBaseline {
    fn from(value: &LegendVariant5TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5TitleBaselineVariant0> for LegendVariant5TitleBaseline {
    fn from(value: LegendVariant5TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant5TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant5TitleBaselineVariant0 {
    fn from(value: &LegendVariant5TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleColor {
    fn from(value: &LegendVariant5TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant5TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant5TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleFont {
    fn from(value: &LegendVariant5TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant5TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleFontSize {
    fn from(value: &LegendVariant5TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleFontStyle {
    fn from(value: &LegendVariant5TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant5TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleFontWeight {
    fn from(value: &LegendVariant5TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant5TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant5TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleLimit {
    fn from(value: &LegendVariant5TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleLineHeight {
    fn from(value: &LegendVariant5TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleOpacity {
    fn from(value: &LegendVariant5TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitleOrient {
    Variant0(LegendVariant5TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitleOrient {
    fn from(value: &LegendVariant5TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant5TitleOrientVariant0> for LegendVariant5TitleOrient {
    fn from(value: LegendVariant5TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant5TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant5TitleOrientVariant0 {
    fn from(value: &LegendVariant5TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant5TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant5TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant5TitlePadding {
    fn from(value: &LegendVariant5TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant5TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant5TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant5Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant5Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant5Type {
    fn from(value: &LegendVariant5Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant5Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant5Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6CornerRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6CornerRadius {
    fn from(value: &LegendVariant6CornerRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl ::std::convert::From<&Self> for LegendVariant6Direction {
    fn from(value: &LegendVariant6Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Vertical => write!(f, "vertical"),
            Self::Horizontal => write!(f, "horizontal"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant6Encode {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub entries: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gradient: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub labels: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub legend: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub symbols: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&LegendVariant6Encode> for LegendVariant6Encode {
    fn from(value: &LegendVariant6Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LegendVariant6Encode {
    fn default() -> Self {
        Self {
            entries: Default::default(),
            gradient: Default::default(),
            labels: Default::default(),
            legend: Default::default(),
            symbols: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`LegendVariant6FillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6FillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6FillColor {
    fn from(value: &LegendVariant6FillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6Format`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant6Format {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        date: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        day: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        month: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        quarter: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        week: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        year: ::std::option::Option<::std::string::String>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant6Format {
    fn from(value: &LegendVariant6Format) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant6Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6FormatType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6FormatType {
    Variant0(LegendVariant6FormatTypeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant6FormatType {
    fn from(value: &LegendVariant6FormatType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6FormatTypeVariant0> for LegendVariant6FormatType {
    fn from(value: LegendVariant6FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant6FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6FormatTypeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for LegendVariant6FormatTypeVariant0 {
    fn from(value: &LegendVariant6FormatTypeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6FormatTypeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Number => write!(f, "number"),
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6GradientOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6GradientOpacity {
    fn from(value: &LegendVariant6GradientOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6GradientStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6GradientStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6GradientStrokeColor {
    fn from(value: &LegendVariant6GradientStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6GradientStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6GradientStrokeWidth {
    fn from(value: &LegendVariant6GradientStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6GridAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6GridAlign {
    Variant0(LegendVariant6GridAlignVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant6GridAlign {
    fn from(value: &LegendVariant6GridAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6GridAlignVariant0> for LegendVariant6GridAlign {
    fn from(value: LegendVariant6GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant6GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6GridAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for LegendVariant6GridAlignVariant0 {
    fn from(value: &LegendVariant6GridAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6GridAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::All => write!(f, "all"),
            Self::Each => write!(f, "each"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6LabelAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelAlign {
    Variant0(LegendVariant6LabelAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelAlign {
    fn from(value: &LegendVariant6LabelAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6LabelAlignVariant0> for LegendVariant6LabelAlign {
    fn from(value: LegendVariant6LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant6LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant6LabelAlignVariant0 {
    fn from(value: &LegendVariant6LabelAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6LabelAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6LabelBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelBaseline {
    Variant0(LegendVariant6LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelBaseline {
    fn from(value: &LegendVariant6LabelBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6LabelBaselineVariant0> for LegendVariant6LabelBaseline {
    fn from(value: LegendVariant6LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant6LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant6LabelBaselineVariant0 {
    fn from(value: &LegendVariant6LabelBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6LabelBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6LabelColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelColor {
    fn from(value: &LegendVariant6LabelColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6LabelFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelFont {
    fn from(value: &LegendVariant6LabelFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant6LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelFontSize {
    fn from(value: &LegendVariant6LabelFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelFontStyle {
    fn from(value: &LegendVariant6LabelFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant6LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelFontWeight {
    fn from(value: &LegendVariant6LabelFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant6LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant6LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelLimit {
    fn from(value: &LegendVariant6LabelLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelOffset {
    fn from(value: &LegendVariant6LabelOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LabelOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LabelOpacity {
    fn from(value: &LegendVariant6LabelOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LegendX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LegendX {
    fn from(value: &LegendVariant6LegendX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6LegendY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6LegendY {
    fn from(value: &LegendVariant6LegendY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6Offset {
    fn from(value: &LegendVariant6Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6Orient {
    Variant0(LegendVariant6OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LegendVariant6Orient {
    fn from(value: &LegendVariant6Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6OrientVariant0> for LegendVariant6Orient {
    fn from(value: LegendVariant6OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LegendVariant6Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl ::std::convert::From<&Self> for LegendVariant6OrientVariant0 {
    fn from(value: &LegendVariant6OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
            Self::TopLeft => write!(f, "top-left"),
            Self::TopRight => write!(f, "top-right"),
            Self::BottomLeft => write!(f, "bottom-left"),
            Self::BottomRight => write!(f, "bottom-right"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6Padding {
    fn from(value: &LegendVariant6Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6StrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6StrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6StrokeColor {
    fn from(value: &LegendVariant6StrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6SymbolDash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolDash {
    Variant0(::std::vec::Vec<f64>),
    Variant1(ArrayValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolDash {
    fn from(value: &LegendVariant6SymbolDash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<f64>> for LegendVariant6SymbolDash {
    fn from(value: ::std::vec::Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ArrayValue> for LegendVariant6SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolDashOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolDashOffset {
    fn from(value: &LegendVariant6SymbolDashOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolFillColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolFillColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolFillColor {
    fn from(value: &LegendVariant6SymbolFillColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6SymbolOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolOffset {
    fn from(value: &LegendVariant6SymbolOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolOpacity {
    fn from(value: &LegendVariant6SymbolOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolSize {
    fn from(value: &LegendVariant6SymbolSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolStrokeColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolStrokeColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolStrokeColor {
    fn from(value: &LegendVariant6SymbolStrokeColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6SymbolStrokeWidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolStrokeWidth {
    fn from(value: &LegendVariant6SymbolStrokeWidth) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6SymbolType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6SymbolType {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant6SymbolType {
    fn from(value: &LegendVariant6SymbolType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant6SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleAlign`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleAlign {
    Variant0(LegendVariant6TitleAlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleAlign {
    fn from(value: &LegendVariant6TitleAlign) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6TitleAlignVariant0> for LegendVariant6TitleAlign {
    fn from(value: LegendVariant6TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for LegendVariant6TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleAlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for LegendVariant6TitleAlignVariant0 {
    fn from(value: &LegendVariant6TitleAlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6TitleAlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6TitleAnchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleAnchor {
    Variant0(::std::option::Option<LegendVariant6TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleAnchor {
    fn from(value: &LegendVariant6TitleAnchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<LegendVariant6TitleAnchorVariant0>>
    for LegendVariant6TitleAnchor
{
    fn from(value: ::std::option::Option<LegendVariant6TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for LegendVariant6TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleAnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for LegendVariant6TitleAnchorVariant0 {
    fn from(value: &LegendVariant6TitleAnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6TitleAnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6TitleBaseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleBaseline {
    Variant0(LegendVariant6TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleBaseline {
    fn from(value: &LegendVariant6TitleBaseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6TitleBaselineVariant0> for LegendVariant6TitleBaseline {
    fn from(value: LegendVariant6TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for LegendVariant6TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleBaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for LegendVariant6TitleBaselineVariant0 {
    fn from(value: &LegendVariant6TitleBaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6TitleBaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6TitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleColor {
    fn from(value: &LegendVariant6TitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for LegendVariant6TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LegendVariant6TitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleFont {
    fn from(value: &LegendVariant6TitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant6TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleFontSize {
    fn from(value: &LegendVariant6TitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleFontStyle {
    fn from(value: &LegendVariant6TitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for LegendVariant6TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleFontWeight {
    fn from(value: &LegendVariant6TitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for LegendVariant6TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for LegendVariant6TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleLimit {
    fn from(value: &LegendVariant6TitleLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleLineHeight {
    fn from(value: &LegendVariant6TitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleOpacity`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleOpacity {
    fn from(value: &LegendVariant6TitleOpacity) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitleOrient {
    Variant0(LegendVariant6TitleOrientVariant0),
    Variant1(OrientValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitleOrient {
    fn from(value: &LegendVariant6TitleOrient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<LegendVariant6TitleOrientVariant0> for LegendVariant6TitleOrient {
    fn from(value: LegendVariant6TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValue> for LegendVariant6TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6TitleOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for LegendVariant6TitleOrientVariant0 {
    fn from(value: &LegendVariant6TitleOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6TitleOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LegendVariant6TitlePadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LegendVariant6TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for LegendVariant6TitlePadding {
    fn from(value: &LegendVariant6TitlePadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for LegendVariant6TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for LegendVariant6TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LegendVariant6Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LegendVariant6Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl ::std::convert::From<&Self> for LegendVariant6Type {
    fn from(value: &LegendVariant6Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LegendVariant6Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Gradient => write!(f, "gradient"),
            Self::Symbol => write!(f, "symbol"),
        }
    }
}
impl ::std::str::FromStr for LegendVariant6Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LinearGradient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"stops\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"linear\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stops\": {"]
#[doc = "      \"$ref\": \"#/definitions/gradientStops\""]
#[doc = "    },"]
#[doc = "    \"x1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LinearGradient {
    pub gradient: LinearGradientGradient,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x1: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x2: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y1: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y2: ::std::option::Option<f64>,
}
impl ::std::convert::From<&LinearGradient> for LinearGradient {
    fn from(value: &LinearGradient) -> Self {
        value.clone()
    }
}
#[doc = "`LinearGradientGradient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linear\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LinearGradientGradient {
    #[serde(rename = "linear")]
    Linear,
}
impl ::std::convert::From<&Self> for LinearGradientGradient {
    fn from(value: &LinearGradientGradient) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LinearGradientGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Linear => write!(f, "linear"),
        }
    }
}
impl ::std::str::FromStr for LinearGradientGradient {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "linear" => Ok(Self::Linear),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LinkpathTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"default\": \"vertical\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"horizontal\","]
#[doc = "            \"vertical\","]
#[doc = "            \"radial\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"require\": {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    \"shape\": {"]
#[doc = "      \"default\": \"line\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"line\","]
#[doc = "            \"arc\","]
#[doc = "            \"curve\","]
#[doc = "            \"diagonal\","]
#[doc = "            \"orthogonal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sourceX\": {"]
#[doc = "      \"default\": \"source.x\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sourceY\": {"]
#[doc = "      \"default\": \"source.y\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"targetX\": {"]
#[doc = "      \"default\": \"target.x\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"targetY\": {"]
#[doc = "      \"default\": \"target.y\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"linkpath\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LinkpathTransform {
    #[serde(rename = "as", default = "defaults::linkpath_transform_as")]
    pub as_: LinkpathTransformAs,
    #[serde(default = "defaults::linkpath_transform_orient")]
    pub orient: LinkpathTransformOrient,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub require: ::std::option::Option<SignalRef>,
    #[serde(default = "defaults::linkpath_transform_shape")]
    pub shape: LinkpathTransformShape,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "sourceX", default = "defaults::linkpath_transform_source_x")]
    pub source_x: LinkpathTransformSourceX,
    #[serde(rename = "sourceY", default = "defaults::linkpath_transform_source_y")]
    pub source_y: LinkpathTransformSourceY,
    #[serde(rename = "targetX", default = "defaults::linkpath_transform_target_x")]
    pub target_x: LinkpathTransformTargetX,
    #[serde(rename = "targetY", default = "defaults::linkpath_transform_target_y")]
    pub target_y: LinkpathTransformTargetY,
    #[serde(rename = "type")]
    pub type_: LinkpathTransformType,
}
impl ::std::convert::From<&LinkpathTransform> for LinkpathTransform {
    fn from(value: &LinkpathTransform) -> Self {
        value.clone()
    }
}
#[doc = "`LinkpathTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LinkpathTransformAs {
    fn from(value: &LinkpathTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformAs {
    fn default() -> Self {
        LinkpathTransformAs::Variant0("path".to_string())
    }
}
impl ::std::convert::From<SignalRef> for LinkpathTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LinkpathTransformOrient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"vertical\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"horizontal\","]
#[doc = "        \"vertical\","]
#[doc = "        \"radial\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformOrient {
    Variant0(LinkpathTransformOrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LinkpathTransformOrient {
    fn from(value: &LinkpathTransformOrient) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformOrient {
    fn default() -> Self {
        LinkpathTransformOrient::Variant0(LinkpathTransformOrientVariant0::Vertical)
    }
}
impl ::std::convert::From<LinkpathTransformOrientVariant0> for LinkpathTransformOrient {
    fn from(value: LinkpathTransformOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LinkpathTransformOrient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LinkpathTransformOrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\","]
#[doc = "    \"radial\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LinkpathTransformOrientVariant0 {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "radial")]
    Radial,
}
impl ::std::convert::From<&Self> for LinkpathTransformOrientVariant0 {
    fn from(value: &LinkpathTransformOrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LinkpathTransformOrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Horizontal => write!(f, "horizontal"),
            Self::Vertical => write!(f, "vertical"),
            Self::Radial => write!(f, "radial"),
        }
    }
}
impl ::std::str::FromStr for LinkpathTransformOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LinkpathTransformShape`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"line\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"line\","]
#[doc = "        \"arc\","]
#[doc = "        \"curve\","]
#[doc = "        \"diagonal\","]
#[doc = "        \"orthogonal\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformShape {
    Variant0(LinkpathTransformShapeVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LinkpathTransformShape {
    fn from(value: &LinkpathTransformShape) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformShape {
    fn default() -> Self {
        LinkpathTransformShape::Variant0(LinkpathTransformShapeVariant0::Line)
    }
}
impl ::std::convert::From<LinkpathTransformShapeVariant0> for LinkpathTransformShape {
    fn from(value: LinkpathTransformShapeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LinkpathTransformShape {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LinkpathTransformShapeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"line\","]
#[doc = "    \"arc\","]
#[doc = "    \"curve\","]
#[doc = "    \"diagonal\","]
#[doc = "    \"orthogonal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LinkpathTransformShapeVariant0 {
    #[serde(rename = "line")]
    Line,
    #[serde(rename = "arc")]
    Arc,
    #[serde(rename = "curve")]
    Curve,
    #[serde(rename = "diagonal")]
    Diagonal,
    #[serde(rename = "orthogonal")]
    Orthogonal,
}
impl ::std::convert::From<&Self> for LinkpathTransformShapeVariant0 {
    fn from(value: &LinkpathTransformShapeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LinkpathTransformShapeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Line => write!(f, "line"),
            Self::Arc => write!(f, "arc"),
            Self::Curve => write!(f, "curve"),
            Self::Diagonal => write!(f, "diagonal"),
            Self::Orthogonal => write!(f, "orthogonal"),
        }
    }
}
impl ::std::str::FromStr for LinkpathTransformShapeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "line" => Ok(Self::Line),
            "arc" => Ok(Self::Arc),
            "curve" => Ok(Self::Curve),
            "diagonal" => Ok(Self::Diagonal),
            "orthogonal" => Ok(Self::Orthogonal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LinkpathTransformSourceX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"source.x\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformSourceX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LinkpathTransformSourceX {
    fn from(value: &LinkpathTransformSourceX) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformSourceX {
    fn default() -> Self {
        LinkpathTransformSourceX::ScaleField(ScaleField(StringOrSignal::Variant0(
            "source.x".to_string(),
        )))
    }
}
impl ::std::convert::From<ScaleField> for LinkpathTransformSourceX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LinkpathTransformSourceX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LinkpathTransformSourceX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LinkpathTransformSourceY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"source.y\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformSourceY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LinkpathTransformSourceY {
    fn from(value: &LinkpathTransformSourceY) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformSourceY {
    fn default() -> Self {
        LinkpathTransformSourceY::ScaleField(ScaleField(StringOrSignal::Variant0(
            "source.y".to_string(),
        )))
    }
}
impl ::std::convert::From<ScaleField> for LinkpathTransformSourceY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LinkpathTransformSourceY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LinkpathTransformSourceY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LinkpathTransformTargetX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"target.x\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformTargetX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LinkpathTransformTargetX {
    fn from(value: &LinkpathTransformTargetX) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformTargetX {
    fn default() -> Self {
        LinkpathTransformTargetX::ScaleField(ScaleField(StringOrSignal::Variant0(
            "target.x".to_string(),
        )))
    }
}
impl ::std::convert::From<ScaleField> for LinkpathTransformTargetX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LinkpathTransformTargetX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LinkpathTransformTargetX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LinkpathTransformTargetY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"target.y\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LinkpathTransformTargetY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LinkpathTransformTargetY {
    fn from(value: &LinkpathTransformTargetY) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LinkpathTransformTargetY {
    fn default() -> Self {
        LinkpathTransformTargetY::ScaleField(ScaleField(StringOrSignal::Variant0(
            "target.y".to_string(),
        )))
    }
}
impl ::std::convert::From<ScaleField> for LinkpathTransformTargetY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LinkpathTransformTargetY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LinkpathTransformTargetY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LinkpathTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linkpath\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LinkpathTransformType {
    #[serde(rename = "linkpath")]
    Linkpath,
}
impl ::std::convert::From<&Self> for LinkpathTransformType {
    fn from(value: &LinkpathTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LinkpathTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Linkpath => write!(f, "linkpath"),
        }
    }
}
impl ::std::str::FromStr for LinkpathTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "linkpath" => Ok(Self::Linkpath),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Listener`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stream\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Listener {
    Variant0(SignalRef),
    Variant1 { scale: ::std::string::String },
    Variant2(Stream),
}
impl ::std::convert::From<&Self> for Listener {
    fn from(value: &Listener) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for Listener {
    fn from(value: SignalRef) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<Stream> for Listener {
    fn from(value: Stream) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`LoessTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"default\": 0.3,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"loess\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LoessTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<LoessTransformAs>,
    #[serde(default = "defaults::loess_transform_bandwidth")]
    pub bandwidth: LoessTransformBandwidth,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<LoessTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: LoessTransformType,
    pub x: LoessTransformX,
    pub y: LoessTransformY,
}
impl ::std::convert::From<&LoessTransform> for LoessTransform {
    fn from(value: &LoessTransform) -> Self {
        value.clone()
    }
}
#[doc = "`LoessTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformAs {
    Variant0(::std::vec::Vec<LoessTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LoessTransformAs {
    fn from(value: &LoessTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<LoessTransformAsVariant0Item>> for LoessTransformAs {
    fn from(value: ::std::vec::Vec<LoessTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LoessTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LoessTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LoessTransformAsVariant0Item {
    fn from(value: &LoessTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LoessTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LoessTransformBandwidth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.3,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LoessTransformBandwidth {
    fn from(value: &LoessTransformBandwidth) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for LoessTransformBandwidth {
    fn default() -> Self {
        LoessTransformBandwidth::Variant0(0.3_f64)
    }
}
impl ::std::convert::From<f64> for LoessTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LoessTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LoessTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformGroupby {
    Variant0(::std::vec::Vec<LoessTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LoessTransformGroupby {
    fn from(value: &LoessTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<LoessTransformGroupbyVariant0Item>>
    for LoessTransformGroupby
{
    fn from(value: ::std::vec::Vec<LoessTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LoessTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LoessTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LoessTransformGroupbyVariant0Item {
    fn from(value: &LoessTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LoessTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LoessTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LoessTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LoessTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"loess\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LoessTransformType {
    #[serde(rename = "loess")]
    Loess,
}
impl ::std::convert::From<&Self> for LoessTransformType {
    fn from(value: &LoessTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LoessTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Loess => write!(f, "loess"),
        }
    }
}
impl ::std::str::FromStr for LoessTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "loess" => Ok(Self::Loess),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LoessTransformX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LoessTransformX {
    fn from(value: &LoessTransformX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LoessTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LoessTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LoessTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LoessTransformY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LoessTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LoessTransformY {
    fn from(value: &LoessTransformY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LoessTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LoessTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LoessTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LookupTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"from\","]
#[doc = "    \"key\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"default\": {},"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"lookup\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct LookupTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<LookupTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub default: ::std::option::Option<::serde_json::Value>,
    pub fields: LookupTransformFields,
    pub from: ::std::string::String,
    pub key: LookupTransformKey,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: LookupTransformType,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub values: ::std::option::Option<LookupTransformValues>,
}
impl ::std::convert::From<&LookupTransform> for LookupTransform {
    fn from(value: &LookupTransform) -> Self {
        value.clone()
    }
}
#[doc = "`LookupTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformAs {
    Variant0(::std::vec::Vec<LookupTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LookupTransformAs {
    fn from(value: &LookupTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<LookupTransformAsVariant0Item>> for LookupTransformAs {
    fn from(value: ::std::vec::Vec<LookupTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LookupTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LookupTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LookupTransformAsVariant0Item {
    fn from(value: &LookupTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for LookupTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LookupTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformFields {
    Variant0(::std::vec::Vec<LookupTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LookupTransformFields {
    fn from(value: &LookupTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<LookupTransformFieldsVariant0Item>>
    for LookupTransformFields
{
    fn from(value: ::std::vec::Vec<LookupTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LookupTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LookupTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LookupTransformFieldsVariant0Item {
    fn from(value: &LookupTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LookupTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LookupTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LookupTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LookupTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LookupTransformKey {
    fn from(value: &LookupTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LookupTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LookupTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LookupTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`LookupTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"lookup\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LookupTransformType {
    #[serde(rename = "lookup")]
    Lookup,
}
impl ::std::convert::From<&Self> for LookupTransformType {
    fn from(value: &LookupTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LookupTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Lookup => write!(f, "lookup"),
        }
    }
}
impl ::std::str::FromStr for LookupTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "lookup" => Ok(Self::Lookup),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`LookupTransformValues`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformValues {
    Variant0(::std::vec::Vec<LookupTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for LookupTransformValues {
    fn from(value: &LookupTransformValues) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<LookupTransformValuesVariant0Item>>
    for LookupTransformValues
{
    fn from(value: ::std::vec::Vec<LookupTransformValuesVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for LookupTransformValues {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`LookupTransformValuesVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum LookupTransformValuesVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for LookupTransformValuesVariant0Item {
    fn from(value: &LookupTransformValuesVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for LookupTransformValuesVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for LookupTransformValuesVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for LookupTransformValuesVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`Mark`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"aria\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"clip\": {"]
#[doc = "      \"$ref\": \"#/definitions/markclip\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"$ref\": \"#/definitions/encode\""]
#[doc = "    },"]
#[doc = "    \"interactive\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"on\": {"]
#[doc = "      \"$ref\": \"#/definitions/onMarkTrigger\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"style\": {"]
#[doc = "      \"$ref\": \"#/definitions/style\""]
#[doc = "    },"]
#[doc = "    \"transform\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/transformMark\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/marktype\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Mark {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aria: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub clip: ::std::option::Option<Markclip>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<Encode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub interactive: ::std::option::Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub on: ::std::option::Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub role: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub style: ::std::option::Option<Style>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub transform: ::std::vec::Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
impl ::std::convert::From<&Mark> for Mark {
    fn from(value: &Mark) -> Self {
        value.clone()
    }
}
#[doc = "`MarkGroup`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/from\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/facet\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"group\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/mark\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scope\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MarkGroup {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aria: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub axes: ::std::vec::Vec<Axis>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub clip: ::std::option::Option<Markclip>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<Data>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<Encode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub from: ::std::option::Option<MarkGroupFrom>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub interactive: ::std::option::Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub layout: ::std::option::Option<Layout>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub legends: ::std::vec::Vec<Legend>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub marks: ::std::vec::Vec<MarkGroupMarksItem>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub on: ::std::option::Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub projections: ::std::vec::Vec<Projection>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub role: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scales: ::std::vec::Vec<Scale>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub signals: ::std::vec::Vec<Signal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub style: ::std::option::Option<Style>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<Title>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub transform: ::std::vec::Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: MarkGroupType,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub usermeta: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&MarkGroup> for MarkGroup {
    fn from(value: &MarkGroup) -> Self {
        value.clone()
    }
}
#[doc = "`MarkGroupFrom`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/from\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/facet\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MarkGroupFrom {
    From(From),
    Facet(Facet),
}
impl ::std::convert::From<&Self> for MarkGroupFrom {
    fn from(value: &MarkGroupFrom) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<From> for MarkGroupFrom {
    fn from(value: From) -> Self {
        Self::From(value)
    }
}
impl ::std::convert::From<Facet> for MarkGroupFrom {
    fn from(value: Facet) -> Self {
        Self::Facet(value)
    }
}
#[doc = "`MarkGroupMarksItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum MarkGroupMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl ::std::convert::From<&Self> for MarkGroupMarksItem {
    fn from(value: &MarkGroupMarksItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MarkGroup> for MarkGroupMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl ::std::convert::From<MarkVisual> for MarkGroupMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "`MarkGroupType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"group\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MarkGroupType {
    #[serde(rename = "group")]
    Group,
}
impl ::std::convert::From<&Self> for MarkGroupType {
    fn from(value: &MarkGroupType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MarkGroupType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Group => write!(f, "group"),
        }
    }
}
impl ::std::str::FromStr for MarkGroupType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "group" => Ok(Self::Group),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MarkVisual`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/from\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"not\": {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"group\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/mark\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MarkVisual {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub aria: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub clip: ::std::option::Option<Markclip>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub description: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<Encode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub from: ::std::option::Option<From>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub interactive: ::std::option::Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub on: ::std::option::Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub role: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub style: ::std::option::Option<Style>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub transform: ::std::vec::Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
impl ::std::convert::From<&MarkVisual> for MarkVisual {
    fn from(value: &MarkVisual) -> Self {
        value.clone()
    }
}
#[doc = "`Markclip`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"path\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"path\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sphere\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sphere\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Markclip {
    Variant0(BooleanOrSignal),
    Variant1 { path: StringOrSignal },
    Variant2 { sphere: StringOrSignal },
}
impl ::std::convert::From<&Self> for Markclip {
    fn from(value: &Markclip) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BooleanOrSignal> for Markclip {
    fn from(value: BooleanOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`Marktype`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Marktype(pub ::std::string::String);
impl ::std::ops::Deref for Marktype {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Marktype> for ::std::string::String {
    fn from(value: Marktype) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Marktype> for Marktype {
    fn from(value: &Marktype) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Marktype {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Marktype {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Marktype {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`NestTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"generate\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"keys\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"nest\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct NestTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub generate: ::std::option::Option<NestTransformGenerate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub keys: ::std::option::Option<NestTransformKeys>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: NestTransformType,
}
impl ::std::convert::From<&NestTransform> for NestTransform {
    fn from(value: &NestTransform) -> Self {
        value.clone()
    }
}
#[doc = "`NestTransformGenerate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NestTransformGenerate {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for NestTransformGenerate {
    fn from(value: &NestTransformGenerate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for NestTransformGenerate {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for NestTransformGenerate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NestTransformKeys`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NestTransformKeys {
    Variant0(::std::vec::Vec<NestTransformKeysVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for NestTransformKeys {
    fn from(value: &NestTransformKeys) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<NestTransformKeysVariant0Item>> for NestTransformKeys {
    fn from(value: ::std::vec::Vec<NestTransformKeysVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for NestTransformKeys {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NestTransformKeysVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NestTransformKeysVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for NestTransformKeysVariant0Item {
    fn from(value: &NestTransformKeysVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for NestTransformKeysVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for NestTransformKeysVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for NestTransformKeysVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`NestTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"nest\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum NestTransformType {
    #[serde(rename = "nest")]
    Nest,
}
impl ::std::convert::From<&Self> for NestTransformType {
    fn from(value: &NestTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for NestTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Nest => write!(f, "nest"),
        }
    }
}
impl ::std::str::FromStr for NestTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "nest" => Ok(Self::Nest),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`NumberModifiers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"band\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"exponent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extra\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"mult\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/field\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NumberModifiers {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub band: ::std::option::Option<NumberModifiersBand>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub exponent: ::std::option::Option<NumberModifiersExponent>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extra: ::std::option::Option<bool>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub mult: ::std::option::Option<NumberModifiersMult>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub offset: ::std::option::Option<NumberModifiersOffset>,
    #[serde(default)]
    pub round: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub scale: ::std::option::Option<Field>,
}
impl ::std::convert::From<&NumberModifiers> for NumberModifiers {
    fn from(value: &NumberModifiers) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for NumberModifiers {
    fn default() -> Self {
        Self {
            band: Default::default(),
            exponent: Default::default(),
            extra: Default::default(),
            mult: Default::default(),
            offset: Default::default(),
            round: Default::default(),
            scale: Default::default(),
        }
    }
}
#[doc = "`NumberModifiersBand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberModifiersBand {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberModifiersBand {
    fn from(value: &NumberModifiersBand) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberModifiersBand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberModifiersBand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberModifiersBand {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberModifiersBand {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberModifiersExponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberModifiersExponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberModifiersExponent {
    fn from(value: &NumberModifiersExponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberModifiersExponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberModifiersExponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberModifiersMult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberModifiersMult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberModifiersMult {
    fn from(value: &NumberModifiersMult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberModifiersMult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberModifiersMult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberModifiersOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberModifiersOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberModifiersOffset {
    fn from(value: &NumberModifiersOffset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberModifiersOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberModifiersOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberOrSignal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberOrSignal {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for NumberOrSignal {
    fn from(value: &NumberOrSignal) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberOrSignal {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for NumberOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"number\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValue {
    Variant0(::std::vec::Vec<NumberValueVariant0Item>),
    Variant1(NumberValueVariant1),
}
impl ::std::convert::From<&Self> for NumberValue {
    fn from(value: &NumberValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberValueVariant0Item>> for NumberValue {
    fn from(value: ::std::vec::Vec<NumberValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValueVariant1> for NumberValue {
    fn from(value: NumberValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0Item {
    Variant0(NumberValueVariant0ItemVariant0),
    Variant1(NumberValueVariant0ItemVariant1),
    Variant2(NumberValueVariant0ItemVariant2),
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant0ItemVariant3Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant0ItemVariant3Mult>,
        offset: NumberValueVariant0ItemVariant3Offset,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for NumberValueVariant0Item {
    fn from(value: &NumberValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<NumberValueVariant0ItemVariant0> for NumberValueVariant0Item {
    fn from(value: NumberValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValueVariant0ItemVariant1> for NumberValueVariant0Item {
    fn from(value: NumberValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<NumberValueVariant0ItemVariant2> for NumberValueVariant0Item {
    fn from(value: NumberValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant0ItemVariant0Variant0Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant0ItemVariant0Variant0Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant0ItemVariant0Variant0Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant0ItemVariant0Variant0Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant0ItemVariant0Variant1Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant0ItemVariant0Variant1Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant0ItemVariant0Variant1Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant0ItemVariant0Variant1Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: f64,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant0ItemVariant0Variant2Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant0ItemVariant0Variant2Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant0ItemVariant0Variant2Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant0ItemVariant0Variant2Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant0ItemVariant0Variant3Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant0ItemVariant0Variant3Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant0ItemVariant0Variant3Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant0ItemVariant0Variant3Offset>,
        range: NumberValueVariant0ItemVariant0Variant3Range,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0 {
    fn from(value: &NumberValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant0Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: &NumberValueVariant0ItemVariant0Variant0Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant0ItemVariant0Variant0Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for NumberValueVariant0ItemVariant0Variant0Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for NumberValueVariant0ItemVariant0Variant0Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant0ItemVariant0Variant0Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant0Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: &NumberValueVariant0ItemVariant0Variant0Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant0Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: &NumberValueVariant0ItemVariant0Variant0Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant0Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: &NumberValueVariant0ItemVariant0Variant0Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant1Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: &NumberValueVariant0ItemVariant0Variant1Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant0ItemVariant0Variant1Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for NumberValueVariant0ItemVariant0Variant1Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for NumberValueVariant0ItemVariant0Variant1Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant0ItemVariant0Variant1Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant1Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: &NumberValueVariant0ItemVariant0Variant1Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant1Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: &NumberValueVariant0ItemVariant0Variant1Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant1Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: &NumberValueVariant0ItemVariant0Variant1Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant2Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: &NumberValueVariant0ItemVariant0Variant2Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant0ItemVariant0Variant2Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for NumberValueVariant0ItemVariant0Variant2Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for NumberValueVariant0ItemVariant0Variant2Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant0ItemVariant0Variant2Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant2Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: &NumberValueVariant0ItemVariant0Variant2Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant2Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: &NumberValueVariant0ItemVariant0Variant2Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant2Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: &NumberValueVariant0ItemVariant0Variant2Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant3Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: &NumberValueVariant0ItemVariant0Variant3Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant0ItemVariant0Variant3Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for NumberValueVariant0ItemVariant0Variant3Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for NumberValueVariant0ItemVariant0Variant3Band
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant0ItemVariant0Variant3Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant3Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: &NumberValueVariant0ItemVariant0Variant3Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant3Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: &NumberValueVariant0ItemVariant0Variant3Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant3Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: &NumberValueVariant0ItemVariant0Variant3Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: &NumberValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for NumberValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for NumberValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant1 {
    fn from(value: &NumberValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant2 {
    fn from(value: &NumberValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant0ItemVariant3Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant3Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant3Exponent {
    fn from(value: &NumberValueVariant0ItemVariant3Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant3Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant3Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant3Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant3Mult {
    fn from(value: &NumberValueVariant0ItemVariant3Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant3Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant0ItemVariant3Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant3Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for NumberValueVariant0ItemVariant3Offset {
    fn from(value: &NumberValueVariant0ItemVariant3Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant0ItemVariant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for NumberValueVariant0ItemVariant3Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1 {
    Variant0(NumberValueVariant1Variant0),
    Variant1(NumberValueVariant1Variant1),
    Variant2(NumberValueVariant1Variant2),
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant1Variant3Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant1Variant3Mult>,
        offset: NumberValueVariant1Variant3Offset,
        #[serde(default)]
        round: bool,
    },
}
impl ::std::convert::From<&Self> for NumberValueVariant1 {
    fn from(value: &NumberValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<NumberValueVariant1Variant0> for NumberValueVariant1 {
    fn from(value: NumberValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValueVariant1Variant1> for NumberValueVariant1 {
    fn from(value: NumberValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<NumberValueVariant1Variant2> for NumberValueVariant1 {
    fn from(value: NumberValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`NumberValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant1Variant0Variant0Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant1Variant0Variant0Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant1Variant0Variant0Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant1Variant0Variant0Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant1Variant0Variant1Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant1Variant0Variant1Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant1Variant0Variant1Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant1Variant0Variant1Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: f64,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant1Variant0Variant2Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant1Variant0Variant2Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant1Variant0Variant2Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant1Variant0Variant2Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        band: ::std::option::Option<NumberValueVariant1Variant0Variant3Band>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberValueVariant1Variant0Variant3Exponent>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extra: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        mult: ::std::option::Option<NumberValueVariant1Variant0Variant3Mult>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<NumberValueVariant1Variant0Variant3Offset>,
        range: NumberValueVariant1Variant0Variant3Range,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0 {
    fn from(value: &NumberValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant1Variant0Variant0Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: &NumberValueVariant1Variant0Variant0Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant1Variant0Variant0Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant1Variant0Variant0Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant0Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Exponent {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant0Exponent {
    fn from(value: &NumberValueVariant1Variant0Variant0Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant0Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant0Exponent
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant0Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Mult {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant0Mult {
    fn from(value: &NumberValueVariant1Variant0Variant0Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant0Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant0Mult
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant0Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Offset {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant0Offset {
    fn from(value: &NumberValueVariant1Variant0Variant0Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant0Offset
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant1Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: &NumberValueVariant1Variant0Variant1Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant1Variant0Variant1Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant1Variant0Variant1Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant1Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Exponent {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant1Exponent {
    fn from(value: &NumberValueVariant1Variant0Variant1Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant1Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant1Exponent
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant1Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Mult {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant1Mult {
    fn from(value: &NumberValueVariant1Variant0Variant1Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant1Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant1Mult
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant1Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Offset {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant1Offset {
    fn from(value: &NumberValueVariant1Variant0Variant1Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant1Offset
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant2Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: &NumberValueVariant1Variant0Variant2Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant1Variant0Variant2Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant1Variant0Variant2Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant2Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Exponent {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant2Exponent {
    fn from(value: &NumberValueVariant1Variant0Variant2Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant2Exponent
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant2Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Mult {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant2Mult {
    fn from(value: &NumberValueVariant1Variant0Variant2Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant2Mult
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant2Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Offset {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant2Offset {
    fn from(value: &NumberValueVariant1Variant0Variant2Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant2Offset
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant3Band`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Band {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: &NumberValueVariant1Variant0Variant3Band) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant1Variant0Variant3Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant1Variant0Variant3Band {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant3Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Exponent {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant3Exponent {
    fn from(value: &NumberValueVariant1Variant0Variant3Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant3Exponent
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant3Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Mult {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant3Mult {
    fn from(value: &NumberValueVariant1Variant0Variant3Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant3Mult
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant3Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Offset {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant3Offset {
    fn from(value: &NumberValueVariant1Variant0Variant3Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>>
    for NumberValueVariant1Variant0Variant3Offset
{
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: &NumberValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for NumberValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for NumberValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant1 {
    fn from(value: &NumberValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant2 {
    fn from(value: &NumberValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`NumberValueVariant1Variant3Exponent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant3Exponent {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant3Exponent {
    fn from(value: &NumberValueVariant1Variant3Exponent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>> for NumberValueVariant1Variant3Exponent {
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant3Mult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant3Mult {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant3Mult {
    fn from(value: &NumberValueVariant1Variant3Mult) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>> for NumberValueVariant1Variant3Mult {
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`NumberValueVariant1Variant3Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant3Offset {
    Variant0(f64),
    Variant1(::std::boxed::Box<NumberValue>),
}
impl ::std::convert::From<&Self> for NumberValueVariant1Variant3Offset {
    fn from(value: &NumberValueVariant1Variant3Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for NumberValueVariant1Variant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::boxed::Box<NumberValue>> for NumberValueVariant1Variant3Offset {
    fn from(value: ::std::boxed::Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`OnEvents`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"allOf\": ["]
#[doc = "      {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"events\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"events\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/selector\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/listener\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/listener\""]
#[doc = "                },"]
#[doc = "                \"minItems\": 1"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"force\": {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"encode\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"encode\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"update\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"update\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/exprString\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"value\""]
#[doc = "                    ],"]
#[doc = "                    \"properties\": {"]
#[doc = "                      \"value\": {}"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct OnEvents(pub ::std::vec::Vec<OnEventsItem>);
impl ::std::ops::Deref for OnEvents {
    type Target = ::std::vec::Vec<OnEventsItem>;
    fn deref(&self) -> &::std::vec::Vec<OnEventsItem> {
        &self.0
    }
}
impl ::std::convert::From<OnEvents> for ::std::vec::Vec<OnEventsItem> {
    fn from(value: OnEvents) -> Self {
        value.0
    }
}
impl ::std::convert::From<&OnEvents> for OnEvents {
    fn from(value: &OnEvents) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<OnEventsItem>> for OnEvents {
    fn from(value: ::std::vec::Vec<OnEventsItem>) -> Self {
        Self(value)
    }
}
#[doc = "`OnEventsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"events\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"events\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/selector\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/listener\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/listener\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"encode\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"encode\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"update\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"update\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/exprString\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/expr\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OnEventsItem {
    Variant0 {
        encode: ::std::string::String,
        events: OnEventsItemVariant0Events,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        force: ::std::option::Option<bool>,
    },
    Variant1 {
        events: OnEventsItemVariant1Events,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        force: ::std::option::Option<bool>,
        update: OnEventsItemVariant1Update,
    },
}
impl ::std::convert::From<&Self> for OnEventsItem {
    fn from(value: &OnEventsItem) -> Self {
        value.clone()
    }
}
#[doc = "`OnEventsItemVariant0Events`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/selector\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/listener\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/listener\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OnEventsItemVariant0Events {
    Variant0(Selector),
    Variant1(Listener),
    Variant2(::std::vec::Vec<Listener>),
}
impl ::std::convert::From<&Self> for OnEventsItemVariant0Events {
    fn from(value: &OnEventsItemVariant0Events) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Selector> for OnEventsItemVariant0Events {
    fn from(value: Selector) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<Listener> for OnEventsItemVariant0Events {
    fn from(value: Listener) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<Listener>> for OnEventsItemVariant0Events {
    fn from(value: ::std::vec::Vec<Listener>) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`OnEventsItemVariant1Events`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/selector\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/listener\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/listener\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OnEventsItemVariant1Events {
    Variant0(Selector),
    Variant1(Listener),
    Variant2(::std::vec::Vec<Listener>),
}
impl ::std::convert::From<&Self> for OnEventsItemVariant1Events {
    fn from(value: &OnEventsItemVariant1Events) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Selector> for OnEventsItemVariant1Events {
    fn from(value: Selector) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<Listener> for OnEventsItemVariant1Events {
    fn from(value: Listener) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<Listener>> for OnEventsItemVariant1Events {
    fn from(value: ::std::vec::Vec<Listener>) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`OnEventsItemVariant1Update`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {}"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OnEventsItemVariant1Update {
    Variant0(ExprString),
    Variant1(Expr),
    Variant2(SignalRef),
    Variant3 { value: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for OnEventsItemVariant1Update {
    fn from(value: &OnEventsItemVariant1Update) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ExprString> for OnEventsItemVariant1Update {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<Expr> for OnEventsItemVariant1Update {
    fn from(value: Expr) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for OnEventsItemVariant1Update {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`OnMarkTrigger`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"trigger\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"modify\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"trigger\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"values\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct OnMarkTrigger(pub ::std::vec::Vec<OnMarkTriggerItem>);
impl ::std::ops::Deref for OnMarkTrigger {
    type Target = ::std::vec::Vec<OnMarkTriggerItem>;
    fn deref(&self) -> &::std::vec::Vec<OnMarkTriggerItem> {
        &self.0
    }
}
impl ::std::convert::From<OnMarkTrigger> for ::std::vec::Vec<OnMarkTriggerItem> {
    fn from(value: OnMarkTrigger) -> Self {
        value.0
    }
}
impl ::std::convert::From<&OnMarkTrigger> for OnMarkTrigger {
    fn from(value: &OnMarkTrigger) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<OnMarkTriggerItem>> for OnMarkTrigger {
    fn from(value: ::std::vec::Vec<OnMarkTriggerItem>) -> Self {
        Self(value)
    }
}
#[doc = "`OnMarkTriggerItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"trigger\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"modify\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"trigger\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OnMarkTriggerItem {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub modify: ::std::option::Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub values: ::std::option::Option<ExprString>,
}
impl ::std::convert::From<&OnMarkTriggerItem> for OnMarkTriggerItem {
    fn from(value: &OnMarkTriggerItem) -> Self {
        value.clone()
    }
}
#[doc = "`OnTrigger`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"trigger\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"insert\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"modify\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"remove\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/exprString\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"toggle\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"trigger\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"values\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct OnTrigger(pub ::std::vec::Vec<OnTriggerItem>);
impl ::std::ops::Deref for OnTrigger {
    type Target = ::std::vec::Vec<OnTriggerItem>;
    fn deref(&self) -> &::std::vec::Vec<OnTriggerItem> {
        &self.0
    }
}
impl ::std::convert::From<OnTrigger> for ::std::vec::Vec<OnTriggerItem> {
    fn from(value: OnTrigger) -> Self {
        value.0
    }
}
impl ::std::convert::From<&OnTrigger> for OnTrigger {
    fn from(value: &OnTrigger) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<OnTriggerItem>> for OnTrigger {
    fn from(value: ::std::vec::Vec<OnTriggerItem>) -> Self {
        Self(value)
    }
}
#[doc = "`OnTriggerItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"trigger\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"insert\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"modify\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"remove\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"toggle\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"trigger\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct OnTriggerItem {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub insert: ::std::option::Option<ExprString>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub modify: ::std::option::Option<ExprString>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub remove: ::std::option::Option<OnTriggerItemRemove>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub toggle: ::std::option::Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub values: ::std::option::Option<ExprString>,
}
impl ::std::convert::From<&OnTriggerItem> for OnTriggerItem {
    fn from(value: &OnTriggerItem) -> Self {
        value.clone()
    }
}
#[doc = "`OnTriggerItemRemove`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OnTriggerItemRemove {
    Variant0(bool),
    Variant1(ExprString),
}
impl ::std::convert::From<&Self> for OnTriggerItemRemove {
    fn from(value: &OnTriggerItemRemove) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for OnTriggerItemRemove {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for OnTriggerItemRemove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<bool> for OnTriggerItemRemove {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ExprString> for OnTriggerItemRemove {
    fn from(value: ExprString) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`OrientValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"left\","]
#[doc = "                              \"right\","]
#[doc = "                              \"top\","]
#[doc = "                              \"bottom\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"top\","]
#[doc = "                        \"bottom\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValue {
    Variant0(::std::vec::Vec<OrientValueVariant0Item>),
    Variant1(OrientValueVariant1),
}
impl ::std::convert::From<&Self> for OrientValue {
    fn from(value: &OrientValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<OrientValueVariant0Item>> for OrientValue {
    fn from(value: ::std::vec::Vec<OrientValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValueVariant1> for OrientValue {
    fn from(value: OrientValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`OrientValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"top\","]
#[doc = "                        \"bottom\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant0Item {
    Variant0(OrientValueVariant0ItemVariant0),
    Variant1(OrientValueVariant0ItemVariant1),
    Variant2(OrientValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for OrientValueVariant0Item {
    fn from(value: &OrientValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<OrientValueVariant0ItemVariant0> for OrientValueVariant0Item {
    fn from(value: OrientValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValueVariant0ItemVariant1> for OrientValueVariant0Item {
    fn from(value: OrientValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<OrientValueVariant0ItemVariant2> for OrientValueVariant0Item {
    fn from(value: OrientValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`OrientValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: OrientValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: OrientValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for OrientValueVariant0ItemVariant0 {
    fn from(value: &OrientValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`OrientValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrientValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for OrientValueVariant0ItemVariant0Variant1Value {
    fn from(value: &OrientValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrientValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for OrientValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrientValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for OrientValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for OrientValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrientValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for OrientValueVariant0ItemVariant0Variant3Range {
    fn from(value: &OrientValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for OrientValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrientValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for OrientValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for OrientValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for OrientValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for OrientValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for OrientValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`OrientValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"top\","]
#[doc = "                  \"bottom\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum OrientValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for OrientValueVariant0ItemVariant1 {
    fn from(value: &OrientValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`OrientValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"top\","]
#[doc = "                  \"bottom\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum OrientValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for OrientValueVariant0ItemVariant2 {
    fn from(value: &OrientValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`OrientValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"left\","]
#[doc = "                    \"right\","]
#[doc = "                    \"top\","]
#[doc = "                    \"bottom\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant1 {
    Variant0(OrientValueVariant1Variant0),
    Variant1(OrientValueVariant1Variant1),
    Variant2(OrientValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for OrientValueVariant1 {
    fn from(value: &OrientValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<OrientValueVariant1Variant0> for OrientValueVariant1 {
    fn from(value: OrientValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<OrientValueVariant1Variant1> for OrientValueVariant1 {
    fn from(value: OrientValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<OrientValueVariant1Variant2> for OrientValueVariant1 {
    fn from(value: OrientValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`OrientValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: OrientValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: OrientValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for OrientValueVariant1Variant0 {
    fn from(value: &OrientValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`OrientValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OrientValueVariant1Variant0Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for OrientValueVariant1Variant0Variant1Value {
    fn from(value: &OrientValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OrientValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for OrientValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrientValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrientValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrientValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`OrientValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OrientValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for OrientValueVariant1Variant0Variant3Range {
    fn from(value: &OrientValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for OrientValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for OrientValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OrientValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OrientValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for OrientValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for OrientValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for OrientValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`OrientValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"top\","]
#[doc = "                  \"bottom\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum OrientValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for OrientValueVariant1Variant1 {
    fn from(value: &OrientValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`OrientValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"left\","]
#[doc = "                  \"right\","]
#[doc = "                  \"top\","]
#[doc = "                  \"bottom\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum OrientValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for OrientValueVariant1Variant2 {
    fn from(value: &OrientValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`PackTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"r\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 5,"]
#[doc = "          \"minItems\": 5"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"radius\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pack\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PackTransform {
    #[serde(rename = "as", default = "defaults::pack_transform_as")]
    pub as_: PackTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<PackTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<PackTransformPadding>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub radius: ::std::option::Option<PackTransformRadius>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<PackTransformSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PackTransformType,
}
impl ::std::convert::From<&PackTransform> for PackTransform {
    fn from(value: &PackTransform) -> Self {
        value.clone()
    }
}
#[doc = "`PackTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"r\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 5,"]
#[doc = "      \"minItems\": 5"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformAs {
    Variant0([PackTransformAsVariant0Item; 5usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PackTransformAs {
    fn from(value: &PackTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PackTransformAs {
    fn default() -> Self {
        PackTransformAs::Variant0([
            PackTransformAsVariant0Item::Variant0("x".to_string()),
            PackTransformAsVariant0Item::Variant0("y".to_string()),
            PackTransformAsVariant0Item::Variant0("r".to_string()),
            PackTransformAsVariant0Item::Variant0("depth".to_string()),
            PackTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl ::std::convert::From<[PackTransformAsVariant0Item; 5usize]> for PackTransformAs {
    fn from(value: [PackTransformAsVariant0Item; 5usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PackTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PackTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PackTransformAsVariant0Item {
    fn from(value: &PackTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for PackTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PackTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PackTransformField {
    fn from(value: &PackTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PackTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PackTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PackTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PackTransformPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PackTransformPadding {
    fn from(value: &PackTransformPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PackTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PackTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PackTransformRadius`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformRadius {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PackTransformRadius {
    fn from(value: &PackTransformRadius) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PackTransformRadius {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PackTransformRadius {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PackTransformRadius {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PackTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformSize {
    Variant0([PackTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PackTransformSize {
    fn from(value: &PackTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[PackTransformSizeVariant0Item; 2usize]> for PackTransformSize {
    fn from(value: [PackTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PackTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PackTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PackTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PackTransformSizeVariant0Item {
    fn from(value: &PackTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PackTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PackTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PackTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pack\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PackTransformType {
    #[serde(rename = "pack")]
    Pack,
}
impl ::std::convert::From<&Self> for PackTransformType {
    fn from(value: &PackTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PackTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pack => write!(f, "pack"),
        }
    }
}
impl ::std::str::FromStr for PackTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pack" => Ok(Self::Pack),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Padding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"bottom\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"left\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"right\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"top\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Padding {
    Variant0(f64),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bottom: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        left: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        right: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        top: ::std::option::Option<f64>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for Padding {
    fn from(value: &Padding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for Padding {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ParamField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ParamField {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<::std::string::String>,
    pub field: ::std::string::String,
}
impl ::std::convert::From<&ParamField> for ParamField {
    fn from(value: &ParamField) -> Self {
        value.clone()
    }
}
#[doc = "`PartitionTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x0\","]
#[doc = "        \"y0\","]
#[doc = "        \"x1\","]
#[doc = "        \"y1\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 6,"]
#[doc = "          \"minItems\": 6"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"partition\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PartitionTransform {
    #[serde(rename = "as", default = "defaults::partition_transform_as")]
    pub as_: PartitionTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<PartitionTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<PartitionTransformPadding>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub round: ::std::option::Option<PartitionTransformRound>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<PartitionTransformSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PartitionTransformType,
}
impl ::std::convert::From<&PartitionTransform> for PartitionTransform {
    fn from(value: &PartitionTransform) -> Self {
        value.clone()
    }
}
#[doc = "`PartitionTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x0\","]
#[doc = "    \"y0\","]
#[doc = "    \"x1\","]
#[doc = "    \"y1\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 6,"]
#[doc = "      \"minItems\": 6"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformAs {
    Variant0([PartitionTransformAsVariant0Item; 6usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformAs {
    fn from(value: &PartitionTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PartitionTransformAs {
    fn default() -> Self {
        PartitionTransformAs::Variant0([
            PartitionTransformAsVariant0Item::Variant0("x0".to_string()),
            PartitionTransformAsVariant0Item::Variant0("y0".to_string()),
            PartitionTransformAsVariant0Item::Variant0("x1".to_string()),
            PartitionTransformAsVariant0Item::Variant0("y1".to_string()),
            PartitionTransformAsVariant0Item::Variant0("depth".to_string()),
            PartitionTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl ::std::convert::From<[PartitionTransformAsVariant0Item; 6usize]> for PartitionTransformAs {
    fn from(value: [PartitionTransformAsVariant0Item; 6usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformAsVariant0Item {
    fn from(value: &PartitionTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PartitionTransformField {
    fn from(value: &PartitionTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PartitionTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PartitionTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PartitionTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PartitionTransformPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformPadding {
    fn from(value: &PartitionTransformPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PartitionTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformRound`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformRound {
    fn from(value: &PartitionTransformRound) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for PartitionTransformRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformRound {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformSize {
    Variant0([PartitionTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformSize {
    fn from(value: &PartitionTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[PartitionTransformSizeVariant0Item; 2usize]> for PartitionTransformSize {
    fn from(value: [PartitionTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PartitionTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PartitionTransformSizeVariant0Item {
    fn from(value: &PartitionTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PartitionTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PartitionTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PartitionTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"partition\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PartitionTransformType {
    #[serde(rename = "partition")]
    Partition,
}
impl ::std::convert::From<&Self> for PartitionTransformType {
    fn from(value: &PartitionTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PartitionTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Partition => write!(f, "partition"),
        }
    }
}
impl ::std::str::FromStr for PartitionTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "partition" => Ok(Self::Partition),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PieTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"startAngle\","]
#[doc = "        \"endAngle\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"endAngle\": {"]
#[doc = "      \"default\": 6.283185307179586,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"startAngle\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pie\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PieTransform {
    #[serde(rename = "as", default = "defaults::pie_transform_as")]
    pub as_: PieTransformAs,
    #[serde(rename = "endAngle", default = "defaults::pie_transform_end_angle")]
    pub end_angle: PieTransformEndAngle,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<PieTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<PieTransformSort>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub start_angle: ::std::option::Option<PieTransformStartAngle>,
    #[serde(rename = "type")]
    pub type_: PieTransformType,
}
impl ::std::convert::From<&PieTransform> for PieTransform {
    fn from(value: &PieTransform) -> Self {
        value.clone()
    }
}
#[doc = "`PieTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"startAngle\","]
#[doc = "    \"endAngle\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformAs {
    Variant0([PieTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PieTransformAs {
    fn from(value: &PieTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PieTransformAs {
    fn default() -> Self {
        PieTransformAs::Variant0([
            PieTransformAsVariant0Item::Variant0("startAngle".to_string()),
            PieTransformAsVariant0Item::Variant0("endAngle".to_string()),
        ])
    }
}
impl ::std::convert::From<[PieTransformAsVariant0Item; 2usize]> for PieTransformAs {
    fn from(value: [PieTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PieTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PieTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PieTransformAsVariant0Item {
    fn from(value: &PieTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for PieTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PieTransformEndAngle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 6.283185307179586,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformEndAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PieTransformEndAngle {
    fn from(value: &PieTransformEndAngle) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PieTransformEndAngle {
    fn default() -> Self {
        PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
}
impl ::std::convert::From<f64> for PieTransformEndAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PieTransformEndAngle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PieTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PieTransformField {
    fn from(value: &PieTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PieTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PieTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PieTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PieTransformSort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformSort {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PieTransformSort {
    fn from(value: &PieTransformSort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for PieTransformSort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PieTransformSort {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PieTransformStartAngle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PieTransformStartAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PieTransformStartAngle {
    fn from(value: &PieTransformStartAngle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PieTransformStartAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PieTransformStartAngle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PieTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pie\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PieTransformType {
    #[serde(rename = "pie")]
    Pie,
}
impl ::std::convert::From<&Self> for PieTransformType {
    fn from(value: &PieTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PieTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pie => write!(f, "pie"),
        }
    }
}
impl ::std::str::FromStr for PieTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pie" => Ok(Self::Pie),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PivotTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"limit\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"op\": {"]
#[doc = "      \"default\": \"sum\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"values\","]
#[doc = "            \"count\","]
#[doc = "            \"__count__\","]
#[doc = "            \"missing\","]
#[doc = "            \"valid\","]
#[doc = "            \"sum\","]
#[doc = "            \"product\","]
#[doc = "            \"mean\","]
#[doc = "            \"average\","]
#[doc = "            \"variance\","]
#[doc = "            \"variancep\","]
#[doc = "            \"stdev\","]
#[doc = "            \"stdevp\","]
#[doc = "            \"stderr\","]
#[doc = "            \"distinct\","]
#[doc = "            \"ci0\","]
#[doc = "            \"ci1\","]
#[doc = "            \"median\","]
#[doc = "            \"q1\","]
#[doc = "            \"q3\","]
#[doc = "            \"min\","]
#[doc = "            \"max\","]
#[doc = "            \"argmin\","]
#[doc = "            \"argmax\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pivot\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct PivotTransform {
    pub field: PivotTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<PivotTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub key: ::std::option::Option<PivotTransformKey>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub limit: ::std::option::Option<PivotTransformLimit>,
    #[serde(default = "defaults::pivot_transform_op")]
    pub op: PivotTransformOp,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: PivotTransformType,
    pub value: PivotTransformValue,
}
impl ::std::convert::From<&PivotTransform> for PivotTransform {
    fn from(value: &PivotTransform) -> Self {
        value.clone()
    }
}
#[doc = "`PivotTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PivotTransformField {
    fn from(value: &PivotTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PivotTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PivotTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PivotTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PivotTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformGroupby {
    Variant0(::std::vec::Vec<PivotTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PivotTransformGroupby {
    fn from(value: &PivotTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<PivotTransformGroupbyVariant0Item>>
    for PivotTransformGroupby
{
    fn from(value: ::std::vec::Vec<PivotTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PivotTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PivotTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PivotTransformGroupbyVariant0Item {
    fn from(value: &PivotTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PivotTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PivotTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PivotTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PivotTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PivotTransformKey {
    fn from(value: &PivotTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PivotTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PivotTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PivotTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`PivotTransformLimit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformLimit {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PivotTransformLimit {
    fn from(value: &PivotTransformLimit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for PivotTransformLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PivotTransformLimit {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PivotTransformOp`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"sum\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformOp {
    Variant0(PivotTransformOpVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for PivotTransformOp {
    fn from(value: &PivotTransformOp) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for PivotTransformOp {
    fn default() -> Self {
        PivotTransformOp::Variant0(PivotTransformOpVariant0::Sum)
    }
}
impl ::std::convert::From<PivotTransformOpVariant0> for PivotTransformOp {
    fn from(value: PivotTransformOpVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for PivotTransformOp {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`PivotTransformOpVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PivotTransformOpVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    XXcountXx,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ::std::convert::From<&Self> for PivotTransformOpVariant0 {
    fn from(value: &PivotTransformOpVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PivotTransformOpVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Values => write!(f, "values"),
            Self::Count => write!(f, "count"),
            Self::XXcountXx => write!(f, "__count__"),
            Self::Missing => write!(f, "missing"),
            Self::Valid => write!(f, "valid"),
            Self::Sum => write!(f, "sum"),
            Self::Product => write!(f, "product"),
            Self::Mean => write!(f, "mean"),
            Self::Average => write!(f, "average"),
            Self::Variance => write!(f, "variance"),
            Self::Variancep => write!(f, "variancep"),
            Self::Stdev => write!(f, "stdev"),
            Self::Stdevp => write!(f, "stdevp"),
            Self::Stderr => write!(f, "stderr"),
            Self::Distinct => write!(f, "distinct"),
            Self::Ci0 => write!(f, "ci0"),
            Self::Ci1 => write!(f, "ci1"),
            Self::Median => write!(f, "median"),
            Self::Q1 => write!(f, "q1"),
            Self::Q3 => write!(f, "q3"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
            Self::Argmin => write!(f, "argmin"),
            Self::Argmax => write!(f, "argmax"),
        }
    }
}
impl ::std::str::FromStr for PivotTransformOpVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::XXcountXx),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PivotTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pivot\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PivotTransformType {
    #[serde(rename = "pivot")]
    Pivot,
}
impl ::std::convert::From<&Self> for PivotTransformType {
    fn from(value: &PivotTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PivotTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pivot => write!(f, "pivot"),
        }
    }
}
impl ::std::str::FromStr for PivotTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pivot" => Ok(Self::Pivot),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PivotTransformValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum PivotTransformValue {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for PivotTransformValue {
    fn from(value: &PivotTransformValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for PivotTransformValue {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for PivotTransformValue {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for PivotTransformValue {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ProjectTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"project\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ProjectTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<ProjectTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<ProjectTransformFields>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ProjectTransformType,
}
impl ::std::convert::From<&ProjectTransform> for ProjectTransform {
    fn from(value: &ProjectTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectTransformAs {
    Variant0(::std::vec::Vec<ProjectTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectTransformAs {
    fn from(value: &ProjectTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ProjectTransformAsVariant0Item>> for ProjectTransformAs {
    fn from(value: ::std::vec::Vec<ProjectTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for ProjectTransformAsVariant0Item {
    fn from(value: &ProjectTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ProjectTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectTransformFields {
    Variant0(::std::vec::Vec<ProjectTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectTransformFields {
    fn from(value: &ProjectTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ProjectTransformFieldsVariant0Item>>
    for ProjectTransformFields
{
    fn from(value: ::std::vec::Vec<ProjectTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for ProjectTransformFieldsVariant0Item {
    fn from(value: &ProjectTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for ProjectTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for ProjectTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for ProjectTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ProjectTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"project\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ProjectTransformType {
    #[serde(rename = "project")]
    Project,
}
impl ::std::convert::From<&Self> for ProjectTransformType {
    fn from(value: &ProjectTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ProjectTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Project => write!(f, "project"),
        }
    }
}
impl ::std::str::FromStr for ProjectTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "project" => Ok(Self::Project),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Projection`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"center\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"clipAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"clipExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"maxItems\": 2,"]
#[doc = "                \"minItems\": 2"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"maxItems\": 2,"]
#[doc = "                \"minItems\": 2"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parallels\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"precision\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"rotate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 3,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Projection {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub center: ::std::option::Option<ProjectionCenter>,
    #[serde(
        rename = "clipAngle",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub clip_angle: ::std::option::Option<NumberOrSignal>,
    #[serde(
        rename = "clipExtent",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub clip_extent: ::std::option::Option<ProjectionClipExtent>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<ProjectionExtent>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fit: ::std::option::Option<ProjectionFit>,
    pub name: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub parallels: ::std::option::Option<ProjectionParallels>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub point_radius: ::std::option::Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub precision: ::std::option::Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rotate: ::std::option::Option<ProjectionRotate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub scale: ::std::option::Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<ProjectionSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub translate: ::std::option::Option<ProjectionTranslate>,
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<StringOrSignal>,
}
impl ::std::convert::From<&Projection> for Projection {
    fn from(value: &Projection) -> Self {
        value.clone()
    }
}
#[doc = "`ProjectionCenter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionCenter {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionCenter {
    fn from(value: &ProjectionCenter) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionCenter {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionCenter {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionClipExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionClipExtent {
    Variant0([ProjectionClipExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionClipExtent {
    fn from(value: &ProjectionClipExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[ProjectionClipExtentVariant0Item; 2usize]> for ProjectionClipExtent {
    fn from(value: [ProjectionClipExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionClipExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionClipExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionClipExtentVariant0Item {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionClipExtentVariant0Item {
    fn from(value: &ProjectionClipExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionClipExtentVariant0Item {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionClipExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionExtent {
    Variant0([ProjectionExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionExtent {
    fn from(value: &ProjectionExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[ProjectionExtentVariant0Item; 2usize]> for ProjectionExtent {
    fn from(value: [ProjectionExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionExtentVariant0Item {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionExtentVariant0Item {
    fn from(value: &ProjectionExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionExtentVariant0Item {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionFit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionFit {
    Variant0(::serde_json::Map<::std::string::String, ::serde_json::Value>),
    Variant1(::std::vec::Vec<::serde_json::Value>),
}
impl ::std::convert::From<&Self> for ProjectionFit {
    fn from(value: &ProjectionFit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for ProjectionFit
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ProjectionFit {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionParallels`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionParallels {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionParallels {
    fn from(value: &ProjectionParallels) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionParallels {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionParallels {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionRotate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 3,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionRotate {
    Variant0(::std::vec::Vec<NumberOrSignal>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionRotate {
    fn from(value: &ProjectionRotate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ProjectionRotate {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionRotate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionSize {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionSize {
    fn from(value: &ProjectionSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionSize {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ProjectionTranslate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ProjectionTranslate {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ProjectionTranslate {
    fn from(value: &ProjectionTranslate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ProjectionTranslate {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ProjectionTranslate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"prob\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"probs\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 0.01,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"quantile\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct QuantileTransform {
    #[serde(rename = "as", default = "defaults::quantile_transform_as")]
    pub as_: QuantileTransformAs,
    pub field: QuantileTransformField,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<QuantileTransformGroupby>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub probs: ::std::option::Option<QuantileTransformProbs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default = "defaults::quantile_transform_step")]
    pub step: QuantileTransformStep,
    #[serde(rename = "type")]
    pub type_: QuantileTransformType,
}
impl ::std::convert::From<&QuantileTransform> for QuantileTransform {
    fn from(value: &QuantileTransform) -> Self {
        value.clone()
    }
}
#[doc = "`QuantileTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"prob\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformAs {
    Variant0(::std::vec::Vec<QuantileTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformAs {
    fn from(value: &QuantileTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QuantileTransformAs {
    fn default() -> Self {
        QuantileTransformAs::Variant0(vec![
            QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<QuantileTransformAsVariant0Item>>
    for QuantileTransformAs
{
    fn from(value: ::std::vec::Vec<QuantileTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformAsVariant0Item {
    fn from(value: &QuantileTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for QuantileTransformField {
    fn from(value: &QuantileTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for QuantileTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for QuantileTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for QuantileTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`QuantileTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformGroupby {
    Variant0(::std::vec::Vec<QuantileTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformGroupby {
    fn from(value: &QuantileTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<QuantileTransformGroupbyVariant0Item>>
    for QuantileTransformGroupby
{
    fn from(value: ::std::vec::Vec<QuantileTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for QuantileTransformGroupbyVariant0Item {
    fn from(value: &QuantileTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for QuantileTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for QuantileTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for QuantileTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`QuantileTransformProbs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformProbs {
    Variant0(::std::vec::Vec<QuantileTransformProbsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformProbs {
    fn from(value: &QuantileTransformProbs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<QuantileTransformProbsVariant0Item>>
    for QuantileTransformProbs
{
    fn from(value: ::std::vec::Vec<QuantileTransformProbsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformProbs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformProbsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformProbsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformProbsVariant0Item {
    fn from(value: &QuantileTransformProbsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for QuantileTransformProbsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformProbsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.01,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum QuantileTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for QuantileTransformStep {
    fn from(value: &QuantileTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for QuantileTransformStep {
    fn default() -> Self {
        QuantileTransformStep::Variant0(0.01_f64)
    }
}
impl ::std::convert::From<f64> for QuantileTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for QuantileTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`QuantileTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantile\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum QuantileTransformType {
    #[serde(rename = "quantile")]
    Quantile,
}
impl ::std::convert::From<&Self> for QuantileTransformType {
    fn from(value: &QuantileTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for QuantileTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Quantile => write!(f, "quantile"),
        }
    }
}
impl ::std::str::FromStr for QuantileTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RadialGradient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"stops\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"radial\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"r1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"r2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"stops\": {"]
#[doc = "      \"$ref\": \"#/definitions/gradientStops\""]
#[doc = "    },"]
#[doc = "    \"x1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RadialGradient {
    pub gradient: RadialGradientGradient,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub r1: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub r2: ::std::option::Option<f64>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x1: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub x2: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y1: ::std::option::Option<f64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub y2: ::std::option::Option<f64>,
}
impl ::std::convert::From<&RadialGradient> for RadialGradient {
    fn from(value: &RadialGradient) -> Self {
        value.clone()
    }
}
#[doc = "`RadialGradientGradient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"radial\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RadialGradientGradient {
    #[serde(rename = "radial")]
    Radial,
}
impl ::std::convert::From<&Self> for RadialGradientGradient {
    fn from(value: &RadialGradientGradient) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RadialGradientGradient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Radial => write!(f, "radial"),
        }
    }
}
impl ::std::str::FromStr for RadialGradientGradient {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RegressionTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"linear\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"order\": {"]
#[doc = "      \"default\": 3,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"regression\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct RegressionTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<RegressionTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<RegressionTransformExtent>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<RegressionTransformGroupby>,
    #[serde(default = "defaults::regression_transform_method")]
    pub method: RegressionTransformMethod,
    #[serde(default = "defaults::regression_transform_order")]
    pub order: RegressionTransformOrder,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<RegressionTransformParams>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: RegressionTransformType,
    pub x: RegressionTransformX,
    pub y: RegressionTransformY,
}
impl ::std::convert::From<&RegressionTransform> for RegressionTransform {
    fn from(value: &RegressionTransform) -> Self {
        value.clone()
    }
}
#[doc = "`RegressionTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformAs {
    Variant0(::std::vec::Vec<RegressionTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformAs {
    fn from(value: &RegressionTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<RegressionTransformAsVariant0Item>>
    for RegressionTransformAs
{
    fn from(value: ::std::vec::Vec<RegressionTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformAsVariant0Item {
    fn from(value: &RegressionTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformExtent {
    Variant0([RegressionTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformExtent {
    fn from(value: &RegressionTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[RegressionTransformExtentVariant0Item; 2usize]>
    for RegressionTransformExtent
{
    fn from(value: [RegressionTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformExtentVariant0Item {
    fn from(value: &RegressionTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for RegressionTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformGroupby {
    Variant0(::std::vec::Vec<RegressionTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformGroupby {
    fn from(value: &RegressionTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<RegressionTransformGroupbyVariant0Item>>
    for RegressionTransformGroupby
{
    fn from(value: ::std::vec::Vec<RegressionTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for RegressionTransformGroupbyVariant0Item {
    fn from(value: &RegressionTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for RegressionTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for RegressionTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for RegressionTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`RegressionTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"linear\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformMethod {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformMethod {
    fn from(value: &RegressionTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RegressionTransformMethod {
    fn default() -> Self {
        RegressionTransformMethod::Variant0("linear".to_string())
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformOrder`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 3,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformOrder {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformOrder {
    fn from(value: &RegressionTransformOrder) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RegressionTransformOrder {
    fn default() -> Self {
        RegressionTransformOrder::Variant0(3_f64)
    }
}
impl ::std::convert::From<f64> for RegressionTransformOrder {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformOrder {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformParams {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for RegressionTransformParams {
    fn from(value: &RegressionTransformParams) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for RegressionTransformParams {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for RegressionTransformParams {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`RegressionTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"regression\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RegressionTransformType {
    #[serde(rename = "regression")]
    Regression,
}
impl ::std::convert::From<&Self> for RegressionTransformType {
    fn from(value: &RegressionTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RegressionTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Regression => write!(f, "regression"),
        }
    }
}
impl ::std::str::FromStr for RegressionTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "regression" => Ok(Self::Regression),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RegressionTransformX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for RegressionTransformX {
    fn from(value: &RegressionTransformX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for RegressionTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for RegressionTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for RegressionTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`RegressionTransformY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RegressionTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for RegressionTransformY {
    fn from(value: &RegressionTransformY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for RegressionTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for RegressionTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for RegressionTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`ResolvefilterTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"filter\","]
#[doc = "    \"ignore\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"filter\": {},"]
#[doc = "    \"ignore\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolvefilter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct ResolvefilterTransform {
    pub filter: ::serde_json::Value,
    pub ignore: ResolvefilterTransformIgnore,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: ResolvefilterTransformType,
}
impl ::std::convert::From<&ResolvefilterTransform> for ResolvefilterTransform {
    fn from(value: &ResolvefilterTransform) -> Self {
        value.clone()
    }
}
#[doc = "`ResolvefilterTransformIgnore`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ResolvefilterTransformIgnore {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ResolvefilterTransformIgnore {
    fn from(value: &ResolvefilterTransformIgnore) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for ResolvefilterTransformIgnore {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ResolvefilterTransformIgnore {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ResolvefilterTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolvefilter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ResolvefilterTransformType {
    #[serde(rename = "resolvefilter")]
    Resolvefilter,
}
impl ::std::convert::From<&Self> for ResolvefilterTransformType {
    fn from(value: &ResolvefilterTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ResolvefilterTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Resolvefilter => write!(f, "resolvefilter"),
        }
    }
}
impl ::std::str::FromStr for ResolvefilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "resolvefilter" => Ok(Self::Resolvefilter),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Rule`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"test\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Rule {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub test: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Rule> for Rule {
    fn from(value: &Rule) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Rule {
    fn default() -> Self {
        Self {
            test: Default::default(),
        }
    }
}
#[doc = "`SampleTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"default\": 1000,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"sample\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SampleTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default = "defaults::sample_transform_size")]
    pub size: SampleTransformSize,
    #[serde(rename = "type")]
    pub type_: SampleTransformType,
}
impl ::std::convert::From<&SampleTransform> for SampleTransform {
    fn from(value: &SampleTransform) -> Self {
        value.clone()
    }
}
#[doc = "`SampleTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1000,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SampleTransformSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SampleTransformSize {
    fn from(value: &SampleTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SampleTransformSize {
    fn default() -> Self {
        SampleTransformSize::Variant0(1000_f64)
    }
}
impl ::std::convert::From<f64> for SampleTransformSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for SampleTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SampleTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"sample\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SampleTransformType {
    #[serde(rename = "sample")]
    Sample,
}
impl ::std::convert::From<&Self> for SampleTransformType {
    fn from(value: &SampleTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SampleTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Sample => write!(f, "sample"),
        }
    }
}
impl ::std::str::FromStr for SampleTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "sample" => Ok(Self::Sample),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Scale`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"identity\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainImplicit\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"data\","]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"data\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"data\","]
#[doc = "                    \"fields\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"data\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"fields\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"minItems\": 1"]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"required\": ["]
#[doc = "                            \"field\","]
#[doc = "                            \"op\""]
#[doc = "                          ],"]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\","]
#[doc = "                                \"min\","]
#[doc = "                                \"max\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"fields\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"fields\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"object\","]
#[doc = "                            \"required\": ["]
#[doc = "                              \"data\","]
#[doc = "                              \"field\""]
#[doc = "                            ],"]
#[doc = "                            \"properties\": {"]
#[doc = "                              \"data\": {"]
#[doc = "                                \"type\": \"string\""]
#[doc = "                              },"]
#[doc = "                              \"field\": {"]
#[doc = "                                \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                              }"]
#[doc = "                            },"]
#[doc = "                            \"additionalProperties\": false"]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"type\": \"array\","]
#[doc = "                            \"items\": {"]
#[doc = "                              \"oneOf\": ["]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"string\""]
#[doc = "                                },"]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"number\""]
#[doc = "                                },"]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"boolean\""]
#[doc = "                                }"]
#[doc = "                              ]"]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      \"minItems\": 1"]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"required\": ["]
#[doc = "                            \"field\","]
#[doc = "                            \"op\""]
#[doc = "                          ],"]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\","]
#[doc = "                                \"min\","]
#[doc = "                                \"max\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"ordinal\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingInner\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingOuter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"step\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"band\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingOuter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"step\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"point\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"quantize\","]
#[doc = "            \"threshold\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"quantile\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"bin-ordinal\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"interval\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"interval\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"millisecond\","]
#[doc = "                        \"second\","]
#[doc = "                        \"minute\","]
#[doc = "                        \"hour\","]
#[doc = "                        \"day\","]
#[doc = "                        \"week\","]
#[doc = "                        \"month\","]
#[doc = "                        \"year\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"time\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"linear\","]
#[doc = "            \"sqrt\","]
#[doc = "            \"sequential\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"base\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"log\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"pow\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"constant\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"symlog\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Scale {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant0Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant0DomainRaw>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant1Domain>,
        #[serde(
            rename = "domainImplicit",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_implicit: ::std::option::Option<BooleanOrSignal>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant1DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant1Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant1Type,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        align: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant2Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant2DomainRaw>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "paddingInner",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        padding_inner: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        padding_outer: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant2Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant2Type,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        align: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant3Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant3DomainRaw>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        padding_outer: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant3Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant3Type,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant4Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant4DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant4Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant4Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant4Type,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zero: ::std::option::Option<BooleanOrSignal>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant5Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant5DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant5Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant5Type,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant6Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant6DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant6Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant6Type,
    },
    Variant7 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        clamp: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant7Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant7DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant7Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant7Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant7Type,
    },
    Variant8 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        clamp: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant8Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant8DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant8Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant8Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(
            rename = "type",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        type_: ::std::option::Option<ScaleVariant8Type>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zero: ::std::option::Option<BooleanOrSignal>,
    },
    Variant9 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        base: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        clamp: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant9Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant9DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant9Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant9Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant9Type,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zero: ::std::option::Option<BooleanOrSignal>,
    },
    Variant10 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        clamp: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant10Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant10DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        exponent: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant10Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant10Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant10Type,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zero: ::std::option::Option<BooleanOrSignal>,
    },
    Variant11 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bins: ::std::option::Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        clamp: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        constant: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        domain: ::std::option::Option<ScaleVariant11Domain>,
        #[serde(
            rename = "domainMax",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_max: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMid",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_mid: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainMin",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_min: ::std::option::Option<NumberOrSignal>,
        #[serde(
            rename = "domainRaw",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        domain_raw: ::std::option::Option<ScaleVariant11DomainRaw>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interpolate: ::std::option::Option<ScaleInterpolate>,
        name: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        nice: ::std::option::Option<ScaleVariant11Nice>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        range: ::std::option::Option<ScaleVariant11Range>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        reverse: ::std::option::Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        round: ::std::option::Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant11Type,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zero: ::std::option::Option<BooleanOrSignal>,
    },
}
impl ::std::convert::From<&Self> for Scale {
    fn from(value: &Scale) -> Self {
        value.clone()
    }
}
#[doc = "`ScaleBins`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"start\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"stop\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleBins {
    Variant0(::std::vec::Vec<NumberOrSignal>),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        start: ::std::option::Option<NumberOrSignal>,
        step: NumberOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        stop: ::std::option::Option<NumberOrSignal>,
    },
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleBins {
    fn from(value: &ScaleBins) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleBins {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleBins {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleData`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"data\","]
#[doc = "                  \"field\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"data\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"field\": {"]
#[doc = "                    \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleData {
    Variant0 {
        data: ::std::string::String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleDataVariant0Sort>,
    },
    Variant1 {
        data: ::std::string::String,
        fields: ::std::vec::Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleDataVariant1Sort>,
    },
    Variant2 {
        fields: ::std::vec::Vec<ScaleDataVariant2FieldsItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleDataVariant2Sort>,
    },
}
impl ::std::convert::From<&Self> for ScaleData {
    fn from(value: &ScaleData) -> Self {
        value.clone()
    }
}
#[doc = "`ScaleDataVariant0Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        field: ::std::option::Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleDataVariant0Sort {
    fn from(value: &ScaleDataVariant0Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleDataVariant0Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleDataVariant1Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<ScaleDataVariant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleDataVariant1Sort {
    fn from(value: &ScaleDataVariant1Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleDataVariant1Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleDataVariant1SortVariant1Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleDataVariant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl ::std::convert::From<&Self> for ScaleDataVariant1SortVariant1Op {
    fn from(value: &ScaleDataVariant1SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleDataVariant1SortVariant1Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
        }
    }
}
impl ::std::str::FromStr for ScaleDataVariant1SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleDataVariant1SortVariant2Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleDataVariant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ::std::convert::From<&Self> for ScaleDataVariant1SortVariant2Op {
    fn from(value: &ScaleDataVariant1SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleDataVariant1SortVariant2Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
        }
    }
}
impl ::std::str::FromStr for ScaleDataVariant1SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleDataVariant2FieldsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2FieldsItem {
    Variant0 {
        data: ::std::string::String,
        field: StringOrSignal,
    },
    Variant1(::std::vec::Vec<ScaleDataVariant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleDataVariant2FieldsItem {
    fn from(value: &ScaleDataVariant2FieldsItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleDataVariant2FieldsItemVariant1Item>>
    for ScaleDataVariant2FieldsItem
{
    fn from(value: ::std::vec::Vec<ScaleDataVariant2FieldsItemVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleDataVariant2FieldsItem {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleDataVariant2FieldsItemVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleDataVariant2FieldsItemVariant1Item {
    Variant0(::std::string::String),
    Variant1(f64),
    Variant2(bool),
}
impl ::std::convert::From<&Self> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: &ScaleDataVariant2FieldsItemVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ScaleDataVariant2FieldsItemVariant1Item {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ScaleDataVariant2FieldsItemVariant1Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
            Self::Variant2(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<bool> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleDataVariant2Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<ScaleDataVariant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleDataVariant2Sort {
    fn from(value: &ScaleDataVariant2Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleDataVariant2Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleDataVariant2SortVariant1Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleDataVariant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl ::std::convert::From<&Self> for ScaleDataVariant2SortVariant1Op {
    fn from(value: &ScaleDataVariant2SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleDataVariant2SortVariant1Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
        }
    }
}
impl ::std::str::FromStr for ScaleDataVariant2SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleDataVariant2SortVariant2Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleDataVariant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ::std::convert::From<&Self> for ScaleDataVariant2SortVariant2Op {
    fn from(value: &ScaleDataVariant2SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleDataVariant2SortVariant2Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
        }
    }
}
impl ::std::str::FromStr for ScaleDataVariant2SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ScaleField(pub StringOrSignal);
impl ::std::ops::Deref for ScaleField {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl ::std::convert::From<ScaleField> for StringOrSignal {
    fn from(value: ScaleField) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ScaleField> for ScaleField {
    fn from(value: &ScaleField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringOrSignal> for ScaleField {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[doc = "`ScaleInterpolate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"gamma\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleInterpolate {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        gamma: ::std::option::Option<NumberOrSignal>,
        #[serde(rename = "type")]
        type_: StringOrSignal,
    },
}
impl ::std::convert::From<&Self> for ScaleInterpolate {
    fn from(value: &ScaleInterpolate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleInterpolate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant0Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant0Domain {
    Variant0(::std::vec::Vec<ScaleVariant0DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant0Domain {
    fn from(value: &ScaleVariant0Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant0DomainVariant0Item>>
    for ScaleVariant0Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant0DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant0Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant0Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant0DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant0DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant0DomainRaw {
    fn from(value: &ScaleVariant0DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant0DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant0DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant0DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant0DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant0DomainVariant0Item {
    fn from(value: &ScaleVariant0DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant0DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant0DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant0DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant0DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"identity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant0Type {
    #[serde(rename = "identity")]
    Identity,
}
impl ::std::convert::From<&Self> for ScaleVariant0Type {
    fn from(value: &ScaleVariant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Identity => write!(f, "identity"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "identity" => Ok(Self::Identity),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant10Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10Domain {
    Variant0(::std::vec::Vec<ScaleVariant10DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10Domain {
    fn from(value: &ScaleVariant10Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant10DomainVariant0Item>>
    for ScaleVariant10Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant10DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant10Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant10DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10DomainRaw {
    fn from(value: &ScaleVariant10DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant10DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant10DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant10DomainVariant0Item {
    fn from(value: &ScaleVariant10DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant10DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant10DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant10DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant10Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10Nice {
    fn from(value: &ScaleVariant10Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant10Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant10Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant10Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant10Range {
    Variant0(ScaleVariant10RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant10RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant10RangeVariant2Extent>,
        scheme: ScaleVariant10RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10Range {
    fn from(value: &ScaleVariant10Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant10RangeVariant0> for ScaleVariant10Range {
    fn from(value: ScaleVariant10RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant10RangeVariant1Item>>
    for ScaleVariant10Range
{
    fn from(value: ::std::vec::Vec<ScaleVariant10RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant10RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant10RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant10RangeVariant0 {
    fn from(value: &ScaleVariant10RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant10RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant10RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant10RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant10RangeVariant1Item {
    fn from(value: &ScaleVariant10RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant10RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant10RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant10RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant10RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10RangeVariant2Extent {
    fn from(value: &ScaleVariant10RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant10RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant10RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10RangeVariant2Scheme {
    fn from(value: &ScaleVariant10RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>>
    for ScaleVariant10RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant10RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant10RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant10RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant10RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant10Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pow\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant10Type {
    #[serde(rename = "pow")]
    Pow,
}
impl ::std::convert::From<&Self> for ScaleVariant10Type {
    fn from(value: &ScaleVariant10Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant10Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Pow => write!(f, "pow"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant10Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "pow" => Ok(Self::Pow),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant11Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11Domain {
    Variant0(::std::vec::Vec<ScaleVariant11DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11Domain {
    fn from(value: &ScaleVariant11Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant11DomainVariant0Item>>
    for ScaleVariant11Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant11DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant11Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant11DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11DomainRaw {
    fn from(value: &ScaleVariant11DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant11DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant11DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant11DomainVariant0Item {
    fn from(value: &ScaleVariant11DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant11DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant11DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant11DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant11Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11Nice {
    fn from(value: &ScaleVariant11Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant11Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant11Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant11Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant11Range {
    Variant0(ScaleVariant11RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant11RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant11RangeVariant2Extent>,
        scheme: ScaleVariant11RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11Range {
    fn from(value: &ScaleVariant11Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant11RangeVariant0> for ScaleVariant11Range {
    fn from(value: ScaleVariant11RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant11RangeVariant1Item>>
    for ScaleVariant11Range
{
    fn from(value: ::std::vec::Vec<ScaleVariant11RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant11RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant11RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant11RangeVariant0 {
    fn from(value: &ScaleVariant11RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant11RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant11RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant11RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant11RangeVariant1Item {
    fn from(value: &ScaleVariant11RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant11RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant11RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant11RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant11RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11RangeVariant2Extent {
    fn from(value: &ScaleVariant11RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant11RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant11RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11RangeVariant2Scheme {
    fn from(value: &ScaleVariant11RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>>
    for ScaleVariant11RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant11RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant11RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant11RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant11RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant11Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"symlog\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant11Type {
    #[serde(rename = "symlog")]
    Symlog,
}
impl ::std::convert::From<&Self> for ScaleVariant11Type {
    fn from(value: &ScaleVariant11Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant11Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Symlog => write!(f, "symlog"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant11Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "symlog" => Ok(Self::Symlog),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1Domain {
    Variant0(::std::vec::Vec<ScaleVariant1DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1Domain {
    fn from(value: &ScaleVariant1Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant1DomainVariant0Item>>
    for ScaleVariant1Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant1DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant1Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant1DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1DomainRaw {
    fn from(value: &ScaleVariant1DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant1DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant1DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant1DomainVariant0Item {
    fn from(value: &ScaleVariant1DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant1DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant1DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant1DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant1Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"fields\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\","]
#[doc = "                    \"op\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\","]
#[doc = "                        \"min\","]
#[doc = "                        \"max\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"fields\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"data\","]
#[doc = "                      \"field\""]
#[doc = "                    ],"]
#[doc = "                    \"properties\": {"]
#[doc = "                      \"data\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      },"]
#[doc = "                      \"field\": {"]
#[doc = "                        \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"additionalProperties\": false"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\","]
#[doc = "                    \"op\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\","]
#[doc = "                        \"min\","]
#[doc = "                        \"max\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1Range {
    Variant0(ScaleVariant1RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant1RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant1RangeVariant2Extent>,
        scheme: ScaleVariant1RangeVariant2Scheme,
    },
    Variant3(ScaleVariant1RangeVariant3),
    Variant4(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1Range {
    fn from(value: &ScaleVariant1Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant1RangeVariant0> for ScaleVariant1Range {
    fn from(value: ScaleVariant1RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant1RangeVariant1Item>> for ScaleVariant1Range {
    fn from(value: ::std::vec::Vec<ScaleVariant1RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<ScaleVariant1RangeVariant3> for ScaleVariant1Range {
    fn from(value: ScaleVariant1RangeVariant3) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant0 {
    fn from(value: &ScaleVariant1RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant1Item {
    fn from(value: &ScaleVariant1RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant1RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant1RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant1RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant2Extent {
    fn from(value: &ScaleVariant1RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant1RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: &ScaleVariant1RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>>
    for ScaleVariant1RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant1RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"data\","]
#[doc = "                  \"field\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"data\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"field\": {"]
#[doc = "                    \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3 {
    Variant0 {
        data: ::std::string::String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleVariant1RangeVariant3Variant0Sort>,
    },
    Variant1 {
        data: ::std::string::String,
        fields: ::std::vec::Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleVariant1RangeVariant3Variant1Sort>,
    },
    Variant2 {
        fields: ::std::vec::Vec<ScaleVariant1RangeVariant3Variant2FieldsItem>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        sort: ::std::option::Option<ScaleVariant1RangeVariant3Variant2Sort>,
    },
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3 {
    fn from(value: &ScaleVariant1RangeVariant3) -> Self {
        value.clone()
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant0Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        field: ::std::option::Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant0Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant0Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant1RangeVariant3Variant0Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant1Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<ScaleVariant1RangeVariant3Variant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant1Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant1Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant1RangeVariant3Variant1Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant1SortVariant1Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn from(value: &ScaleVariant1RangeVariant3Variant1SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ScaleVariant1RangeVariant3Variant1SortVariant1Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ScaleVariant1RangeVariant3Variant1SortVariant1Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant1SortVariant2Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn from(value: &ScaleVariant1RangeVariant3Variant1SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ScaleVariant1RangeVariant3Variant1SortVariant2Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ScaleVariant1RangeVariant3Variant1SortVariant2Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant2FieldsItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItem {
    Variant0 {
        data: ::std::string::String,
        field: StringOrSignal,
    },
    Variant1(::std::vec::Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant2FieldsItem {
    fn from(value: &ScaleVariant1RangeVariant3Variant2FieldsItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>>
    for ScaleVariant1RangeVariant3Variant2FieldsItem
{
    fn from(
        value: ::std::vec::Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant1RangeVariant3Variant2FieldsItem {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    Variant0(::std::string::String),
    Variant1(f64),
    Variant2(bool),
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: &ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
            Self::Variant2(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<bool> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant2Sort`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        op: ::std::option::Option<ScaleVariant1RangeVariant3Variant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        order: ::std::option::Option<SortOrder>,
    },
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant2Sort {
    fn from(value: &ScaleVariant1RangeVariant3Variant2Sort) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant1RangeVariant3Variant2Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant2SortVariant1Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn from(value: &ScaleVariant1RangeVariant3Variant2SortVariant1Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ScaleVariant1RangeVariant3Variant2SortVariant1Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ScaleVariant1RangeVariant3Variant2SortVariant1Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1RangeVariant3Variant2SortVariant2Op`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl ::std::convert::From<&Self> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn from(value: &ScaleVariant1RangeVariant3Variant2SortVariant2Op) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Count => write!(f, "count"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ScaleVariant1RangeVariant3Variant2SortVariant2Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ScaleVariant1RangeVariant3Variant2SortVariant2Op
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"ordinal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant1Type {
    #[serde(rename = "ordinal")]
    Ordinal,
}
impl ::std::convert::From<&Self> for ScaleVariant1Type {
    fn from(value: &ScaleVariant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Ordinal => write!(f, "ordinal"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ordinal" => Ok(Self::Ordinal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant2Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant2Domain {
    Variant0(::std::vec::Vec<ScaleVariant2DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant2Domain {
    fn from(value: &ScaleVariant2Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant2DomainVariant0Item>>
    for ScaleVariant2Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant2DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant2Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant2Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant2DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant2DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant2DomainRaw {
    fn from(value: &ScaleVariant2DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant2DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant2DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant2DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant2DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant2DomainVariant0Item {
    fn from(value: &ScaleVariant2DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant2DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant2DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant2DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant2DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant2Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant2Range {
    Variant0(ScaleVariant2RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant2RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant2Range {
    fn from(value: &ScaleVariant2Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant2RangeVariant0> for ScaleVariant2Range {
    fn from(value: ScaleVariant2RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant2RangeVariant1Item>> for ScaleVariant2Range {
    fn from(value: ::std::vec::Vec<ScaleVariant2RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant2Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant2RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant2RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant2RangeVariant0 {
    fn from(value: &ScaleVariant2RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant2RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant2RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant2RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant2RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant2RangeVariant1Item {
    fn from(value: &ScaleVariant2RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant2RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant2RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant2RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant2RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant2Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"band\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant2Type {
    #[serde(rename = "band")]
    Band,
}
impl ::std::convert::From<&Self> for ScaleVariant2Type {
    fn from(value: &ScaleVariant2Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant2Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Band => write!(f, "band"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "band" => Ok(Self::Band),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant3Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant3Domain {
    Variant0(::std::vec::Vec<ScaleVariant3DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant3Domain {
    fn from(value: &ScaleVariant3Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant3DomainVariant0Item>>
    for ScaleVariant3Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant3DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant3Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant3Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant3DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant3DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant3DomainRaw {
    fn from(value: &ScaleVariant3DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant3DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant3DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant3DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant3DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant3DomainVariant0Item {
    fn from(value: &ScaleVariant3DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant3DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant3DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant3DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant3DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant3Range {
    Variant0(ScaleVariant3RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant3RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant3Range {
    fn from(value: &ScaleVariant3Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant3RangeVariant0> for ScaleVariant3Range {
    fn from(value: ScaleVariant3RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant3RangeVariant1Item>> for ScaleVariant3Range {
    fn from(value: ::std::vec::Vec<ScaleVariant3RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant3Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant3RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant3RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant3RangeVariant0 {
    fn from(value: &ScaleVariant3RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant3RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant3RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant3RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant3RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant3RangeVariant1Item {
    fn from(value: &ScaleVariant3RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant3RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant3RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant3RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant3RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant3Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"point\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant3Type {
    #[serde(rename = "point")]
    Point,
}
impl ::std::convert::From<&Self> for ScaleVariant3Type {
    fn from(value: &ScaleVariant3Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant3Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Point => write!(f, "point"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "point" => Ok(Self::Point),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant4Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4Domain {
    Variant0(::std::vec::Vec<ScaleVariant4DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4Domain {
    fn from(value: &ScaleVariant4Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant4DomainVariant0Item>>
    for ScaleVariant4Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant4DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant4Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant4DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4DomainRaw {
    fn from(value: &ScaleVariant4DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant4DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant4DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant4DomainVariant0Item {
    fn from(value: &ScaleVariant4DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant4DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant4DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant4DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant4Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4Nice {
    fn from(value: &ScaleVariant4Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant4Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant4Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant4Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant4Range {
    Variant0(ScaleVariant4RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant4RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant4RangeVariant2Extent>,
        scheme: ScaleVariant4RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4Range {
    fn from(value: &ScaleVariant4Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant4RangeVariant0> for ScaleVariant4Range {
    fn from(value: ScaleVariant4RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant4RangeVariant1Item>> for ScaleVariant4Range {
    fn from(value: ::std::vec::Vec<ScaleVariant4RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant4RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant4RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant4RangeVariant0 {
    fn from(value: &ScaleVariant4RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant4RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant4RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant4RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant4RangeVariant1Item {
    fn from(value: &ScaleVariant4RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant4RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant4RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant4RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant4RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4RangeVariant2Extent {
    fn from(value: &ScaleVariant4RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant4RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant4RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: &ScaleVariant4RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>>
    for ScaleVariant4RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant4RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant4RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant4RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant4RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant4Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantize\","]
#[doc = "    \"threshold\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant4Type {
    #[serde(rename = "quantize")]
    Quantize,
    #[serde(rename = "threshold")]
    Threshold,
}
impl ::std::convert::From<&Self> for ScaleVariant4Type {
    fn from(value: &ScaleVariant4Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant4Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Quantize => write!(f, "quantize"),
            Self::Threshold => write!(f, "threshold"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant4Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "quantize" => Ok(Self::Quantize),
            "threshold" => Ok(Self::Threshold),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant5Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5Domain {
    Variant0(::std::vec::Vec<ScaleVariant5DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5Domain {
    fn from(value: &ScaleVariant5Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant5DomainVariant0Item>>
    for ScaleVariant5Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant5DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant5Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant5DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5DomainRaw {
    fn from(value: &ScaleVariant5DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant5DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant5DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant5DomainVariant0Item {
    fn from(value: &ScaleVariant5DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant5DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant5DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant5DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant5Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant5Range {
    Variant0(ScaleVariant5RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant5RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant5RangeVariant2Extent>,
        scheme: ScaleVariant5RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5Range {
    fn from(value: &ScaleVariant5Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant5RangeVariant0> for ScaleVariant5Range {
    fn from(value: ScaleVariant5RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant5RangeVariant1Item>> for ScaleVariant5Range {
    fn from(value: ::std::vec::Vec<ScaleVariant5RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant5RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant5RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant5RangeVariant0 {
    fn from(value: &ScaleVariant5RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant5RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant5RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant5RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant5RangeVariant1Item {
    fn from(value: &ScaleVariant5RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant5RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant5RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant5RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant5RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5RangeVariant2Extent {
    fn from(value: &ScaleVariant5RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant5RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant5RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: &ScaleVariant5RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>>
    for ScaleVariant5RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant5RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant5RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant5RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant5RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant5Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantile\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant5Type {
    #[serde(rename = "quantile")]
    Quantile,
}
impl ::std::convert::From<&Self> for ScaleVariant5Type {
    fn from(value: &ScaleVariant5Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant5Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Quantile => write!(f, "quantile"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant5Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant6Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6Domain {
    Variant0(::std::vec::Vec<ScaleVariant6DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6Domain {
    fn from(value: &ScaleVariant6Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant6DomainVariant0Item>>
    for ScaleVariant6Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant6DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant6Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant6DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6DomainRaw {
    fn from(value: &ScaleVariant6DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant6DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant6DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant6DomainVariant0Item {
    fn from(value: &ScaleVariant6DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant6DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant6DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant6DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant6Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant6Range {
    Variant0(ScaleVariant6RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant6RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant6RangeVariant2Extent>,
        scheme: ScaleVariant6RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6Range {
    fn from(value: &ScaleVariant6Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant6RangeVariant0> for ScaleVariant6Range {
    fn from(value: ScaleVariant6RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant6RangeVariant1Item>> for ScaleVariant6Range {
    fn from(value: ::std::vec::Vec<ScaleVariant6RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant6RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant6RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant6RangeVariant0 {
    fn from(value: &ScaleVariant6RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant6RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant6RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant6RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant6RangeVariant1Item {
    fn from(value: &ScaleVariant6RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant6RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant6RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant6RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant6RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6RangeVariant2Extent {
    fn from(value: &ScaleVariant6RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant6RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant6RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: &ScaleVariant6RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>>
    for ScaleVariant6RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant6RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant6RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant6RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant6RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant6Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"bin-ordinal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant6Type {
    #[serde(rename = "bin-ordinal")]
    BinOrdinal,
}
impl ::std::convert::From<&Self> for ScaleVariant6Type {
    fn from(value: &ScaleVariant6Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant6Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::BinOrdinal => write!(f, "bin-ordinal"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant6Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "bin-ordinal" => Ok(Self::BinOrdinal),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant7Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7Domain {
    Variant0(::std::vec::Vec<ScaleVariant7DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7Domain {
    fn from(value: &ScaleVariant7Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant7DomainVariant0Item>>
    for ScaleVariant7Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant7DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant7Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant7DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7DomainRaw {
    fn from(value: &ScaleVariant7DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant7DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant7DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant7DomainVariant0Item {
    fn from(value: &ScaleVariant7DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant7DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant7DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant7DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant7Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"interval\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"interval\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Nice {
    Variant0(bool),
    Variant1(ScaleVariant7NiceVariant1),
    Variant2 {
        interval: ScaleVariant7NiceVariant2Interval,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        step: ::std::option::Option<NumberOrSignal>,
    },
}
impl ::std::convert::From<&Self> for ScaleVariant7Nice {
    fn from(value: &ScaleVariant7Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant7Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleVariant7NiceVariant1> for ScaleVariant7Nice {
    fn from(value: ScaleVariant7NiceVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant7NiceVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant7NiceVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ::std::convert::From<&Self> for ScaleVariant7NiceVariant1 {
    fn from(value: &ScaleVariant7NiceVariant1) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant7NiceVariant1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Millisecond => write!(f, "millisecond"),
            Self::Second => write!(f, "second"),
            Self::Minute => write!(f, "minute"),
            Self::Hour => write!(f, "hour"),
            Self::Day => write!(f, "day"),
            Self::Week => write!(f, "week"),
            Self::Month => write!(f, "month"),
            Self::Year => write!(f, "year"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant7NiceVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant7NiceVariant2Interval`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7NiceVariant2Interval {
    Variant0(ScaleVariant7NiceVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7NiceVariant2Interval {
    fn from(value: &ScaleVariant7NiceVariant2Interval) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant7NiceVariant2IntervalVariant0>
    for ScaleVariant7NiceVariant2Interval
{
    fn from(value: ScaleVariant7NiceVariant2IntervalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7NiceVariant2Interval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant7NiceVariant2IntervalVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant7NiceVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ::std::convert::From<&Self> for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn from(value: &ScaleVariant7NiceVariant2IntervalVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Millisecond => write!(f, "millisecond"),
            Self::Second => write!(f, "second"),
            Self::Minute => write!(f, "minute"),
            Self::Hour => write!(f, "hour"),
            Self::Day => write!(f, "day"),
            Self::Week => write!(f, "week"),
            Self::Month => write!(f, "month"),
            Self::Year => write!(f, "year"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant7Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Range {
    Variant0(ScaleVariant7RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant7RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant7RangeVariant2Extent>,
        scheme: ScaleVariant7RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7Range {
    fn from(value: &ScaleVariant7Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant7RangeVariant0> for ScaleVariant7Range {
    fn from(value: ScaleVariant7RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant7RangeVariant1Item>> for ScaleVariant7Range {
    fn from(value: ::std::vec::Vec<ScaleVariant7RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant7RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant7RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant7RangeVariant0 {
    fn from(value: &ScaleVariant7RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant7RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant7RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant7RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant7RangeVariant1Item {
    fn from(value: &ScaleVariant7RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant7RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant7RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant7RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant7RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7RangeVariant2Extent {
    fn from(value: &ScaleVariant7RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant7RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant7RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: &ScaleVariant7RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>>
    for ScaleVariant7RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant7RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant7RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant7RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant7RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant7Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant7Type {
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for ScaleVariant7Type {
    fn from(value: &ScaleVariant7Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant7Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Time => write!(f, "time"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant7Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant8Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8Domain {
    Variant0(::std::vec::Vec<ScaleVariant8DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8Domain {
    fn from(value: &ScaleVariant8Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant8DomainVariant0Item>>
    for ScaleVariant8Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant8DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant8Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant8DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8DomainRaw {
    fn from(value: &ScaleVariant8DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant8DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant8DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant8DomainVariant0Item {
    fn from(value: &ScaleVariant8DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant8DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant8DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant8DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant8Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8Nice {
    fn from(value: &ScaleVariant8Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant8Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant8Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant8Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant8Range {
    Variant0(ScaleVariant8RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant8RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant8RangeVariant2Extent>,
        scheme: ScaleVariant8RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8Range {
    fn from(value: &ScaleVariant8Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant8RangeVariant0> for ScaleVariant8Range {
    fn from(value: ScaleVariant8RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant8RangeVariant1Item>> for ScaleVariant8Range {
    fn from(value: ::std::vec::Vec<ScaleVariant8RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant8RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant8RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant8RangeVariant0 {
    fn from(value: &ScaleVariant8RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant8RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant8RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant8RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant8RangeVariant1Item {
    fn from(value: &ScaleVariant8RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant8RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant8RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant8RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant8RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8RangeVariant2Extent {
    fn from(value: &ScaleVariant8RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant8RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant8RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: &ScaleVariant8RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>>
    for ScaleVariant8RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant8RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant8RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant8RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant8RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant8Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linear\","]
#[doc = "    \"sqrt\","]
#[doc = "    \"sequential\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant8Type {
    #[serde(rename = "linear")]
    Linear,
    #[serde(rename = "sqrt")]
    Sqrt,
    #[serde(rename = "sequential")]
    Sequential,
}
impl ::std::convert::From<&Self> for ScaleVariant8Type {
    fn from(value: &ScaleVariant8Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant8Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Linear => write!(f, "linear"),
            Self::Sqrt => write!(f, "sqrt"),
            Self::Sequential => write!(f, "sequential"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant8Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "linear" => Ok(Self::Linear),
            "sqrt" => Ok(Self::Sqrt),
            "sequential" => Ok(Self::Sequential),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant9Domain`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9Domain {
    Variant0(::std::vec::Vec<ScaleVariant9DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9Domain {
    fn from(value: &ScaleVariant9Domain) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant9DomainVariant0Item>>
    for ScaleVariant9Domain
{
    fn from(value: ::std::vec::Vec<ScaleVariant9DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ScaleData> for ScaleVariant9Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant9DomainRaw`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9DomainRaw {
    Variant0,
    Variant1(::std::vec::Vec<::serde_json::Value>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9DomainRaw {
    fn from(value: &ScaleVariant9DomainRaw) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::serde_json::Value>> for ScaleVariant9DomainRaw {
    fn from(value: ::std::vec::Vec<::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant9DomainVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant9DomainVariant0Item {
    fn from(value: &ScaleVariant9DomainVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant9DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant9DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant9DomainVariant0Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant9Nice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9Nice {
    fn from(value: &ScaleVariant9Nice) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant9Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant9Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant9Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant9Range {
    Variant0(ScaleVariant9RangeVariant0),
    Variant1(::std::vec::Vec<ScaleVariant9RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        count: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        extent: ::std::option::Option<ScaleVariant9RangeVariant2Extent>,
        scheme: ScaleVariant9RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9Range {
    fn from(value: &ScaleVariant9Range) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleVariant9RangeVariant0> for ScaleVariant9Range {
    fn from(value: ScaleVariant9RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant9RangeVariant1Item>> for ScaleVariant9Range {
    fn from(value: ::std::vec::Vec<ScaleVariant9RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`ScaleVariant9RangeVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant9RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl ::std::convert::From<&Self> for ScaleVariant9RangeVariant0 {
    fn from(value: &ScaleVariant9RangeVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant9RangeVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Width => write!(f, "width"),
            Self::Height => write!(f, "height"),
            Self::Symbol => write!(f, "symbol"),
            Self::Category => write!(f, "category"),
            Self::Ordinal => write!(f, "ordinal"),
            Self::Ramp => write!(f, "ramp"),
            Self::Diverging => write!(f, "diverging"),
            Self::Heatmap => write!(f, "heatmap"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant9RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ScaleVariant9RangeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(::std::string::String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(::std::vec::Vec<NumberOrSignal>),
}
impl ::std::convert::From<&Self> for ScaleVariant9RangeVariant1Item {
    fn from(value: &ScaleVariant9RangeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for ScaleVariant9RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<f64> for ScaleVariant9RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<NumberOrSignal>> for ScaleVariant9RangeVariant1Item {
    fn from(value: ::std::vec::Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "`ScaleVariant9RangeVariant2Extent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9RangeVariant2Extent {
    fn from(value: &ScaleVariant9RangeVariant2Extent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[NumberOrSignal; 2usize]> for ScaleVariant9RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant9RangeVariant2Scheme`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Scheme {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: &ScaleVariant9RangeVariant2Scheme) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>>
    for ScaleVariant9RangeVariant2Scheme
{
    fn from(value: ::std::vec::Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`ScaleVariant9RangeVariant2SchemeVariant1Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2SchemeVariant1Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for ScaleVariant9RangeVariant2SchemeVariant1Item {
    fn from(value: &ScaleVariant9RangeVariant2SchemeVariant1Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for ScaleVariant9RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`ScaleVariant9Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"log\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ScaleVariant9Type {
    #[serde(rename = "log")]
    Log,
}
impl ::std::convert::From<&Self> for ScaleVariant9Type {
    fn from(value: &ScaleVariant9Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ScaleVariant9Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Log => write!(f, "log"),
        }
    }
}
impl ::std::str::FromStr for ScaleVariant9Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "log" => Ok(Self::Log),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Scope`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"axes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/axis\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/data\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"$ref\": \"#/definitions/encode\""]
#[doc = "    },"]
#[doc = "    \"layout\": {"]
#[doc = "      \"$ref\": \"#/definitions/layout\""]
#[doc = "    },"]
#[doc = "    \"legends\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/legend\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"marks\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/markGroup\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/markVisual\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"projections\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/projection\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scales\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/scale\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"signals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/signal\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/title\""]
#[doc = "    },"]
#[doc = "    \"usermeta\": {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Scope {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub axes: ::std::vec::Vec<Axis>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub data: ::std::vec::Vec<Data>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub encode: ::std::option::Option<Encode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub layout: ::std::option::Option<Layout>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub legends: ::std::vec::Vec<Legend>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub marks: ::std::vec::Vec<ScopeMarksItem>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub projections: ::std::vec::Vec<Projection>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scales: ::std::vec::Vec<Scale>,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub signals: ::std::vec::Vec<Signal>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<Title>,
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub usermeta: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&Scope> for Scope {
    fn from(value: &Scope) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Scope {
    fn default() -> Self {
        Self {
            axes: Default::default(),
            data: Default::default(),
            encode: Default::default(),
            layout: Default::default(),
            legends: Default::default(),
            marks: Default::default(),
            projections: Default::default(),
            scales: Default::default(),
            signals: Default::default(),
            title: Default::default(),
            usermeta: Default::default(),
        }
    }
}
#[doc = "`ScopeMarksItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ScopeMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl ::std::convert::From<&Self> for ScopeMarksItem {
    fn from(value: &ScopeMarksItem) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MarkGroup> for ScopeMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl ::std::convert::From<MarkVisual> for ScopeMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "`Selector`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Selector(pub ::std::string::String);
impl ::std::ops::Deref for Selector {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Selector> for ::std::string::String {
    fn from(value: Selector) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Selector> for Selector {
    fn from(value: &Selector) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Selector {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Selector {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Selector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`SequenceTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"start\","]
#[doc = "    \"stop\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"data\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stop\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"sequence\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct SequenceTransform {
    #[serde(rename = "as", default = "defaults::sequence_transform_as")]
    pub as_: SequenceTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    pub start: SequenceTransformStart,
    #[serde(default = "defaults::sequence_transform_step")]
    pub step: SequenceTransformStep,
    pub stop: SequenceTransformStop,
    #[serde(rename = "type")]
    pub type_: SequenceTransformType,
}
impl ::std::convert::From<&SequenceTransform> for SequenceTransform {
    fn from(value: &SequenceTransform) -> Self {
        value.clone()
    }
}
#[doc = "`SequenceTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"data\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SequenceTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SequenceTransformAs {
    fn from(value: &SequenceTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SequenceTransformAs {
    fn default() -> Self {
        SequenceTransformAs::Variant0("data".to_string())
    }
}
impl ::std::convert::From<SignalRef> for SequenceTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SequenceTransformStart`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SequenceTransformStart {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SequenceTransformStart {
    fn from(value: &SequenceTransformStart) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for SequenceTransformStart {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for SequenceTransformStart {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SequenceTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SequenceTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SequenceTransformStep {
    fn from(value: &SequenceTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for SequenceTransformStep {
    fn default() -> Self {
        SequenceTransformStep::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for SequenceTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for SequenceTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SequenceTransformStop`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SequenceTransformStop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SequenceTransformStop {
    fn from(value: &SequenceTransformStop) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for SequenceTransformStop {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for SequenceTransformStop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SequenceTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"sequence\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SequenceTransformType {
    #[serde(rename = "sequence")]
    Sequence,
}
impl ::std::convert::From<&Self> for SequenceTransformType {
    fn from(value: &SequenceTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SequenceTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Sequence => write!(f, "sequence"),
        }
    }
}
impl ::std::str::FromStr for SequenceTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "sequence" => Ok(Self::Sequence),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Signal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"push\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"push\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"outer\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bind\": {"]
#[doc = "          \"$ref\": \"#/definitions/bind\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"react\": {"]
#[doc = "          \"default\": true,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"update\": {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        },"]
#[doc = "        \"value\": {}"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"init\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bind\": {"]
#[doc = "          \"$ref\": \"#/definitions/bind\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"init\": {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"value\": {}"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Signal {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnEvents>,
        push: SignalVariant0Push,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bind: ::std::option::Option<Bind>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnEvents>,
        #[serde(default = "defaults::default_bool::<true>")]
        react: bool,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        update: ::std::option::Option<ExprString>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        value: ::std::option::Option<::serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        bind: ::std::option::Option<Bind>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        description: ::std::option::Option<::std::string::String>,
        init: ExprString,
        name: SignalName,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        on: ::std::option::Option<OnEvents>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        value: ::std::option::Option<::serde_json::Value>,
    },
}
impl ::std::convert::From<&Self> for Signal {
    fn from(value: &Signal) -> Self {
        value.clone()
    }
}
#[doc = "`SignalName`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"not\": {"]
#[doc = "    \"enum\": ["]
#[doc = "      \"parent\","]
#[doc = "      \"datum\","]
#[doc = "      \"event\","]
#[doc = "      \"item\""]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct SignalName(::std::string::String);
impl ::std::ops::Deref for SignalName {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<SignalName> for ::std::string::String {
    fn from(value: SignalName) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SignalName> for SignalName {
    fn from(value: &SignalName) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SignalName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        if [
            "parent".to_string(),
            "datum".to_string(),
            "event".to_string(),
            "item".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for SignalName {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<::std::string::String>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "`SignalRef`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"signal\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SignalRef {
    pub signal: ::std::string::String,
}
impl ::std::convert::From<&SignalRef> for SignalRef {
    fn from(value: &SignalRef) -> Self {
        value.clone()
    }
}
#[doc = "`SignalVariant0Push`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"outer\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SignalVariant0Push {
    #[serde(rename = "outer")]
    Outer,
}
impl ::std::convert::From<&Self> for SignalVariant0Push {
    fn from(value: &SignalVariant0Push) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SignalVariant0Push {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Outer => write!(f, "outer"),
        }
    }
}
impl ::std::str::FromStr for SignalVariant0Push {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "outer" => Ok(Self::Outer),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SortOrder`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"ascending\","]
#[doc = "        \"descending\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum SortOrder {
    Variant0(SortOrderVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for SortOrder {
    fn from(value: &SortOrder) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SortOrderVariant0> for SortOrder {
    fn from(value: SortOrderVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for SortOrder {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`SortOrderVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"ascending\","]
#[doc = "    \"descending\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SortOrderVariant0 {
    #[serde(rename = "ascending")]
    Ascending,
    #[serde(rename = "descending")]
    Descending,
}
impl ::std::convert::From<&Self> for SortOrderVariant0 {
    fn from(value: &SortOrderVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SortOrderVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Ascending => write!(f, "ascending"),
            Self::Descending => write!(f, "descending"),
        }
    }
}
impl ::std::str::FromStr for SortOrderVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StackTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"y0\","]
#[doc = "        \"y1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"default\": \"zero\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"zero\","]
#[doc = "            \"center\","]
#[doc = "            \"normalize\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"stack\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StackTransform {
    #[serde(rename = "as", default = "defaults::stack_transform_as")]
    pub as_: StackTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<StackTransformField>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<StackTransformGroupby>,
    #[serde(default = "defaults::stack_transform_offset")]
    pub offset: StackTransformOffset,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: StackTransformType,
}
impl ::std::convert::From<&StackTransform> for StackTransform {
    fn from(value: &StackTransform) -> Self {
        value.clone()
    }
}
#[doc = "`StackTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"y0\","]
#[doc = "    \"y1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformAs {
    Variant0([StackTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for StackTransformAs {
    fn from(value: &StackTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StackTransformAs {
    fn default() -> Self {
        StackTransformAs::Variant0([
            StackTransformAsVariant0Item::Variant0("y0".to_string()),
            StackTransformAsVariant0Item::Variant0("y1".to_string()),
        ])
    }
}
impl ::std::convert::From<[StackTransformAsVariant0Item; 2usize]> for StackTransformAs {
    fn from(value: [StackTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for StackTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StackTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for StackTransformAsVariant0Item {
    fn from(value: &StackTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for StackTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StackTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for StackTransformField {
    fn from(value: &StackTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for StackTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for StackTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for StackTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`StackTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformGroupby {
    Variant0(::std::vec::Vec<StackTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for StackTransformGroupby {
    fn from(value: &StackTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<StackTransformGroupbyVariant0Item>>
    for StackTransformGroupby
{
    fn from(value: ::std::vec::Vec<StackTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for StackTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StackTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for StackTransformGroupbyVariant0Item {
    fn from(value: &StackTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for StackTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for StackTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for StackTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`StackTransformOffset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"zero\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"zero\","]
#[doc = "        \"center\","]
#[doc = "        \"normalize\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StackTransformOffset {
    Variant0(StackTransformOffsetVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for StackTransformOffset {
    fn from(value: &StackTransformOffset) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StackTransformOffset {
    fn default() -> Self {
        StackTransformOffset::Variant0(StackTransformOffsetVariant0::Zero)
    }
}
impl ::std::convert::From<StackTransformOffsetVariant0> for StackTransformOffset {
    fn from(value: StackTransformOffsetVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for StackTransformOffset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StackTransformOffsetVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"zero\","]
#[doc = "    \"center\","]
#[doc = "    \"normalize\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackTransformOffsetVariant0 {
    #[serde(rename = "zero")]
    Zero,
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "normalize")]
    Normalize,
}
impl ::std::convert::From<&Self> for StackTransformOffsetVariant0 {
    fn from(value: &StackTransformOffsetVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackTransformOffsetVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Zero => write!(f, "zero"),
            Self::Center => write!(f, "center"),
            Self::Normalize => write!(f, "normalize"),
        }
    }
}
impl ::std::str::FromStr for StackTransformOffsetVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "zero" => Ok(Self::Zero),
            "center" => Ok(Self::Center),
            "normalize" => Ok(Self::Normalize),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StackTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"stack\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StackTransformType {
    #[serde(rename = "stack")]
    Stack,
}
impl ::std::convert::From<&Self> for StackTransformType {
    fn from(value: &StackTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StackTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Stack => write!(f, "stack"),
        }
    }
}
impl ::std::str::FromStr for StackTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stack" => Ok(Self::Stack),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StratifyTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"key\","]
#[doc = "    \"parentKey\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"parentKey\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"stratify\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct StratifyTransform {
    pub key: StratifyTransformKey,
    #[serde(rename = "parentKey")]
    pub parent_key: StratifyTransformParentKey,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: StratifyTransformType,
}
impl ::std::convert::From<&StratifyTransform> for StratifyTransform {
    fn from(value: &StratifyTransform) -> Self {
        value.clone()
    }
}
#[doc = "`StratifyTransformKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StratifyTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for StratifyTransformKey {
    fn from(value: &StratifyTransformKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for StratifyTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for StratifyTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for StratifyTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`StratifyTransformParentKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StratifyTransformParentKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for StratifyTransformParentKey {
    fn from(value: &StratifyTransformParentKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for StratifyTransformParentKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for StratifyTransformParentKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for StratifyTransformParentKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`StratifyTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"stratify\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StratifyTransformType {
    #[serde(rename = "stratify")]
    Stratify,
}
impl ::std::convert::From<&Self> for StratifyTransformType {
    fn from(value: &StratifyTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StratifyTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Stratify => write!(f, "stratify"),
        }
    }
}
impl ::std::str::FromStr for StratifyTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "stratify" => Ok(Self::Stratify),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Stream`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"between\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stream\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        \"consume\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"filter\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/exprString\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/exprString\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"markname\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"marktype\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"throttle\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"source\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stream\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"stream\": {"]
#[doc = "              \"$ref\": \"#/definitions/stream\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"merge\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"merge\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/stream\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Stream {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        between: ::std::option::Option<[::std::boxed::Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        consume: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        filter: ::std::option::Option<StreamVariant0Filter>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        markname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        marktype: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        source: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        throttle: ::std::option::Option<f64>,
        #[serde(rename = "type")]
        type_: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        between: ::std::option::Option<[::std::boxed::Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        consume: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        filter: ::std::option::Option<StreamVariant1Filter>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        markname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        marktype: ::std::option::Option<::std::string::String>,
        stream: ::std::boxed::Box<Stream>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        throttle: ::std::option::Option<f64>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        between: ::std::option::Option<[::std::boxed::Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        consume: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        debounce: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        filter: ::std::option::Option<StreamVariant2Filter>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        markname: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        marktype: ::std::option::Option<::std::string::String>,
        merge: ::std::vec::Vec<Stream>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        throttle: ::std::option::Option<f64>,
    },
}
impl ::std::convert::From<&Self> for Stream {
    fn from(value: &Stream) -> Self {
        value.clone()
    }
}
#[doc = "`StreamVariant0Filter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StreamVariant0Filter {
    Variant0(ExprString),
    Variant1(::std::vec::Vec<ExprString>),
}
impl ::std::convert::From<&Self> for StreamVariant0Filter {
    fn from(value: &StreamVariant0Filter) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ExprString> for StreamVariant0Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ExprString>> for StreamVariant0Filter {
    fn from(value: ::std::vec::Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StreamVariant1Filter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StreamVariant1Filter {
    Variant0(ExprString),
    Variant1(::std::vec::Vec<ExprString>),
}
impl ::std::convert::From<&Self> for StreamVariant1Filter {
    fn from(value: &StreamVariant1Filter) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ExprString> for StreamVariant1Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ExprString>> for StreamVariant1Filter {
    fn from(value: ::std::vec::Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StreamVariant2Filter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StreamVariant2Filter {
    Variant0(ExprString),
    Variant1(::std::vec::Vec<ExprString>),
}
impl ::std::convert::From<&Self> for StreamVariant2Filter {
    fn from(value: &StreamVariant2Filter) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ExprString> for StreamVariant2Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<ExprString>> for StreamVariant2Filter {
    fn from(value: ::std::vec::Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StringModifiers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/field\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StringModifiers {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub scale: ::std::option::Option<Field>,
}
impl ::std::convert::From<&StringModifiers> for StringModifiers {
    fn from(value: &StringModifiers) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StringModifiers {
    fn default() -> Self {
        Self {
            scale: Default::default(),
        }
    }
}
#[doc = "`StringOrSignal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringOrSignal {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for StringOrSignal {
    fn from(value: &StringOrSignal) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for StringOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StringValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValue {
    Variant0(::std::vec::Vec<StringValueVariant0Item>),
    Variant1(StringValueVariant1),
}
impl ::std::convert::From<&Self> for StringValue {
    fn from(value: &StringValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<StringValueVariant0Item>> for StringValue {
    fn from(value: ::std::vec::Vec<StringValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StringValueVariant1> for StringValue {
    fn from(value: StringValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StringValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant0Item {
    Variant0(StringValueVariant0ItemVariant0),
    Variant1(StringValueVariant0ItemVariant1),
    Variant2(StringValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StringValueVariant0Item {
    fn from(value: &StringValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValueVariant0ItemVariant0> for StringValueVariant0Item {
    fn from(value: StringValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StringValueVariant0ItemVariant1> for StringValueVariant0Item {
    fn from(value: StringValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StringValueVariant0ItemVariant2> for StringValueVariant0Item {
    fn from(value: StringValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StringValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: ::std::string::String,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: StringValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StringValueVariant0ItemVariant0 {
    fn from(value: &StringValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`StringValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StringValueVariant0ItemVariant0Variant3Range {
    fn from(value: &StringValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StringValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StringValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StringValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StringValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StringValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StringValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StringValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StringValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StringValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for StringValueVariant0ItemVariant1 {
    fn from(value: &StringValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`StringValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StringValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for StringValueVariant0ItemVariant2 {
    fn from(value: &StringValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`StringValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant1 {
    Variant0(StringValueVariant1Variant0),
    Variant1(StringValueVariant1Variant1),
    Variant2(StringValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for StringValueVariant1 {
    fn from(value: &StringValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValueVariant1Variant0> for StringValueVariant1 {
    fn from(value: StringValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StringValueVariant1Variant1> for StringValueVariant1 {
    fn from(value: StringValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StringValueVariant1Variant2> for StringValueVariant1 {
    fn from(value: StringValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StringValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: ::std::string::String,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: StringValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for StringValueVariant1Variant0 {
    fn from(value: &StringValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`StringValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StringValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StringValueVariant1Variant0Variant3Range {
    fn from(value: &StringValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StringValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StringValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StringValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StringValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StringValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StringValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StringValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StringValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StringValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for StringValueVariant1Variant1 {
    fn from(value: &StringValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`StringValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StringValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for StringValueVariant1Variant2 {
    fn from(value: &StringValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"butt\","]
#[doc = "                              \"round\","]
#[doc = "                              \"square\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"butt\","]
#[doc = "                        \"round\","]
#[doc = "                        \"square\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValue {
    Variant0(::std::vec::Vec<StrokeCapValueVariant0Item>),
    Variant1(StrokeCapValueVariant1),
}
impl ::std::convert::From<&Self> for StrokeCapValue {
    fn from(value: &StrokeCapValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<StrokeCapValueVariant0Item>> for StrokeCapValue {
    fn from(value: ::std::vec::Vec<StrokeCapValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeCapValueVariant1> for StrokeCapValue {
    fn from(value: StrokeCapValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeCapValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"butt\","]
#[doc = "                        \"round\","]
#[doc = "                        \"square\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0Item {
    Variant0(StrokeCapValueVariant0ItemVariant0),
    Variant1(StrokeCapValueVariant0ItemVariant1),
    Variant2(StrokeCapValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0Item {
    fn from(value: &StrokeCapValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StrokeCapValueVariant0ItemVariant0> for StrokeCapValueVariant0Item {
    fn from(value: StrokeCapValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeCapValueVariant0ItemVariant1> for StrokeCapValueVariant0Item {
    fn from(value: StrokeCapValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StrokeCapValueVariant0ItemVariant2> for StrokeCapValueVariant0Item {
    fn from(value: StrokeCapValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StrokeCapValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"butt\","]
#[doc = "                \"round\","]
#[doc = "                \"square\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: StrokeCapValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: StrokeCapValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0ItemVariant0 {
    fn from(value: &StrokeCapValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"butt\","]
#[doc = "    \"round\","]
#[doc = "    \"square\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StrokeCapValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0ItemVariant0Variant1Value {
    fn from(value: &StrokeCapValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StrokeCapValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Butt => write!(f, "butt"),
            Self::Round => write!(f, "round"),
            Self::Square => write!(f, "square"),
        }
    }
}
impl ::std::str::FromStr for StrokeCapValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeCapValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeCapValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeCapValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StrokeCapValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0ItemVariant0Variant3Range {
    fn from(value: &StrokeCapValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StrokeCapValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeCapValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeCapValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeCapValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StrokeCapValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StrokeCapValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StrokeCapValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeCapValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"butt\","]
#[doc = "                  \"round\","]
#[doc = "                  \"square\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeCapValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0ItemVariant1 {
    fn from(value: &StrokeCapValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"butt\","]
#[doc = "                  \"round\","]
#[doc = "                  \"square\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeCapValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for StrokeCapValueVariant0ItemVariant2 {
    fn from(value: &StrokeCapValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"butt\","]
#[doc = "                    \"round\","]
#[doc = "                    \"square\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1 {
    Variant0(StrokeCapValueVariant1Variant0),
    Variant1(StrokeCapValueVariant1Variant1),
    Variant2(StrokeCapValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1 {
    fn from(value: &StrokeCapValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StrokeCapValueVariant1Variant0> for StrokeCapValueVariant1 {
    fn from(value: StrokeCapValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeCapValueVariant1Variant1> for StrokeCapValueVariant1 {
    fn from(value: StrokeCapValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StrokeCapValueVariant1Variant2> for StrokeCapValueVariant1 {
    fn from(value: StrokeCapValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StrokeCapValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"butt\","]
#[doc = "                \"round\","]
#[doc = "                \"square\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: StrokeCapValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: StrokeCapValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1Variant0 {
    fn from(value: &StrokeCapValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"butt\","]
#[doc = "    \"round\","]
#[doc = "    \"square\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StrokeCapValueVariant1Variant0Variant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1Variant0Variant1Value {
    fn from(value: &StrokeCapValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StrokeCapValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Butt => write!(f, "butt"),
            Self::Round => write!(f, "round"),
            Self::Square => write!(f, "square"),
        }
    }
}
impl ::std::str::FromStr for StrokeCapValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeCapValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeCapValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeCapValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StrokeCapValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1Variant0Variant3Range {
    fn from(value: &StrokeCapValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StrokeCapValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeCapValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeCapValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeCapValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StrokeCapValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StrokeCapValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StrokeCapValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeCapValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"butt\","]
#[doc = "                  \"round\","]
#[doc = "                  \"square\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeCapValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1Variant1 {
    fn from(value: &StrokeCapValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeCapValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"butt\","]
#[doc = "                  \"round\","]
#[doc = "                  \"square\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeCapValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for StrokeCapValueVariant1Variant2 {
    fn from(value: &StrokeCapValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"miter\","]
#[doc = "                              \"round\","]
#[doc = "                              \"bevel\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"miter\","]
#[doc = "                        \"round\","]
#[doc = "                        \"bevel\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValue {
    Variant0(::std::vec::Vec<StrokeJoinValueVariant0Item>),
    Variant1(StrokeJoinValueVariant1),
}
impl ::std::convert::From<&Self> for StrokeJoinValue {
    fn from(value: &StrokeJoinValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<StrokeJoinValueVariant0Item>> for StrokeJoinValue {
    fn from(value: ::std::vec::Vec<StrokeJoinValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeJoinValueVariant1> for StrokeJoinValue {
    fn from(value: StrokeJoinValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeJoinValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"miter\","]
#[doc = "                        \"round\","]
#[doc = "                        \"bevel\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0Item {
    Variant0(StrokeJoinValueVariant0ItemVariant0),
    Variant1(StrokeJoinValueVariant0ItemVariant1),
    Variant2(StrokeJoinValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0Item {
    fn from(value: &StrokeJoinValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StrokeJoinValueVariant0ItemVariant0> for StrokeJoinValueVariant0Item {
    fn from(value: StrokeJoinValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeJoinValueVariant0ItemVariant1> for StrokeJoinValueVariant0Item {
    fn from(value: StrokeJoinValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StrokeJoinValueVariant0ItemVariant2> for StrokeJoinValueVariant0Item {
    fn from(value: StrokeJoinValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StrokeJoinValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"miter\","]
#[doc = "                \"round\","]
#[doc = "                \"bevel\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: StrokeJoinValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: StrokeJoinValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0ItemVariant0 {
    fn from(value: &StrokeJoinValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"miter\","]
#[doc = "    \"round\","]
#[doc = "    \"bevel\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StrokeJoinValueVariant0ItemVariant0Variant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0ItemVariant0Variant1Value {
    fn from(value: &StrokeJoinValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StrokeJoinValueVariant0ItemVariant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Miter => write!(f, "miter"),
            Self::Round => write!(f, "round"),
            Self::Bevel => write!(f, "bevel"),
        }
    }
}
impl ::std::str::FromStr for StrokeJoinValueVariant0ItemVariant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeJoinValueVariant0ItemVariant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeJoinValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeJoinValueVariant0ItemVariant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StrokeJoinValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    fn from(value: &StrokeJoinValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeJoinValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeJoinValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StrokeJoinValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeJoinValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"miter\","]
#[doc = "                  \"round\","]
#[doc = "                  \"bevel\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeJoinValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0ItemVariant1 {
    fn from(value: &StrokeJoinValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"miter\","]
#[doc = "                  \"round\","]
#[doc = "                  \"bevel\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeJoinValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant0ItemVariant2 {
    fn from(value: &StrokeJoinValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"miter\","]
#[doc = "                    \"round\","]
#[doc = "                    \"bevel\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1 {
    Variant0(StrokeJoinValueVariant1Variant0),
    Variant1(StrokeJoinValueVariant1Variant1),
    Variant2(StrokeJoinValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1 {
    fn from(value: &StrokeJoinValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StrokeJoinValueVariant1Variant0> for StrokeJoinValueVariant1 {
    fn from(value: StrokeJoinValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StrokeJoinValueVariant1Variant1> for StrokeJoinValueVariant1 {
    fn from(value: StrokeJoinValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<StrokeJoinValueVariant1Variant2> for StrokeJoinValueVariant1 {
    fn from(value: StrokeJoinValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`StrokeJoinValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"miter\","]
#[doc = "                \"round\","]
#[doc = "                \"bevel\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: StrokeJoinValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: StrokeJoinValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1Variant0 {
    fn from(value: &StrokeJoinValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"miter\","]
#[doc = "    \"round\","]
#[doc = "    \"bevel\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StrokeJoinValueVariant1Variant0Variant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1Variant0Variant1Value {
    fn from(value: &StrokeJoinValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StrokeJoinValueVariant1Variant0Variant1Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Miter => write!(f, "miter"),
            Self::Round => write!(f, "round"),
            Self::Bevel => write!(f, "bevel"),
        }
    }
}
impl ::std::str::FromStr for StrokeJoinValueVariant1Variant0Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeJoinValueVariant1Variant0Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeJoinValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeJoinValueVariant1Variant0Variant1Value
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StrokeJoinValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1Variant0Variant3Range {
    fn from(value: &StrokeJoinValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for StrokeJoinValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for StrokeJoinValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for StrokeJoinValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for StrokeJoinValueVariant1Variant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for StrokeJoinValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for StrokeJoinValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for StrokeJoinValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`StrokeJoinValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"miter\","]
#[doc = "                  \"round\","]
#[doc = "                  \"bevel\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeJoinValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1Variant1 {
    fn from(value: &StrokeJoinValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`StrokeJoinValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"miter\","]
#[doc = "                  \"round\","]
#[doc = "                  \"bevel\""]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum StrokeJoinValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for StrokeJoinValueVariant1Variant2 {
    fn from(value: &StrokeJoinValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`Style`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Style {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for Style {
    fn from(value: &Style) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for Style {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextOrSignal`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextOrSignal {
    Variant0(TextOrSignalVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TextOrSignal {
    fn from(value: &TextOrSignal) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextOrSignalVariant0> for TextOrSignal {
    fn from(value: TextOrSignalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TextOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextOrSignalVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextOrSignalVariant0 {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for TextOrSignalVariant0 {
    fn from(value: &TextOrSignalVariant0) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>> for TextOrSignalVariant0 {
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"array\","]
#[doc = "                                \"items\": {"]
#[doc = "                                  \"type\": \"string\""]
#[doc = "                                }"]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"array\","]
#[doc = "                          \"items\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValue {
    Variant0(::std::vec::Vec<TextValueVariant0Item>),
    Variant1(TextValueVariant1),
}
impl ::std::convert::From<&Self> for TextValue {
    fn from(value: &TextValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<TextValueVariant0Item>> for TextValue {
    fn from(value: ::std::vec::Vec<TextValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<TextValueVariant1> for TextValue {
    fn from(value: TextValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValueVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"array\","]
#[doc = "                          \"items\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant0Item {
    Variant0(TextValueVariant0ItemVariant0),
    Variant1(TextValueVariant0ItemVariant1),
    Variant2(TextValueVariant0ItemVariant2),
    Variant3 {
        offset: ::serde_json::Value,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for TextValueVariant0Item {
    fn from(value: &TextValueVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextValueVariant0ItemVariant0> for TextValueVariant0Item {
    fn from(value: TextValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<TextValueVariant0ItemVariant1> for TextValueVariant0Item {
    fn from(value: TextValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<TextValueVariant0ItemVariant2> for TextValueVariant0Item {
    fn from(value: TextValueVariant0ItemVariant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`TextValueVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
        value: TextValueVariant0ItemVariant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
    Variant3 {
        range: TextValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        test: ::std::option::Option<::std::string::String>,
    },
}
impl ::std::convert::From<&Self> for TextValueVariant0ItemVariant0 {
    fn from(value: &TextValueVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
#[doc = "`TextValueVariant0ItemVariant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant0ItemVariant0Variant1Value {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for TextValueVariant0ItemVariant0Variant1Value {
    fn from(value: &TextValueVariant0ItemVariant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>>
    for TextValueVariant0ItemVariant0Variant1Value
{
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValueVariant0ItemVariant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for TextValueVariant0ItemVariant0Variant3Range {
    fn from(value: &TextValueVariant0ItemVariant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TextValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for TextValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for TextValueVariant0ItemVariant0Variant3Range
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TextValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for TextValueVariant0ItemVariant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for TextValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for TextValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValueVariant0ItemVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum TextValueVariant0ItemVariant1 {}
impl ::std::convert::From<&Self> for TextValueVariant0ItemVariant1 {
    fn from(value: &TextValueVariant0ItemVariant1) -> Self {
        value.clone()
    }
}
#[doc = "`TextValueVariant0ItemVariant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum TextValueVariant0ItemVariant2 {}
impl ::std::convert::From<&Self> for TextValueVariant0ItemVariant2 {
    fn from(value: &TextValueVariant0ItemVariant2) -> Self {
        value.clone()
    }
}
#[doc = "`TextValueVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant1 {
    Variant0(TextValueVariant1Variant0),
    Variant1(TextValueVariant1Variant1),
    Variant2(TextValueVariant1Variant2),
    Variant3 { offset: ::serde_json::Value },
}
impl ::std::convert::From<&Self> for TextValueVariant1 {
    fn from(value: &TextValueVariant1) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TextValueVariant1Variant0> for TextValueVariant1 {
    fn from(value: TextValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<TextValueVariant1Variant1> for TextValueVariant1 {
    fn from(value: TextValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<TextValueVariant1Variant2> for TextValueVariant1 {
    fn from(value: TextValueVariant1Variant2) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`TextValueVariant1Variant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        signal: ::std::string::String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
        value: TextValueVariant1Variant0Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
    Variant3 {
        range: TextValueVariant1Variant0Variant3Range,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        scale: ::std::option::Option<Field>,
    },
}
impl ::std::convert::From<&Self> for TextValueVariant1Variant0 {
    fn from(value: &TextValueVariant1Variant0) -> Self {
        value.clone()
    }
}
#[doc = "`TextValueVariant1Variant0Variant1Value`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant1Variant0Variant1Value {
    Variant0(::std::string::String),
    Variant1(::std::vec::Vec<::std::string::String>),
}
impl ::std::convert::From<&Self> for TextValueVariant1Variant0Variant1Value {
    fn from(value: &TextValueVariant1Variant0Variant1Value) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::string::String>>
    for TextValueVariant1Variant0Variant1Value
{
    fn from(value: ::std::vec::Vec<::std::string::String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValueVariant1Variant0Variant3Range`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TextValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl ::std::convert::From<&Self> for TextValueVariant1Variant0Variant3Range {
    fn from(value: &TextValueVariant1Variant0Variant3Range) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TextValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for TextValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TextValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TextValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for TextValueVariant1Variant0Variant3Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::Variant0(x) => x.fmt(f),
            Self::Variant1(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<f64> for TextValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<bool> for TextValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TextValueVariant1Variant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\","]
#[doc = "        \"value\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum TextValueVariant1Variant1 {}
impl ::std::convert::From<&Self> for TextValueVariant1Variant1 {
    fn from(value: &TextValueVariant1Variant1) -> Self {
        value.clone()
    }
}
#[doc = "`TextValueVariant1Variant2`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(deny_unknown_fields)]
pub enum TextValueVariant1Variant2 {}
impl ::std::convert::From<&Self> for TextValueVariant1Variant2 {
    fn from(value: &TextValueVariant1Variant2) -> Self {
        value.clone()
    }
}
#[doc = "`TickBand`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"center\","]
#[doc = "        \"extent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TickBand {
    Variant0(TickBandVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TickBand {
    fn from(value: &TickBand) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TickBandVariant0> for TickBand {
    fn from(value: TickBandVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TickBand {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TickBandVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"center\","]
#[doc = "    \"extent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TickBandVariant0 {
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "extent")]
    Extent,
}
impl ::std::convert::From<&Self> for TickBandVariant0 {
    fn from(value: &TickBandVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TickBandVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Center => write!(f, "center"),
            Self::Extent => write!(f, "extent"),
        }
    }
}
impl ::std::str::FromStr for TickBandVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "center" => Ok(Self::Center),
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TickCount`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"interval\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"interval\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum TickCount {
    Variant0(f64),
    Variant1(TickCountVariant1),
    Variant2 {
        interval: TickCountVariant2Interval,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        step: ::std::option::Option<NumberOrSignal>,
    },
    Variant3(SignalRef),
}
impl ::std::convert::From<&Self> for TickCount {
    fn from(value: &TickCount) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TickCount {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<TickCountVariant1> for TickCount {
    fn from(value: TickCountVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<SignalRef> for TickCount {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`TickCountVariant1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TickCountVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ::std::convert::From<&Self> for TickCountVariant1 {
    fn from(value: &TickCountVariant1) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TickCountVariant1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Millisecond => write!(f, "millisecond"),
            Self::Second => write!(f, "second"),
            Self::Minute => write!(f, "minute"),
            Self::Hour => write!(f, "hour"),
            Self::Day => write!(f, "day"),
            Self::Week => write!(f, "week"),
            Self::Month => write!(f, "month"),
            Self::Year => write!(f, "year"),
        }
    }
}
impl ::std::str::FromStr for TickCountVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TickCountVariant2Interval`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TickCountVariant2Interval {
    Variant0(TickCountVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TickCountVariant2Interval {
    fn from(value: &TickCountVariant2Interval) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TickCountVariant2IntervalVariant0> for TickCountVariant2Interval {
    fn from(value: TickCountVariant2IntervalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TickCountVariant2Interval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TickCountVariant2IntervalVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TickCountVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl ::std::convert::From<&Self> for TickCountVariant2IntervalVariant0 {
    fn from(value: &TickCountVariant2IntervalVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TickCountVariant2IntervalVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Millisecond => write!(f, "millisecond"),
            Self::Second => write!(f, "second"),
            Self::Minute => write!(f, "minute"),
            Self::Hour => write!(f, "hour"),
            Self::Day => write!(f, "day"),
            Self::Week => write!(f, "week"),
            Self::Month => write!(f, "month"),
            Self::Year => write!(f, "year"),
        }
    }
}
impl ::std::str::FromStr for TickCountVariant2IntervalVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TimeunitTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"unit0\","]
#[doc = "        \"unit1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"interval\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxbins\": {"]
#[doc = "      \"default\": 40,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"timezone\": {"]
#[doc = "      \"default\": \"local\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"local\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"timeunit\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"units\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"year\","]
#[doc = "                  \"quarter\","]
#[doc = "                  \"month\","]
#[doc = "                  \"week\","]
#[doc = "                  \"date\","]
#[doc = "                  \"day\","]
#[doc = "                  \"dayofyear\","]
#[doc = "                  \"hours\","]
#[doc = "                  \"minutes\","]
#[doc = "                  \"seconds\","]
#[doc = "                  \"milliseconds\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TimeunitTransform {
    #[serde(rename = "as", default = "defaults::timeunit_transform_as")]
    pub as_: TimeunitTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub extent: ::std::option::Option<TimeunitTransformExtent>,
    pub field: TimeunitTransformField,
    #[serde(default = "defaults::timeunit_transform_interval")]
    pub interval: TimeunitTransformInterval,
    #[serde(default = "defaults::timeunit_transform_maxbins")]
    pub maxbins: TimeunitTransformMaxbins,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default = "defaults::timeunit_transform_step")]
    pub step: TimeunitTransformStep,
    #[serde(default = "defaults::timeunit_transform_timezone")]
    pub timezone: TimeunitTransformTimezone,
    #[serde(rename = "type")]
    pub type_: TimeunitTransformType,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub units: ::std::option::Option<TimeunitTransformUnits>,
}
impl ::std::convert::From<&TimeunitTransform> for TimeunitTransform {
    fn from(value: &TimeunitTransform) -> Self {
        value.clone()
    }
}
#[doc = "`TimeunitTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"unit0\","]
#[doc = "    \"unit1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformAs {
    Variant0([TimeunitTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformAs {
    fn from(value: &TimeunitTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TimeunitTransformAs {
    fn default() -> Self {
        TimeunitTransformAs::Variant0([
            TimeunitTransformAsVariant0Item::Variant0("unit0".to_string()),
            TimeunitTransformAsVariant0Item::Variant0("unit1".to_string()),
        ])
    }
}
impl ::std::convert::From<[TimeunitTransformAsVariant0Item; 2usize]> for TimeunitTransformAs {
    fn from(value: [TimeunitTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformAsVariant0Item {
    fn from(value: &TimeunitTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformExtent {
    Variant0(::std::vec::Vec<TimeunitTransformExtentVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformExtent {
    fn from(value: &TimeunitTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<TimeunitTransformExtentVariant0Item>>
    for TimeunitTransformExtent
{
    fn from(value: ::std::vec::Vec<TimeunitTransformExtentVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformExtentVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformExtentVariant0Item {
    fn from(value: &TimeunitTransformExtentVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TimeunitTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for TimeunitTransformField {
    fn from(value: &TimeunitTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for TimeunitTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for TimeunitTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for TimeunitTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`TimeunitTransformInterval`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformInterval {
    fn from(value: &TimeunitTransformInterval) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TimeunitTransformInterval {
    fn default() -> Self {
        TimeunitTransformInterval::Variant0(true)
    }
}
impl ::std::convert::From<bool> for TimeunitTransformInterval {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformInterval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformMaxbins`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 40,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformMaxbins {
    fn from(value: &TimeunitTransformMaxbins) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TimeunitTransformMaxbins {
    fn default() -> Self {
        TimeunitTransformMaxbins::Variant0(40_f64)
    }
}
impl ::std::convert::From<f64> for TimeunitTransformMaxbins {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformMaxbins {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformStep`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformStep {
    fn from(value: &TimeunitTransformStep) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TimeunitTransformStep {
    fn default() -> Self {
        TimeunitTransformStep::Variant0(1_f64)
    }
}
impl ::std::convert::From<f64> for TimeunitTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformTimezone`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"local\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"local\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformTimezone {
    Variant0(TimeunitTransformTimezoneVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformTimezone {
    fn from(value: &TimeunitTransformTimezone) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TimeunitTransformTimezone {
    fn default() -> Self {
        TimeunitTransformTimezone::Variant0(TimeunitTransformTimezoneVariant0::Local)
    }
}
impl ::std::convert::From<TimeunitTransformTimezoneVariant0> for TimeunitTransformTimezone {
    fn from(value: TimeunitTransformTimezoneVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformTimezone {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformTimezoneVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"local\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TimeunitTransformTimezoneVariant0 {
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "utc")]
    Utc,
}
impl ::std::convert::From<&Self> for TimeunitTransformTimezoneVariant0 {
    fn from(value: &TimeunitTransformTimezoneVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TimeunitTransformTimezoneVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Local => write!(f, "local"),
            Self::Utc => write!(f, "utc"),
        }
    }
}
impl ::std::str::FromStr for TimeunitTransformTimezoneVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "local" => Ok(Self::Local),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TimeunitTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"timeunit\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TimeunitTransformType {
    #[serde(rename = "timeunit")]
    Timeunit,
}
impl ::std::convert::From<&Self> for TimeunitTransformType {
    fn from(value: &TimeunitTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TimeunitTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Timeunit => write!(f, "timeunit"),
        }
    }
}
impl ::std::str::FromStr for TimeunitTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "timeunit" => Ok(Self::Timeunit),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TimeunitTransformUnits`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"year\","]
#[doc = "              \"quarter\","]
#[doc = "              \"month\","]
#[doc = "              \"week\","]
#[doc = "              \"date\","]
#[doc = "              \"day\","]
#[doc = "              \"dayofyear\","]
#[doc = "              \"hours\","]
#[doc = "              \"minutes\","]
#[doc = "              \"seconds\","]
#[doc = "              \"milliseconds\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformUnits {
    Variant0(::std::vec::Vec<TimeunitTransformUnitsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformUnits {
    fn from(value: &TimeunitTransformUnits) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<TimeunitTransformUnitsVariant0Item>>
    for TimeunitTransformUnits
{
    fn from(value: ::std::vec::Vec<TimeunitTransformUnitsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformUnits {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformUnitsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"year\","]
#[doc = "        \"quarter\","]
#[doc = "        \"month\","]
#[doc = "        \"week\","]
#[doc = "        \"date\","]
#[doc = "        \"day\","]
#[doc = "        \"dayofyear\","]
#[doc = "        \"hours\","]
#[doc = "        \"minutes\","]
#[doc = "        \"seconds\","]
#[doc = "        \"milliseconds\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TimeunitTransformUnitsVariant0Item {
    Variant0(TimeunitTransformUnitsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TimeunitTransformUnitsVariant0Item {
    fn from(value: &TimeunitTransformUnitsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TimeunitTransformUnitsVariant0ItemVariant0>
    for TimeunitTransformUnitsVariant0Item
{
    fn from(value: TimeunitTransformUnitsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TimeunitTransformUnitsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TimeunitTransformUnitsVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"year\","]
#[doc = "    \"quarter\","]
#[doc = "    \"month\","]
#[doc = "    \"week\","]
#[doc = "    \"date\","]
#[doc = "    \"day\","]
#[doc = "    \"dayofyear\","]
#[doc = "    \"hours\","]
#[doc = "    \"minutes\","]
#[doc = "    \"seconds\","]
#[doc = "    \"milliseconds\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TimeunitTransformUnitsVariant0ItemVariant0 {
    #[serde(rename = "year")]
    Year,
    #[serde(rename = "quarter")]
    Quarter,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "dayofyear")]
    Dayofyear,
    #[serde(rename = "hours")]
    Hours,
    #[serde(rename = "minutes")]
    Minutes,
    #[serde(rename = "seconds")]
    Seconds,
    #[serde(rename = "milliseconds")]
    Milliseconds,
}
impl ::std::convert::From<&Self> for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn from(value: &TimeunitTransformUnitsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Year => write!(f, "year"),
            Self::Quarter => write!(f, "quarter"),
            Self::Month => write!(f, "month"),
            Self::Week => write!(f, "week"),
            Self::Date => write!(f, "date"),
            Self::Day => write!(f, "day"),
            Self::Dayofyear => write!(f, "dayofyear"),
            Self::Hours => write!(f, "hours"),
            Self::Minutes => write!(f, "minutes"),
            Self::Seconds => write!(f, "seconds"),
            Self::Milliseconds => write!(f, "milliseconds"),
        }
    }
}
impl ::std::str::FromStr for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "year" => Ok(Self::Year),
            "quarter" => Ok(Self::Quarter),
            "month" => Ok(Self::Month),
            "week" => Ok(Self::Week),
            "date" => Ok(Self::Date),
            "day" => Ok(Self::Day),
            "dayofyear" => Ok(Self::Dayofyear),
            "hours" => Ok(Self::Hours),
            "minutes" => Ok(Self::Minutes),
            "seconds" => Ok(Self::Seconds),
            "milliseconds" => Ok(Self::Milliseconds),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for TimeunitTransformUnitsVariant0ItemVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`Title`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"anchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"angle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"aria\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"baseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"color\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dx\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dy\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"encode\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"patternProperties\": {"]
#[doc = "                \"^(?!interactive|name|style).+$\": {"]
#[doc = "                  \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"group\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                },"]
#[doc = "                \"subtitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                },"]
#[doc = "                \"title\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"font\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"frame\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"group\","]
#[doc = "                \"bounds\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interactive\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"limit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"lineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"orient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"default\": \"top\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"style\": {"]
#[doc = "          \"$ref\": \"#/definitions/style\""]
#[doc = "        },"]
#[doc = "        \"subtitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"subtitleColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleLineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitlePadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"zindex\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum Title {
    Variant0(::std::string::String),
    Variant1 {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        align: ::std::option::Option<TitleVariant1Align>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        anchor: ::std::option::Option<TitleVariant1Anchor>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        angle: ::std::option::Option<TitleVariant1Angle>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        aria: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        baseline: ::std::option::Option<TitleVariant1Baseline>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        color: ::std::option::Option<TitleVariant1Color>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        dx: ::std::option::Option<TitleVariant1Dx>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        dy: ::std::option::Option<TitleVariant1Dy>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        encode: ::std::option::Option<TitleVariant1Encode>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        font: ::std::option::Option<TitleVariant1Font>,
        #[serde(
            rename = "fontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        font_size: ::std::option::Option<TitleVariant1FontSize>,
        #[serde(
            rename = "fontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        font_style: ::std::option::Option<TitleVariant1FontStyle>,
        #[serde(
            rename = "fontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        font_weight: ::std::option::Option<TitleVariant1FontWeight>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        frame: ::std::option::Option<TitleVariant1Frame>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        interactive: ::std::option::Option<bool>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        limit: ::std::option::Option<TitleVariant1Limit>,
        #[serde(
            rename = "lineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        line_height: ::std::option::Option<TitleVariant1LineHeight>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        name: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        offset: ::std::option::Option<TitleVariant1Offset>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        orient: ::std::option::Option<TitleVariant1Orient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        style: ::std::option::Option<Style>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        subtitle: ::std::option::Option<TextOrSignal>,
        #[serde(
            rename = "subtitleColor",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_color: ::std::option::Option<TitleVariant1SubtitleColor>,
        #[serde(
            rename = "subtitleFont",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_font: ::std::option::Option<TitleVariant1SubtitleFont>,
        #[serde(
            rename = "subtitleFontSize",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_font_size: ::std::option::Option<TitleVariant1SubtitleFontSize>,
        #[serde(
            rename = "subtitleFontStyle",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_font_style: ::std::option::Option<TitleVariant1SubtitleFontStyle>,
        #[serde(
            rename = "subtitleFontWeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_font_weight: ::std::option::Option<TitleVariant1SubtitleFontWeight>,
        #[serde(
            rename = "subtitleLineHeight",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_line_height: ::std::option::Option<TitleVariant1SubtitleLineHeight>,
        #[serde(
            rename = "subtitlePadding",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        subtitle_padding: ::std::option::Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        text: ::std::option::Option<TextOrSignal>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        zindex: ::std::option::Option<f64>,
    },
}
impl ::std::convert::From<&Self> for Title {
    fn from(value: &Title) -> Self {
        value.clone()
    }
}
#[doc = "`TitleVariant1Align`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Align {
    Variant0(TitleVariant1AlignVariant0),
    Variant1(AlignValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Align {
    fn from(value: &TitleVariant1Align) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TitleVariant1AlignVariant0> for TitleVariant1Align {
    fn from(value: TitleVariant1AlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AlignValue> for TitleVariant1Align {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1AlignVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TitleVariant1AlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl ::std::convert::From<&Self> for TitleVariant1AlignVariant0 {
    fn from(value: &TitleVariant1AlignVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TitleVariant1AlignVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Center => write!(f, "center"),
        }
    }
}
impl ::std::str::FromStr for TitleVariant1AlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TitleVariant1Anchor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Anchor {
    Variant0(::std::option::Option<TitleVariant1AnchorVariant0>),
    Variant1(AnchorValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Anchor {
    fn from(value: &TitleVariant1Anchor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::option::Option<TitleVariant1AnchorVariant0>>
    for TitleVariant1Anchor
{
    fn from(value: ::std::option::Option<TitleVariant1AnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<AnchorValue> for TitleVariant1Anchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1AnchorVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TitleVariant1AnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for TitleVariant1AnchorVariant0 {
    fn from(value: &TitleVariant1AnchorVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TitleVariant1AnchorVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Start => write!(f, "start"),
            Self::Middle => write!(f, "middle"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for TitleVariant1AnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TitleVariant1Angle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Angle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Angle {
    fn from(value: &TitleVariant1Angle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1Angle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1Angle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Baseline`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Baseline {
    Variant0(TitleVariant1BaselineVariant0),
    Variant1(BaselineValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Baseline {
    fn from(value: &TitleVariant1Baseline) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TitleVariant1BaselineVariant0> for TitleVariant1Baseline {
    fn from(value: TitleVariant1BaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<BaselineValue> for TitleVariant1Baseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1BaselineVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TitleVariant1BaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl ::std::convert::From<&Self> for TitleVariant1BaselineVariant0 {
    fn from(value: &TitleVariant1BaselineVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TitleVariant1BaselineVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Top => write!(f, "top"),
            Self::Middle => write!(f, "middle"),
            Self::Bottom => write!(f, "bottom"),
            Self::Alphabetic => write!(f, "alphabetic"),
            Self::LineTop => write!(f, "line-top"),
            Self::LineBottom => write!(f, "line-bottom"),
        }
    }
}
impl ::std::str::FromStr for TitleVariant1BaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TitleVariant1Color`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Color {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Color {
    fn from(value: &TitleVariant1Color) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for TitleVariant1Color {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`TitleVariant1Dx`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Dx {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Dx {
    fn from(value: &TitleVariant1Dx) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1Dx {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1Dx {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Dy`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Dy {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Dy {
    fn from(value: &TitleVariant1Dy) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1Dy {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1Dy {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Encode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"patternProperties\": {"]
#[doc = "        \"^(?!interactive|name|style).+$\": {"]
#[doc = "          \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"group\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"subtitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TitleVariant1Encode {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<
        ::std::collections::HashMap<TitleVariant1EncodeSubtype0Key, EncodeEntry>,
    >,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<TitleVariant1EncodeSubtype1>,
}
impl ::std::convert::From<&TitleVariant1Encode> for TitleVariant1Encode {
    fn from(value: &TitleVariant1Encode) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TitleVariant1Encode {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
        }
    }
}
#[doc = "`TitleVariant1EncodeSubtype0Key`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(?!interactive|name|style).+$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct TitleVariant1EncodeSubtype0Key(::std::string::String);
impl ::std::ops::Deref for TitleVariant1EncodeSubtype0Key {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<TitleVariant1EncodeSubtype0Key> for ::std::string::String {
    fn from(value: TitleVariant1EncodeSubtype0Key) -> Self {
        value.0
    }
}
impl ::std::convert::From<&TitleVariant1EncodeSubtype0Key> for TitleVariant1EncodeSubtype0Key {
    fn from(value: &TitleVariant1EncodeSubtype0Key) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for TitleVariant1EncodeSubtype0Key {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        static PATTERN: ::std::sync::LazyLock<::regress::Regex> =
            ::std::sync::LazyLock::new(|| {
                ::regress::Regex::new("^(?!interactive|name|style).+$").unwrap()
            });
        if (&*PATTERN).find(value).is_none() {
            return Err("doesn't match pattern \"^(?!interactive|name|style).+$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1EncodeSubtype0Key {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1EncodeSubtype0Key {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1EncodeSubtype0Key {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for TitleVariant1EncodeSubtype0Key {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "`TitleVariant1EncodeSubtype1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"group\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"subtitle\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype1 {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub group: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subtitle: ::std::option::Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<GuideEncode>,
}
impl ::std::convert::From<&TitleVariant1EncodeSubtype1> for TitleVariant1EncodeSubtype1 {
    fn from(value: &TitleVariant1EncodeSubtype1) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TitleVariant1EncodeSubtype1 {
    fn default() -> Self {
        Self {
            group: Default::default(),
            subtitle: Default::default(),
            title: Default::default(),
        }
    }
}
#[doc = "`TitleVariant1Font`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Font {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Font {
    fn from(value: &TitleVariant1Font) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for TitleVariant1Font {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1FontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1FontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1FontSize {
    fn from(value: &TitleVariant1FontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1FontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1FontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1FontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1FontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for TitleVariant1FontStyle {
    fn from(value: &TitleVariant1FontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for TitleVariant1FontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1FontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1FontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for TitleVariant1FontWeight {
    fn from(value: &TitleVariant1FontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for TitleVariant1FontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for TitleVariant1FontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Frame`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"group\","]
#[doc = "        \"bounds\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Frame {
    Variant0(TitleVariant1FrameVariant0),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Frame {
    fn from(value: &TitleVariant1Frame) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TitleVariant1FrameVariant0> for TitleVariant1Frame {
    fn from(value: TitleVariant1FrameVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<StringValue> for TitleVariant1Frame {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1FrameVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"group\","]
#[doc = "    \"bounds\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TitleVariant1FrameVariant0 {
    #[serde(rename = "group")]
    Group,
    #[serde(rename = "bounds")]
    Bounds,
}
impl ::std::convert::From<&Self> for TitleVariant1FrameVariant0 {
    fn from(value: &TitleVariant1FrameVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TitleVariant1FrameVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Group => write!(f, "group"),
            Self::Bounds => write!(f, "bounds"),
        }
    }
}
impl ::std::str::FromStr for TitleVariant1FrameVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "group" => Ok(Self::Group),
            "bounds" => Ok(Self::Bounds),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TitleVariant1Limit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Limit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Limit {
    fn from(value: &TitleVariant1Limit) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1Limit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1Limit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1LineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1LineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1LineHeight {
    fn from(value: &TitleVariant1LineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1LineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1LineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Offset`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1Offset {
    fn from(value: &TitleVariant1Offset) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1Orient`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"top\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1Orient {
    Variant0(TitleVariant1OrientVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TitleVariant1Orient {
    fn from(value: &TitleVariant1Orient) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TitleVariant1OrientVariant0> for TitleVariant1Orient {
    fn from(value: TitleVariant1OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TitleVariant1Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1OrientVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"top\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TitleVariant1OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl ::std::convert::From<&Self> for TitleVariant1OrientVariant0 {
    fn from(value: &TitleVariant1OrientVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TitleVariant1OrientVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "none"),
            Self::Left => write!(f, "left"),
            Self::Right => write!(f, "right"),
            Self::Top => write!(f, "top"),
            Self::Bottom => write!(f, "bottom"),
        }
    }
}
impl ::std::str::FromStr for TitleVariant1OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TitleVariant1SubtitleColor`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleColor {
    Variant0,
    Variant1(::std::string::String),
    Variant2(ColorValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleColor {
    fn from(value: &TitleVariant1SubtitleColor) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ColorValue> for TitleVariant1SubtitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`TitleVariant1SubtitleFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFont {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleFont {
    fn from(value: &TitleVariant1SubtitleFont) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for TitleVariant1SubtitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1SubtitleFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleFontSize {
    fn from(value: &TitleVariant1SubtitleFontSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1SubtitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1SubtitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1SubtitleFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontStyle {
    Variant0(::std::string::String),
    Variant1(StringValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleFontStyle {
    fn from(value: &TitleVariant1SubtitleFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<StringValue> for TitleVariant1SubtitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1SubtitleFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleFontWeight {
    fn from(value: &TitleVariant1SubtitleFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MyEnum> for TitleVariant1SubtitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<FontWeightValue> for TitleVariant1SubtitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TitleVariant1SubtitleLineHeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl ::std::convert::From<&Self> for TitleVariant1SubtitleLineHeight {
    fn from(value: &TitleVariant1SubtitleLineHeight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TitleVariant1SubtitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<NumberValue> for TitleVariant1SubtitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`Transform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossfilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/resolvefilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/linkpathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pieTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stackTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/forceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/contourTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geojsonTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopointTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geoshapeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/graticuleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/heatmapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/isocontourTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/kde2dTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/nestTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/packTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/partitionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stratifyTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treelinksTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treemapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/labelTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/loessTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/regressionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/aggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/binTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/collectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/countpatternTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/densityTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/dotbinTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/extentTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/filterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/flattenTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/foldTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/formulaTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/imputeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/joinaggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/kdeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/lookupTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pivotTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/projectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/quantileTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sampleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sequenceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/timeunitTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/windowTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/identifierTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/voronoiTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/wordcloudTransform\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Transform {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    ContourTransform(ContourTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    GraticuleTransform(GraticuleTransform),
    HeatmapTransform(HeatmapTransform),
    IsocontourTransform(IsocontourTransform),
    Kde2dTransform(Kde2dTransform),
    NestTransform(NestTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreelinksTransform(TreelinksTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    LoessTransform(LoessTransform),
    RegressionTransform(RegressionTransform),
    AggregateTransform(AggregateTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    CountpatternTransform(CountpatternTransform),
    CrossTransform(CrossTransform),
    DensityTransform(DensityTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FilterTransform(FilterTransform),
    FlattenTransform(FlattenTransform),
    FoldTransform(FoldTransform),
    FormulaTransform(FormulaTransform),
    ImputeTransform(ImputeTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    KdeTransform(KdeTransform),
    LookupTransform(LookupTransform),
    PivotTransform(PivotTransform),
    ProjectTransform(ProjectTransform),
    QuantileTransform(QuantileTransform),
    SampleTransform(SampleTransform),
    SequenceTransform(SequenceTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl ::std::convert::From<&Self> for Transform {
    fn from(value: &Transform) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CrossfilterTransform> for Transform {
    fn from(value: CrossfilterTransform) -> Self {
        Self::CrossfilterTransform(value)
    }
}
impl ::std::convert::From<ResolvefilterTransform> for Transform {
    fn from(value: ResolvefilterTransform) -> Self {
        Self::ResolvefilterTransform(value)
    }
}
impl ::std::convert::From<LinkpathTransform> for Transform {
    fn from(value: LinkpathTransform) -> Self {
        Self::LinkpathTransform(value)
    }
}
impl ::std::convert::From<PieTransform> for Transform {
    fn from(value: PieTransform) -> Self {
        Self::PieTransform(value)
    }
}
impl ::std::convert::From<StackTransform> for Transform {
    fn from(value: StackTransform) -> Self {
        Self::StackTransform(value)
    }
}
impl ::std::convert::From<ForceTransform> for Transform {
    fn from(value: ForceTransform) -> Self {
        Self::ForceTransform(value)
    }
}
impl ::std::convert::From<ContourTransform> for Transform {
    fn from(value: ContourTransform) -> Self {
        Self::ContourTransform(value)
    }
}
impl ::std::convert::From<GeojsonTransform> for Transform {
    fn from(value: GeojsonTransform) -> Self {
        Self::GeojsonTransform(value)
    }
}
impl ::std::convert::From<GeopathTransform> for Transform {
    fn from(value: GeopathTransform) -> Self {
        Self::GeopathTransform(value)
    }
}
impl ::std::convert::From<GeopointTransform> for Transform {
    fn from(value: GeopointTransform) -> Self {
        Self::GeopointTransform(value)
    }
}
impl ::std::convert::From<GeoshapeTransform> for Transform {
    fn from(value: GeoshapeTransform) -> Self {
        Self::GeoshapeTransform(value)
    }
}
impl ::std::convert::From<GraticuleTransform> for Transform {
    fn from(value: GraticuleTransform) -> Self {
        Self::GraticuleTransform(value)
    }
}
impl ::std::convert::From<HeatmapTransform> for Transform {
    fn from(value: HeatmapTransform) -> Self {
        Self::HeatmapTransform(value)
    }
}
impl ::std::convert::From<IsocontourTransform> for Transform {
    fn from(value: IsocontourTransform) -> Self {
        Self::IsocontourTransform(value)
    }
}
impl ::std::convert::From<Kde2dTransform> for Transform {
    fn from(value: Kde2dTransform) -> Self {
        Self::Kde2dTransform(value)
    }
}
impl ::std::convert::From<NestTransform> for Transform {
    fn from(value: NestTransform) -> Self {
        Self::NestTransform(value)
    }
}
impl ::std::convert::From<PackTransform> for Transform {
    fn from(value: PackTransform) -> Self {
        Self::PackTransform(value)
    }
}
impl ::std::convert::From<PartitionTransform> for Transform {
    fn from(value: PartitionTransform) -> Self {
        Self::PartitionTransform(value)
    }
}
impl ::std::convert::From<StratifyTransform> for Transform {
    fn from(value: StratifyTransform) -> Self {
        Self::StratifyTransform(value)
    }
}
impl ::std::convert::From<TreeTransform> for Transform {
    fn from(value: TreeTransform) -> Self {
        Self::TreeTransform(value)
    }
}
impl ::std::convert::From<TreelinksTransform> for Transform {
    fn from(value: TreelinksTransform) -> Self {
        Self::TreelinksTransform(value)
    }
}
impl ::std::convert::From<TreemapTransform> for Transform {
    fn from(value: TreemapTransform) -> Self {
        Self::TreemapTransform(value)
    }
}
impl ::std::convert::From<LabelTransform> for Transform {
    fn from(value: LabelTransform) -> Self {
        Self::LabelTransform(value)
    }
}
impl ::std::convert::From<LoessTransform> for Transform {
    fn from(value: LoessTransform) -> Self {
        Self::LoessTransform(value)
    }
}
impl ::std::convert::From<RegressionTransform> for Transform {
    fn from(value: RegressionTransform) -> Self {
        Self::RegressionTransform(value)
    }
}
impl ::std::convert::From<AggregateTransform> for Transform {
    fn from(value: AggregateTransform) -> Self {
        Self::AggregateTransform(value)
    }
}
impl ::std::convert::From<BinTransform> for Transform {
    fn from(value: BinTransform) -> Self {
        Self::BinTransform(value)
    }
}
impl ::std::convert::From<CollectTransform> for Transform {
    fn from(value: CollectTransform) -> Self {
        Self::CollectTransform(value)
    }
}
impl ::std::convert::From<CountpatternTransform> for Transform {
    fn from(value: CountpatternTransform) -> Self {
        Self::CountpatternTransform(value)
    }
}
impl ::std::convert::From<CrossTransform> for Transform {
    fn from(value: CrossTransform) -> Self {
        Self::CrossTransform(value)
    }
}
impl ::std::convert::From<DensityTransform> for Transform {
    fn from(value: DensityTransform) -> Self {
        Self::DensityTransform(value)
    }
}
impl ::std::convert::From<DotbinTransform> for Transform {
    fn from(value: DotbinTransform) -> Self {
        Self::DotbinTransform(value)
    }
}
impl ::std::convert::From<ExtentTransform> for Transform {
    fn from(value: ExtentTransform) -> Self {
        Self::ExtentTransform(value)
    }
}
impl ::std::convert::From<FilterTransform> for Transform {
    fn from(value: FilterTransform) -> Self {
        Self::FilterTransform(value)
    }
}
impl ::std::convert::From<FlattenTransform> for Transform {
    fn from(value: FlattenTransform) -> Self {
        Self::FlattenTransform(value)
    }
}
impl ::std::convert::From<FoldTransform> for Transform {
    fn from(value: FoldTransform) -> Self {
        Self::FoldTransform(value)
    }
}
impl ::std::convert::From<FormulaTransform> for Transform {
    fn from(value: FormulaTransform) -> Self {
        Self::FormulaTransform(value)
    }
}
impl ::std::convert::From<ImputeTransform> for Transform {
    fn from(value: ImputeTransform) -> Self {
        Self::ImputeTransform(value)
    }
}
impl ::std::convert::From<JoinaggregateTransform> for Transform {
    fn from(value: JoinaggregateTransform) -> Self {
        Self::JoinaggregateTransform(value)
    }
}
impl ::std::convert::From<KdeTransform> for Transform {
    fn from(value: KdeTransform) -> Self {
        Self::KdeTransform(value)
    }
}
impl ::std::convert::From<LookupTransform> for Transform {
    fn from(value: LookupTransform) -> Self {
        Self::LookupTransform(value)
    }
}
impl ::std::convert::From<PivotTransform> for Transform {
    fn from(value: PivotTransform) -> Self {
        Self::PivotTransform(value)
    }
}
impl ::std::convert::From<ProjectTransform> for Transform {
    fn from(value: ProjectTransform) -> Self {
        Self::ProjectTransform(value)
    }
}
impl ::std::convert::From<QuantileTransform> for Transform {
    fn from(value: QuantileTransform) -> Self {
        Self::QuantileTransform(value)
    }
}
impl ::std::convert::From<SampleTransform> for Transform {
    fn from(value: SampleTransform) -> Self {
        Self::SampleTransform(value)
    }
}
impl ::std::convert::From<SequenceTransform> for Transform {
    fn from(value: SequenceTransform) -> Self {
        Self::SequenceTransform(value)
    }
}
impl ::std::convert::From<TimeunitTransform> for Transform {
    fn from(value: TimeunitTransform) -> Self {
        Self::TimeunitTransform(value)
    }
}
impl ::std::convert::From<WindowTransform> for Transform {
    fn from(value: WindowTransform) -> Self {
        Self::WindowTransform(value)
    }
}
impl ::std::convert::From<IdentifierTransform> for Transform {
    fn from(value: IdentifierTransform) -> Self {
        Self::IdentifierTransform(value)
    }
}
impl ::std::convert::From<VoronoiTransform> for Transform {
    fn from(value: VoronoiTransform) -> Self {
        Self::VoronoiTransform(value)
    }
}
impl ::std::convert::From<WordcloudTransform> for Transform {
    fn from(value: WordcloudTransform) -> Self {
        Self::WordcloudTransform(value)
    }
}
#[doc = "`TransformMark`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossfilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/resolvefilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/linkpathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pieTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stackTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/forceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geojsonTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopointTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geoshapeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/heatmapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/packTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/partitionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stratifyTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treemapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/labelTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/binTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/collectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/dotbinTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/extentTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/formulaTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/joinaggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/lookupTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sampleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/timeunitTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/windowTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/identifierTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/voronoiTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/wordcloudTransform\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TransformMark {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    HeatmapTransform(HeatmapTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FormulaTransform(FormulaTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    LookupTransform(LookupTransform),
    SampleTransform(SampleTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl ::std::convert::From<&Self> for TransformMark {
    fn from(value: &TransformMark) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CrossfilterTransform> for TransformMark {
    fn from(value: CrossfilterTransform) -> Self {
        Self::CrossfilterTransform(value)
    }
}
impl ::std::convert::From<ResolvefilterTransform> for TransformMark {
    fn from(value: ResolvefilterTransform) -> Self {
        Self::ResolvefilterTransform(value)
    }
}
impl ::std::convert::From<LinkpathTransform> for TransformMark {
    fn from(value: LinkpathTransform) -> Self {
        Self::LinkpathTransform(value)
    }
}
impl ::std::convert::From<PieTransform> for TransformMark {
    fn from(value: PieTransform) -> Self {
        Self::PieTransform(value)
    }
}
impl ::std::convert::From<StackTransform> for TransformMark {
    fn from(value: StackTransform) -> Self {
        Self::StackTransform(value)
    }
}
impl ::std::convert::From<ForceTransform> for TransformMark {
    fn from(value: ForceTransform) -> Self {
        Self::ForceTransform(value)
    }
}
impl ::std::convert::From<GeojsonTransform> for TransformMark {
    fn from(value: GeojsonTransform) -> Self {
        Self::GeojsonTransform(value)
    }
}
impl ::std::convert::From<GeopathTransform> for TransformMark {
    fn from(value: GeopathTransform) -> Self {
        Self::GeopathTransform(value)
    }
}
impl ::std::convert::From<GeopointTransform> for TransformMark {
    fn from(value: GeopointTransform) -> Self {
        Self::GeopointTransform(value)
    }
}
impl ::std::convert::From<GeoshapeTransform> for TransformMark {
    fn from(value: GeoshapeTransform) -> Self {
        Self::GeoshapeTransform(value)
    }
}
impl ::std::convert::From<HeatmapTransform> for TransformMark {
    fn from(value: HeatmapTransform) -> Self {
        Self::HeatmapTransform(value)
    }
}
impl ::std::convert::From<PackTransform> for TransformMark {
    fn from(value: PackTransform) -> Self {
        Self::PackTransform(value)
    }
}
impl ::std::convert::From<PartitionTransform> for TransformMark {
    fn from(value: PartitionTransform) -> Self {
        Self::PartitionTransform(value)
    }
}
impl ::std::convert::From<StratifyTransform> for TransformMark {
    fn from(value: StratifyTransform) -> Self {
        Self::StratifyTransform(value)
    }
}
impl ::std::convert::From<TreeTransform> for TransformMark {
    fn from(value: TreeTransform) -> Self {
        Self::TreeTransform(value)
    }
}
impl ::std::convert::From<TreemapTransform> for TransformMark {
    fn from(value: TreemapTransform) -> Self {
        Self::TreemapTransform(value)
    }
}
impl ::std::convert::From<LabelTransform> for TransformMark {
    fn from(value: LabelTransform) -> Self {
        Self::LabelTransform(value)
    }
}
impl ::std::convert::From<BinTransform> for TransformMark {
    fn from(value: BinTransform) -> Self {
        Self::BinTransform(value)
    }
}
impl ::std::convert::From<CollectTransform> for TransformMark {
    fn from(value: CollectTransform) -> Self {
        Self::CollectTransform(value)
    }
}
impl ::std::convert::From<DotbinTransform> for TransformMark {
    fn from(value: DotbinTransform) -> Self {
        Self::DotbinTransform(value)
    }
}
impl ::std::convert::From<ExtentTransform> for TransformMark {
    fn from(value: ExtentTransform) -> Self {
        Self::ExtentTransform(value)
    }
}
impl ::std::convert::From<FormulaTransform> for TransformMark {
    fn from(value: FormulaTransform) -> Self {
        Self::FormulaTransform(value)
    }
}
impl ::std::convert::From<JoinaggregateTransform> for TransformMark {
    fn from(value: JoinaggregateTransform) -> Self {
        Self::JoinaggregateTransform(value)
    }
}
impl ::std::convert::From<LookupTransform> for TransformMark {
    fn from(value: LookupTransform) -> Self {
        Self::LookupTransform(value)
    }
}
impl ::std::convert::From<SampleTransform> for TransformMark {
    fn from(value: SampleTransform) -> Self {
        Self::SampleTransform(value)
    }
}
impl ::std::convert::From<TimeunitTransform> for TransformMark {
    fn from(value: TimeunitTransform) -> Self {
        Self::TimeunitTransform(value)
    }
}
impl ::std::convert::From<WindowTransform> for TransformMark {
    fn from(value: WindowTransform) -> Self {
        Self::WindowTransform(value)
    }
}
impl ::std::convert::From<IdentifierTransform> for TransformMark {
    fn from(value: IdentifierTransform) -> Self {
        Self::IdentifierTransform(value)
    }
}
impl ::std::convert::From<VoronoiTransform> for TransformMark {
    fn from(value: VoronoiTransform) -> Self {
        Self::VoronoiTransform(value)
    }
}
impl ::std::convert::From<WordcloudTransform> for TransformMark {
    fn from(value: WordcloudTransform) -> Self {
        Self::WordcloudTransform(value)
    }
}
#[doc = "`TreeTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 4,"]
#[doc = "          \"minItems\": 4"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"tidy\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"tidy\","]
#[doc = "            \"cluster\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nodeSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"separation\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"tree\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TreeTransform {
    #[serde(rename = "as", default = "defaults::tree_transform_as")]
    pub as_: TreeTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<TreeTransformField>,
    #[serde(default = "defaults::tree_transform_method")]
    pub method: TreeTransformMethod,
    #[serde(
        rename = "nodeSize",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub node_size: ::std::option::Option<TreeTransformNodeSize>,
    #[serde(default = "defaults::tree_transform_separation")]
    pub separation: TreeTransformSeparation,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<TreeTransformSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreeTransformType,
}
impl ::std::convert::From<&TreeTransform> for TreeTransform {
    fn from(value: &TreeTransform) -> Self {
        value.clone()
    }
}
#[doc = "`TreeTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 4,"]
#[doc = "      \"minItems\": 4"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformAs {
    Variant0([TreeTransformAsVariant0Item; 4usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformAs {
    fn from(value: &TreeTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreeTransformAs {
    fn default() -> Self {
        TreeTransformAs::Variant0([
            TreeTransformAsVariant0Item::Variant0("x".to_string()),
            TreeTransformAsVariant0Item::Variant0("y".to_string()),
            TreeTransformAsVariant0Item::Variant0("depth".to_string()),
            TreeTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl ::std::convert::From<[TreeTransformAsVariant0Item; 4usize]> for TreeTransformAs {
    fn from(value: [TreeTransformAsVariant0Item; 4usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformAsVariant0Item {
    fn from(value: &TreeTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for TreeTransformField {
    fn from(value: &TreeTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for TreeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for TreeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for TreeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`TreeTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"tidy\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"tidy\","]
#[doc = "        \"cluster\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformMethod {
    Variant0(TreeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformMethod {
    fn from(value: &TreeTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreeTransformMethod {
    fn default() -> Self {
        TreeTransformMethod::Variant0(TreeTransformMethodVariant0::Tidy)
    }
}
impl ::std::convert::From<TreeTransformMethodVariant0> for TreeTransformMethod {
    fn from(value: TreeTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformMethodVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"tidy\","]
#[doc = "    \"cluster\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TreeTransformMethodVariant0 {
    #[serde(rename = "tidy")]
    Tidy,
    #[serde(rename = "cluster")]
    Cluster,
}
impl ::std::convert::From<&Self> for TreeTransformMethodVariant0 {
    fn from(value: &TreeTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TreeTransformMethodVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Tidy => write!(f, "tidy"),
            Self::Cluster => write!(f, "cluster"),
        }
    }
}
impl ::std::str::FromStr for TreeTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tidy" => Ok(Self::Tidy),
            "cluster" => Ok(Self::Cluster),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TreeTransformNodeSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformNodeSize {
    Variant0([TreeTransformNodeSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformNodeSize {
    fn from(value: &TreeTransformNodeSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[TreeTransformNodeSizeVariant0Item; 2usize]> for TreeTransformNodeSize {
    fn from(value: [TreeTransformNodeSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformNodeSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformNodeSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformNodeSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformNodeSizeVariant0Item {
    fn from(value: &TreeTransformNodeSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreeTransformNodeSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformNodeSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformSeparation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformSeparation {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformSeparation {
    fn from(value: &TreeTransformSeparation) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreeTransformSeparation {
    fn default() -> Self {
        TreeTransformSeparation::Variant0(true)
    }
}
impl ::std::convert::From<bool> for TreeTransformSeparation {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformSeparation {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformSize {
    Variant0([TreeTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformSize {
    fn from(value: &TreeTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[TreeTransformSizeVariant0Item; 2usize]> for TreeTransformSize {
    fn from(value: [TreeTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreeTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreeTransformSizeVariant0Item {
    fn from(value: &TreeTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreeTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreeTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreeTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"tree\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TreeTransformType {
    #[serde(rename = "tree")]
    Tree,
}
impl ::std::convert::From<&Self> for TreeTransformType {
    fn from(value: &TreeTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TreeTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Tree => write!(f, "tree"),
        }
    }
}
impl ::std::str::FromStr for TreeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tree" => Ok(Self::Tree),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TreelinksTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"treelinks\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TreelinksTransform {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(rename = "type")]
    pub type_: TreelinksTransformType,
}
impl ::std::convert::From<&TreelinksTransform> for TreelinksTransform {
    fn from(value: &TreelinksTransform) -> Self {
        value.clone()
    }
}
#[doc = "`TreelinksTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"treelinks\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TreelinksTransformType {
    #[serde(rename = "treelinks")]
    Treelinks,
}
impl ::std::convert::From<&Self> for TreelinksTransformType {
    fn from(value: &TreelinksTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TreelinksTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Treelinks => write!(f, "treelinks"),
        }
    }
}
impl ::std::str::FromStr for TreelinksTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "treelinks" => Ok(Self::Treelinks),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TreemapTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x0\","]
#[doc = "        \"y0\","]
#[doc = "        \"x1\","]
#[doc = "        \"y1\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 6,"]
#[doc = "          \"minItems\": 6"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"squarify\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"squarify\","]
#[doc = "            \"resquarify\","]
#[doc = "            \"binary\","]
#[doc = "            \"dice\","]
#[doc = "            \"slice\","]
#[doc = "            \"slicedice\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingBottom\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingInner\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingLeft\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingOuter\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingRight\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingTop\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ratio\": {"]
#[doc = "      \"default\": 1.618033988749895,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"treemap\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct TreemapTransform {
    #[serde(rename = "as", default = "defaults::treemap_transform_as")]
    pub as_: TreemapTransformAs,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub field: ::std::option::Option<TreemapTransformField>,
    #[serde(default = "defaults::treemap_transform_method")]
    pub method: TreemapTransformMethod,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<TreemapTransformPadding>,
    #[serde(
        rename = "paddingBottom",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_bottom: ::std::option::Option<TreemapTransformPaddingBottom>,
    #[serde(
        rename = "paddingInner",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_inner: ::std::option::Option<TreemapTransformPaddingInner>,
    #[serde(
        rename = "paddingLeft",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_left: ::std::option::Option<TreemapTransformPaddingLeft>,
    #[serde(
        rename = "paddingOuter",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_outer: ::std::option::Option<TreemapTransformPaddingOuter>,
    #[serde(
        rename = "paddingRight",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_right: ::std::option::Option<TreemapTransformPaddingRight>,
    #[serde(
        rename = "paddingTop",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub padding_top: ::std::option::Option<TreemapTransformPaddingTop>,
    #[serde(default = "defaults::treemap_transform_ratio")]
    pub ratio: TreemapTransformRatio,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub round: ::std::option::Option<TreemapTransformRound>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<TreemapTransformSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreemapTransformType,
}
impl ::std::convert::From<&TreemapTransform> for TreemapTransform {
    fn from(value: &TreemapTransform) -> Self {
        value.clone()
    }
}
#[doc = "`TreemapTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x0\","]
#[doc = "    \"y0\","]
#[doc = "    \"x1\","]
#[doc = "    \"y1\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 6,"]
#[doc = "      \"minItems\": 6"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformAs {
    Variant0([TreemapTransformAsVariant0Item; 6usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformAs {
    fn from(value: &TreemapTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreemapTransformAs {
    fn default() -> Self {
        TreemapTransformAs::Variant0([
            TreemapTransformAsVariant0Item::Variant0("x0".to_string()),
            TreemapTransformAsVariant0Item::Variant0("y0".to_string()),
            TreemapTransformAsVariant0Item::Variant0("x1".to_string()),
            TreemapTransformAsVariant0Item::Variant0("y1".to_string()),
            TreemapTransformAsVariant0Item::Variant0("depth".to_string()),
            TreemapTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl ::std::convert::From<[TreemapTransformAsVariant0Item; 6usize]> for TreemapTransformAs {
    fn from(value: [TreemapTransformAsVariant0Item; 6usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformAsVariant0Item {
    fn from(value: &TreemapTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformField`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for TreemapTransformField {
    fn from(value: &TreemapTransformField) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for TreemapTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for TreemapTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for TreemapTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`TreemapTransformMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"squarify\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"squarify\","]
#[doc = "        \"resquarify\","]
#[doc = "        \"binary\","]
#[doc = "        \"dice\","]
#[doc = "        \"slice\","]
#[doc = "        \"slicedice\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformMethod {
    Variant0(TreemapTransformMethodVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformMethod {
    fn from(value: &TreemapTransformMethod) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreemapTransformMethod {
    fn default() -> Self {
        TreemapTransformMethod::Variant0(TreemapTransformMethodVariant0::Squarify)
    }
}
impl ::std::convert::From<TreemapTransformMethodVariant0> for TreemapTransformMethod {
    fn from(value: TreemapTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformMethodVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"squarify\","]
#[doc = "    \"resquarify\","]
#[doc = "    \"binary\","]
#[doc = "    \"dice\","]
#[doc = "    \"slice\","]
#[doc = "    \"slicedice\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TreemapTransformMethodVariant0 {
    #[serde(rename = "squarify")]
    Squarify,
    #[serde(rename = "resquarify")]
    Resquarify,
    #[serde(rename = "binary")]
    Binary,
    #[serde(rename = "dice")]
    Dice,
    #[serde(rename = "slice")]
    Slice,
    #[serde(rename = "slicedice")]
    Slicedice,
}
impl ::std::convert::From<&Self> for TreemapTransformMethodVariant0 {
    fn from(value: &TreemapTransformMethodVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TreemapTransformMethodVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Squarify => write!(f, "squarify"),
            Self::Resquarify => write!(f, "resquarify"),
            Self::Binary => write!(f, "binary"),
            Self::Dice => write!(f, "dice"),
            Self::Slice => write!(f, "slice"),
            Self::Slicedice => write!(f, "slicedice"),
        }
    }
}
impl ::std::str::FromStr for TreemapTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "squarify" => Ok(Self::Squarify),
            "resquarify" => Ok(Self::Resquarify),
            "binary" => Ok(Self::Binary),
            "dice" => Ok(Self::Dice),
            "slice" => Ok(Self::Slice),
            "slicedice" => Ok(Self::Slicedice),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`TreemapTransformPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPadding {
    fn from(value: &TreemapTransformPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingBottom`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingBottom {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingBottom {
    fn from(value: &TreemapTransformPaddingBottom) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingBottom {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingBottom {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingInner`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingInner {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingInner {
    fn from(value: &TreemapTransformPaddingInner) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingInner {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingInner {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingLeft`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingLeft {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingLeft {
    fn from(value: &TreemapTransformPaddingLeft) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingLeft {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingLeft {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingOuter`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingOuter {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingOuter {
    fn from(value: &TreemapTransformPaddingOuter) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingOuter {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingOuter {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingRight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingRight {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingRight {
    fn from(value: &TreemapTransformPaddingRight) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingRight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingRight {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformPaddingTop`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformPaddingTop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformPaddingTop {
    fn from(value: &TreemapTransformPaddingTop) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformPaddingTop {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformPaddingTop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformRatio`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1.618033988749895,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformRatio {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformRatio {
    fn from(value: &TreemapTransformRatio) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TreemapTransformRatio {
    fn default() -> Self {
        TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
}
impl ::std::convert::From<f64> for TreemapTransformRatio {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformRatio {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformRound`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformRound {
    fn from(value: &TreemapTransformRound) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for TreemapTransformRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformRound {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformSize {
    Variant0([TreemapTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformSize {
    fn from(value: &TreemapTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[TreemapTransformSizeVariant0Item; 2usize]> for TreemapTransformSize {
    fn from(value: [TreemapTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TreemapTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for TreemapTransformSizeVariant0Item {
    fn from(value: &TreemapTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for TreemapTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for TreemapTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`TreemapTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"treemap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TreemapTransformType {
    #[serde(rename = "treemap")]
    Treemap,
}
impl ::std::convert::From<&Self> for TreemapTransformType {
    fn from(value: &TreemapTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TreemapTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Treemap => write!(f, "treemap"),
        }
    }
}
impl ::std::str::FromStr for TreemapTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "treemap" => Ok(Self::Treemap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`VoronoiTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"default\": ["]
#[doc = "        ["]
#[doc = "          -100000,"]
#[doc = "          -100000"]
#[doc = "        ],"]
#[doc = "        ["]
#[doc = "          100000,"]
#[doc = "          100000"]
#[doc = "        ]"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"voronoi\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct VoronoiTransform {
    #[serde(rename = "as", default = "defaults::voronoi_transform_as")]
    pub as_: VoronoiTransformAs,
    #[serde(default = "defaults::voronoi_transform_extent")]
    pub extent: VoronoiTransformExtent,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<VoronoiTransformSize>,
    #[serde(rename = "type")]
    pub type_: VoronoiTransformType,
    pub x: VoronoiTransformX,
    pub y: VoronoiTransformY,
}
impl ::std::convert::From<&VoronoiTransform> for VoronoiTransform {
    fn from(value: &VoronoiTransform) -> Self {
        value.clone()
    }
}
#[doc = "`VoronoiTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformAs {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for VoronoiTransformAs {
    fn from(value: &VoronoiTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for VoronoiTransformAs {
    fn default() -> Self {
        VoronoiTransformAs::Variant0("path".to_string())
    }
}
impl ::std::convert::From<SignalRef> for VoronoiTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`VoronoiTransformExtent`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    ["]
#[doc = "      -100000,"]
#[doc = "      -100000"]
#[doc = "    ],"]
#[doc = "    ["]
#[doc = "      100000,"]
#[doc = "      100000"]
#[doc = "    ]"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformExtent {
    Variant0([::serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for VoronoiTransformExtent {
    fn from(value: &VoronoiTransformExtent) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for VoronoiTransformExtent {
    fn default() -> Self {
        VoronoiTransformExtent::Variant0([
            ::serde_json::from_str::<::serde_json::Value>("[-100000,-100000]").unwrap(),
            ::serde_json::from_str::<::serde_json::Value>("[100000,100000]").unwrap(),
        ])
    }
}
impl ::std::convert::From<[::serde_json::Value; 2usize]> for VoronoiTransformExtent {
    fn from(value: [::serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for VoronoiTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`VoronoiTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformSize {
    Variant0([VoronoiTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for VoronoiTransformSize {
    fn from(value: &VoronoiTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[VoronoiTransformSizeVariant0Item; 2usize]> for VoronoiTransformSize {
    fn from(value: [VoronoiTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for VoronoiTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`VoronoiTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for VoronoiTransformSizeVariant0Item {
    fn from(value: &VoronoiTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for VoronoiTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for VoronoiTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`VoronoiTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"voronoi\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VoronoiTransformType {
    #[serde(rename = "voronoi")]
    Voronoi,
}
impl ::std::convert::From<&Self> for VoronoiTransformType {
    fn from(value: &VoronoiTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VoronoiTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Voronoi => write!(f, "voronoi"),
        }
    }
}
impl ::std::str::FromStr for VoronoiTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "voronoi" => Ok(Self::Voronoi),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`VoronoiTransformX`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for VoronoiTransformX {
    fn from(value: &VoronoiTransformX) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for VoronoiTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for VoronoiTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for VoronoiTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`VoronoiTransformY`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum VoronoiTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for VoronoiTransformY {
    fn from(value: &VoronoiTransformY) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for VoronoiTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for VoronoiTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for VoronoiTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`WindowTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"frame\": {"]
#[doc = "      \"default\": ["]
#[doc = "        null,"]
#[doc = "        0"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ignorePeers\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"row_number\","]
#[doc = "                  \"rank\","]
#[doc = "                  \"dense_rank\","]
#[doc = "                  \"percent_rank\","]
#[doc = "                  \"cume_dist\","]
#[doc = "                  \"ntile\","]
#[doc = "                  \"lag\","]
#[doc = "                  \"lead\","]
#[doc = "                  \"first_value\","]
#[doc = "                  \"last_value\","]
#[doc = "                  \"nth_value\","]
#[doc = "                  \"prev_value\","]
#[doc = "                  \"next_value\","]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"window\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WindowTransform {
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<WindowTransformAs>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub fields: ::std::option::Option<WindowTransformFields>,
    #[serde(default = "defaults::window_transform_frame")]
    pub frame: WindowTransformFrame,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub groupby: ::std::option::Option<WindowTransformGroupby>,
    #[serde(
        rename = "ignorePeers",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub ignore_peers: ::std::option::Option<WindowTransformIgnorePeers>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub ops: ::std::option::Option<WindowTransformOps>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub params: ::std::option::Option<WindowTransformParams>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sort: ::std::option::Option<Compare>,
    #[serde(rename = "type")]
    pub type_: WindowTransformType,
}
impl ::std::convert::From<&WindowTransform> for WindowTransform {
    fn from(value: &WindowTransform) -> Self {
        value.clone()
    }
}
#[doc = "`WindowTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformAs {
    Variant0(::std::vec::Vec<WindowTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformAs {
    fn from(value: &WindowTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WindowTransformAsVariant0Item>> for WindowTransformAs {
    fn from(value: ::std::vec::Vec<WindowTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for WindowTransformAsVariant0Item {
    fn from(value: &WindowTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformFields`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformFields {
    Variant0(::std::vec::Vec<WindowTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformFields {
    fn from(value: &WindowTransformFields) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WindowTransformFieldsVariant0Item>>
    for WindowTransformFields
{
    fn from(value: ::std::vec::Vec<WindowTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformFieldsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl ::std::convert::From<&Self> for WindowTransformFieldsVariant0Item {
    fn from(value: &WindowTransformFieldsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for WindowTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<ParamField> for WindowTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WindowTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "`WindowTransformFrame`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    null,"]
#[doc = "    0"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformFrame {
    Variant0([WindowTransformFrameVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformFrame {
    fn from(value: &WindowTransformFrame) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WindowTransformFrame {
    fn default() -> Self {
        WindowTransformFrame::Variant0([
            WindowTransformFrameVariant0Item::Variant2,
            WindowTransformFrameVariant0Item::Variant0(0_f64),
        ])
    }
}
impl ::std::convert::From<[WindowTransformFrameVariant0Item; 2usize]> for WindowTransformFrame {
    fn from(value: [WindowTransformFrameVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformFrame {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformFrameVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformFrameVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for WindowTransformFrameVariant0Item {
    fn from(value: &WindowTransformFrameVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WindowTransformFrameVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformFrameVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformGroupby`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformGroupby {
    Variant0(::std::vec::Vec<WindowTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformGroupby {
    fn from(value: &WindowTransformGroupby) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WindowTransformGroupbyVariant0Item>>
    for WindowTransformGroupby
{
    fn from(value: ::std::vec::Vec<WindowTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformGroupbyVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for WindowTransformGroupbyVariant0Item {
    fn from(value: &WindowTransformGroupbyVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for WindowTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for WindowTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for WindowTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`WindowTransformIgnorePeers`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformIgnorePeers {
    Variant0(bool),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformIgnorePeers {
    fn from(value: &WindowTransformIgnorePeers) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<bool> for WindowTransformIgnorePeers {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformIgnorePeers {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformOps`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"row_number\","]
#[doc = "              \"rank\","]
#[doc = "              \"dense_rank\","]
#[doc = "              \"percent_rank\","]
#[doc = "              \"cume_dist\","]
#[doc = "              \"ntile\","]
#[doc = "              \"lag\","]
#[doc = "              \"lead\","]
#[doc = "              \"first_value\","]
#[doc = "              \"last_value\","]
#[doc = "              \"nth_value\","]
#[doc = "              \"prev_value\","]
#[doc = "              \"next_value\","]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformOps {
    Variant0(::std::vec::Vec<WindowTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformOps {
    fn from(value: &WindowTransformOps) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WindowTransformOpsVariant0Item>> for WindowTransformOps {
    fn from(value: ::std::vec::Vec<WindowTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformOpsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"row_number\","]
#[doc = "        \"rank\","]
#[doc = "        \"dense_rank\","]
#[doc = "        \"percent_rank\","]
#[doc = "        \"cume_dist\","]
#[doc = "        \"ntile\","]
#[doc = "        \"lag\","]
#[doc = "        \"lead\","]
#[doc = "        \"first_value\","]
#[doc = "        \"last_value\","]
#[doc = "        \"nth_value\","]
#[doc = "        \"prev_value\","]
#[doc = "        \"next_value\","]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformOpsVariant0Item {
    Variant0(WindowTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformOpsVariant0Item {
    fn from(value: &WindowTransformOpsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<WindowTransformOpsVariant0ItemVariant0>
    for WindowTransformOpsVariant0Item
{
    fn from(value: WindowTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformOpsVariant0ItemVariant0`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"row_number\","]
#[doc = "    \"rank\","]
#[doc = "    \"dense_rank\","]
#[doc = "    \"percent_rank\","]
#[doc = "    \"cume_dist\","]
#[doc = "    \"ntile\","]
#[doc = "    \"lag\","]
#[doc = "    \"lead\","]
#[doc = "    \"first_value\","]
#[doc = "    \"last_value\","]
#[doc = "    \"nth_value\","]
#[doc = "    \"prev_value\","]
#[doc = "    \"next_value\","]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WindowTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "row_number")]
    RowXnumber,
    #[serde(rename = "rank")]
    Rank,
    #[serde(rename = "dense_rank")]
    DenseXrank,
    #[serde(rename = "percent_rank")]
    PercentXrank,
    #[serde(rename = "cume_dist")]
    CumeXdist,
    #[serde(rename = "ntile")]
    Ntile,
    #[serde(rename = "lag")]
    Lag,
    #[serde(rename = "lead")]
    Lead,
    #[serde(rename = "first_value")]
    FirstXvalue,
    #[serde(rename = "last_value")]
    LastXvalue,
    #[serde(rename = "nth_value")]
    NthXvalue,
    #[serde(rename = "prev_value")]
    PrevXvalue,
    #[serde(rename = "next_value")]
    NextXvalue,
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    XXcountXx,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl ::std::convert::From<&Self> for WindowTransformOpsVariant0ItemVariant0 {
    fn from(value: &WindowTransformOpsVariant0ItemVariant0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WindowTransformOpsVariant0ItemVariant0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RowXnumber => write!(f, "row_number"),
            Self::Rank => write!(f, "rank"),
            Self::DenseXrank => write!(f, "dense_rank"),
            Self::PercentXrank => write!(f, "percent_rank"),
            Self::CumeXdist => write!(f, "cume_dist"),
            Self::Ntile => write!(f, "ntile"),
            Self::Lag => write!(f, "lag"),
            Self::Lead => write!(f, "lead"),
            Self::FirstXvalue => write!(f, "first_value"),
            Self::LastXvalue => write!(f, "last_value"),
            Self::NthXvalue => write!(f, "nth_value"),
            Self::PrevXvalue => write!(f, "prev_value"),
            Self::NextXvalue => write!(f, "next_value"),
            Self::Values => write!(f, "values"),
            Self::Count => write!(f, "count"),
            Self::XXcountXx => write!(f, "__count__"),
            Self::Missing => write!(f, "missing"),
            Self::Valid => write!(f, "valid"),
            Self::Sum => write!(f, "sum"),
            Self::Product => write!(f, "product"),
            Self::Mean => write!(f, "mean"),
            Self::Average => write!(f, "average"),
            Self::Variance => write!(f, "variance"),
            Self::Variancep => write!(f, "variancep"),
            Self::Stdev => write!(f, "stdev"),
            Self::Stdevp => write!(f, "stdevp"),
            Self::Stderr => write!(f, "stderr"),
            Self::Distinct => write!(f, "distinct"),
            Self::Ci0 => write!(f, "ci0"),
            Self::Ci1 => write!(f, "ci1"),
            Self::Median => write!(f, "median"),
            Self::Q1 => write!(f, "q1"),
            Self::Q3 => write!(f, "q3"),
            Self::Min => write!(f, "min"),
            Self::Max => write!(f, "max"),
            Self::Argmin => write!(f, "argmin"),
            Self::Argmax => write!(f, "argmax"),
        }
    }
}
impl ::std::str::FromStr for WindowTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "row_number" => Ok(Self::RowXnumber),
            "rank" => Ok(Self::Rank),
            "dense_rank" => Ok(Self::DenseXrank),
            "percent_rank" => Ok(Self::PercentXrank),
            "cume_dist" => Ok(Self::CumeXdist),
            "ntile" => Ok(Self::Ntile),
            "lag" => Ok(Self::Lag),
            "lead" => Ok(Self::Lead),
            "first_value" => Ok(Self::FirstXvalue),
            "last_value" => Ok(Self::LastXvalue),
            "nth_value" => Ok(Self::NthXvalue),
            "prev_value" => Ok(Self::PrevXvalue),
            "next_value" => Ok(Self::NextXvalue),
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::XXcountXx),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WindowTransformParams`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformParams {
    Variant0(::std::vec::Vec<WindowTransformParamsVariant0Item>),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WindowTransformParams {
    fn from(value: &WindowTransformParams) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<WindowTransformParamsVariant0Item>>
    for WindowTransformParams
{
    fn from(value: ::std::vec::Vec<WindowTransformParamsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformParams {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformParamsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WindowTransformParamsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for WindowTransformParamsVariant0Item {
    fn from(value: &WindowTransformParamsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WindowTransformParamsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WindowTransformParamsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WindowTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"window\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WindowTransformType {
    #[serde(rename = "window")]
    Window,
}
impl ::std::convert::From<&Self> for WindowTransformType {
    fn from(value: &WindowTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WindowTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Window => write!(f, "window"),
        }
    }
}
impl ::std::str::FromStr for WindowTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "window" => Ok(Self::Window),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`WordcloudTransform`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"font\","]
#[doc = "        \"fontSize\","]
#[doc = "        \"fontStyle\","]
#[doc = "        \"fontWeight\","]
#[doc = "        \"angle\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 7,"]
#[doc = "          \"minItems\": 7"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"font\": {"]
#[doc = "      \"default\": \"sans-serif\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontSize\": {"]
#[doc = "      \"default\": 14,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontSizeRange\": {"]
#[doc = "      \"default\": ["]
#[doc = "        10,"]
#[doc = "        50"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontStyle\": {"]
#[doc = "      \"default\": \"normal\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontWeight\": {"]
#[doc = "      \"default\": \"normal\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"rotate\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"spiral\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"wordcloud\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct WordcloudTransform {
    #[serde(rename = "as", default = "defaults::wordcloud_transform_as")]
    pub as_: WordcloudTransformAs,
    #[serde(default = "defaults::wordcloud_transform_font")]
    pub font: WordcloudTransformFont,
    #[serde(
        rename = "fontSize",
        default = "defaults::wordcloud_transform_font_size"
    )]
    pub font_size: WordcloudTransformFontSize,
    #[serde(
        rename = "fontSizeRange",
        default = "defaults::wordcloud_transform_font_size_range"
    )]
    pub font_size_range: WordcloudTransformFontSizeRange,
    #[serde(
        rename = "fontStyle",
        default = "defaults::wordcloud_transform_font_style"
    )]
    pub font_style: WordcloudTransformFontStyle,
    #[serde(
        rename = "fontWeight",
        default = "defaults::wordcloud_transform_font_weight"
    )]
    pub font_weight: WordcloudTransformFontWeight,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub padding: ::std::option::Option<WordcloudTransformPadding>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rotate: ::std::option::Option<WordcloudTransformRotate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub signal: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub size: ::std::option::Option<WordcloudTransformSize>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub spiral: ::std::option::Option<WordcloudTransformSpiral>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub text: ::std::option::Option<WordcloudTransformText>,
    #[serde(rename = "type")]
    pub type_: WordcloudTransformType,
}
impl ::std::convert::From<&WordcloudTransform> for WordcloudTransform {
    fn from(value: &WordcloudTransform) -> Self {
        value.clone()
    }
}
#[doc = "`WordcloudTransformAs`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"font\","]
#[doc = "    \"fontSize\","]
#[doc = "    \"fontStyle\","]
#[doc = "    \"fontWeight\","]
#[doc = "    \"angle\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 7,"]
#[doc = "      \"minItems\": 7"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformAs {
    Variant0([WordcloudTransformAsVariant0Item; 7usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformAs {
    fn from(value: &WordcloudTransformAs) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformAs {
    fn default() -> Self {
        WordcloudTransformAs::Variant0([
            WordcloudTransformAsVariant0Item::Variant0("x".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("y".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("font".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontSize".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontStyle".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontWeight".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("angle".to_string()),
        ])
    }
}
impl ::std::convert::From<[WordcloudTransformAsVariant0Item; 7usize]> for WordcloudTransformAs {
    fn from(value: [WordcloudTransformAsVariant0Item; 7usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformAsVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformAsVariant0Item {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformAsVariant0Item {
    fn from(value: &WordcloudTransformAsVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformFont`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"sans-serif\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFont {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformFont {
    fn from(value: &WordcloudTransformFont) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformFont {
    fn default() -> Self {
        WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFont {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformFont {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformFont {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformFontSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 14,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFontSize {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformFontSize {
    fn from(value: &WordcloudTransformFontSize) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformFontSize {
    fn default() -> Self {
        WordcloudTransformFontSize::Variant0(14_f64)
    }
}
impl ::std::convert::From<f64> for WordcloudTransformFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFontSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformFontSize {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformFontSize {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformFontSizeRange`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    10,"]
#[doc = "    50"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRange {
    Variant0(::std::vec::Vec<WordcloudTransformFontSizeRangeVariant0Item>),
    Variant1(SignalRef),
    Variant2,
}
impl ::std::convert::From<&Self> for WordcloudTransformFontSizeRange {
    fn from(value: &WordcloudTransformFontSizeRange) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformFontSizeRange {
    fn default() -> Self {
        WordcloudTransformFontSizeRange::Variant0(vec![
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
}
impl ::std::convert::From<::std::vec::Vec<WordcloudTransformFontSizeRangeVariant0Item>>
    for WordcloudTransformFontSizeRange
{
    fn from(value: ::std::vec::Vec<WordcloudTransformFontSizeRangeVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFontSizeRange {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformFontSizeRangeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRangeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: &WordcloudTransformFontSizeRangeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformFontStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"normal\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFontStyle {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformFontStyle {
    fn from(value: &WordcloudTransformFontStyle) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformFontStyle {
    fn default() -> Self {
        WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFontStyle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformFontStyle {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformFontStyle {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformFontWeight`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"normal\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformFontWeight {
    Variant0(::std::string::String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformFontWeight {
    fn from(value: &WordcloudTransformFontWeight) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for WordcloudTransformFontWeight {
    fn default() -> Self {
        WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformFontWeight {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformFontWeight {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformFontWeight {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformPadding`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformPadding {
    fn from(value: &WordcloudTransformPadding) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WordcloudTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformPadding {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformPadding {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformRotate`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformRotate {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl ::std::convert::From<&Self> for WordcloudTransformRotate {
    fn from(value: &WordcloudTransformRotate) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WordcloudTransformRotate {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformRotate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformRotate {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformRotate {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "`WordcloudTransformSize`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformSize {
    Variant0([WordcloudTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformSize {
    fn from(value: &WordcloudTransformSize) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<[WordcloudTransformSizeVariant0Item; 2usize]> for WordcloudTransformSize {
    fn from(value: [WordcloudTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformSizeVariant0Item`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformSizeVariant0Item {
    fn from(value: &WordcloudTransformSizeVariant0Item) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<f64> for WordcloudTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformSpiral`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformSpiral {
    Variant0(::std::string::String),
    Variant1(SignalRef),
}
impl ::std::convert::From<&Self> for WordcloudTransformSpiral {
    fn from(value: &WordcloudTransformSpiral) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SignalRef> for WordcloudTransformSpiral {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "`WordcloudTransformText`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum WordcloudTransformText {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl ::std::convert::From<&Self> for WordcloudTransformText {
    fn from(value: &WordcloudTransformText) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ScaleField> for WordcloudTransformText {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl ::std::convert::From<ParamField> for WordcloudTransformText {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl ::std::convert::From<Expr> for WordcloudTransformText {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "`WordcloudTransformType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"wordcloud\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WordcloudTransformType {
    #[serde(rename = "wordcloud")]
    Wordcloud,
}
impl ::std::convert::From<&Self> for WordcloudTransformType {
    fn from(value: &WordcloudTransformType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WordcloudTransformType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Wordcloud => write!(f, "wordcloud"),
        }
    }
}
impl ::std::str::FromStr for WordcloudTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "wordcloud" => Ok(Self::Wordcloud),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = r" Generation of default values for serde."]
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn default_i64<T, const V: i64>() -> T
    where
        T: ::std::convert::TryFrom<i64>,
        <T as ::std::convert::TryFrom<i64>>::Error: ::std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
    pub(super) fn aggregate_transform_drop() -> super::AggregateTransformDrop {
        super::AggregateTransformDrop::Variant0(true)
    }
    pub(super) fn bin_transform_as() -> super::BinTransformAs {
        super::BinTransformAs::Variant0([
            super::BinTransformAsVariant0Item::Variant0("bin0".to_string()),
            super::BinTransformAsVariant0Item::Variant0("bin1".to_string()),
        ])
    }
    pub(super) fn bin_transform_base() -> super::BinTransformBase {
        super::BinTransformBase::Variant0(10_f64)
    }
    pub(super) fn bin_transform_divide() -> super::BinTransformDivide {
        super::BinTransformDivide::Variant0(vec![
            super::BinTransformDivideVariant0Item::Variant0(5_f64),
            super::BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
    pub(super) fn bin_transform_interval() -> super::BinTransformInterval {
        super::BinTransformInterval::Variant0(true)
    }
    pub(super) fn bin_transform_maxbins() -> super::BinTransformMaxbins {
        super::BinTransformMaxbins::Variant0(20_f64)
    }
    pub(super) fn bin_transform_nice() -> super::BinTransformNice {
        super::BinTransformNice::Variant0(true)
    }
    pub(super) fn contour_transform_smooth() -> super::ContourTransformSmooth {
        super::ContourTransformSmooth::Variant0(true)
    }
    pub(super) fn countpattern_transform_as() -> super::CountpatternTransformAs {
        super::CountpatternTransformAs::Variant0([
            super::CountpatternTransformAsVariant0Item::Variant0("text".to_string()),
            super::CountpatternTransformAsVariant0Item::Variant0("count".to_string()),
        ])
    }
    pub(super) fn countpattern_transform_case() -> super::CountpatternTransformCase {
        super::CountpatternTransformCase::Variant0(super::CountpatternTransformCaseVariant0::Mixed)
    }
    pub(super) fn countpattern_transform_pattern() -> super::CountpatternTransformPattern {
        super::CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
    pub(super) fn cross_transform_as() -> super::CrossTransformAs {
        super::CrossTransformAs::Variant0([
            super::CrossTransformAsVariant0Item::Variant0("a".to_string()),
            super::CrossTransformAsVariant0Item::Variant0("b".to_string()),
        ])
    }
    pub(super) fn density_transform_as() -> super::DensityTransformAs {
        super::DensityTransformAs::Variant0(vec![
            super::DensityTransformAsVariant0Item::Variant0("value".to_string()),
            super::DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn density_transform_maxsteps() -> super::DensityTransformMaxsteps {
        super::DensityTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn density_transform_method() -> super::DensityTransformMethod {
        super::DensityTransformMethod::Variant0("pdf".to_string())
    }
    pub(super) fn density_transform_minsteps() -> super::DensityTransformMinsteps {
        super::DensityTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn density_transform_distribution_lognormal_stdev(
    ) -> super::DensityTransformDistributionStdev {
        super::DensityTransformDistributionStdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_normal_stdev(
    ) -> super::DensityTransformDistributionStdev {
        super::DensityTransformDistributionStdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_uniform_max(
    ) -> super::DensityTransformDistributionMax {
        super::DensityTransformDistributionMax::Variant0(1_f64)
    }
    pub(super) fn dotbin_transform_as() -> super::DotbinTransformAs {
        super::DotbinTransformAs::Variant0("bin".to_string())
    }
    pub(super) fn fold_transform_as() -> super::FoldTransformAs {
        super::FoldTransformAs::Variant0([
            super::FoldTransformAsVariant0Item::Variant0("key".to_string()),
            super::FoldTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn force_transform_alpha() -> super::ForceTransformAlpha {
        super::ForceTransformAlpha::Variant0(1_f64)
    }
    pub(super) fn force_transform_alpha_min() -> super::ForceTransformAlphaMin {
        super::ForceTransformAlphaMin::Variant0(0.001_f64)
    }
    pub(super) fn force_transform_as() -> super::ForceTransformAs {
        super::ForceTransformAs::Variant0(vec![
            super::ForceTransformAsVariant0Item::Variant0("x".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("y".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
    pub(super) fn force_transform_iterations() -> super::ForceTransformIterations {
        super::ForceTransformIterations::Variant0(300_f64)
    }
    pub(super) fn force_transform_velocity_decay() -> super::ForceTransformVelocityDecay {
        super::ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
    pub(super) fn force_transform_forces_item_collide_iterations(
    ) -> super::ForceTransformForcesItemIterations {
        super::ForceTransformForcesItemIterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_collide_strength(
    ) -> super::ForceTransformForcesItemStrength {
        super::ForceTransformForcesItemStrength::Variant0(0.7_f64)
    }
    pub(super) fn force_transform_forces_item_link_distance(
    ) -> super::ForceTransformForcesItemDistance {
        super::ForceTransformForcesItemDistance::Variant0(30_f64)
    }
    pub(super) fn force_transform_forces_item_link_iterations(
    ) -> super::ForceTransformForcesItemIterations {
        super::ForceTransformForcesItemIterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_distance_min(
    ) -> super::ForceTransformForcesItemDistanceMin {
        super::ForceTransformForcesItemDistanceMin::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_strength(
    ) -> super::ForceTransformForcesItemStrength {
        super::ForceTransformForcesItemStrength::Variant0(-30_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_theta() -> super::ForceTransformForcesItemTheta
    {
        super::ForceTransformForcesItemTheta::Variant0(0.9_f64)
    }
    pub(super) fn force_transform_forces_item_x_strength() -> super::ForceTransformForcesItemStrength
    {
        super::ForceTransformForcesItemStrength::Variant0(0.1_f64)
    }
    pub(super) fn force_transform_forces_item_y_strength() -> super::ForceTransformForcesItemStrength
    {
        super::ForceTransformForcesItemStrength::Variant0(0.1_f64)
    }
    pub(super) fn geopath_transform_as() -> super::GeopathTransformAs {
        super::GeopathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn geopoint_transform_as() -> super::GeopointTransformAs {
        super::GeopointTransformAs::Variant0([
            super::GeopointTransformAsVariant0Item::Variant0("x".to_string()),
            super::GeopointTransformAsVariant0Item::Variant0("y".to_string()),
        ])
    }
    pub(super) fn geoshape_transform_as() -> super::GeoshapeTransformAs {
        super::GeoshapeTransformAs::Variant0("shape".to_string())
    }
    pub(super) fn geoshape_transform_field() -> super::GeoshapeTransformField {
        super::GeoshapeTransformField::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("datum".to_string()),
        ))
    }
    pub(super) fn graticule_transform_precision() -> super::GraticuleTransformPrecision {
        super::GraticuleTransformPrecision::Variant0(2.5_f64)
    }
    pub(super) fn graticule_transform_step_major() -> super::GraticuleTransformStepMajor {
        super::GraticuleTransformStepMajor::Variant0([
            super::GraticuleTransformStepMajorVariant0Item::Variant0(90_f64),
            super::GraticuleTransformStepMajorVariant0Item::Variant0(360_f64),
        ])
    }
    pub(super) fn graticule_transform_step_minor() -> super::GraticuleTransformStepMinor {
        super::GraticuleTransformStepMinor::Variant0([
            super::GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
            super::GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
        ])
    }
    pub(super) fn heatmap_transform_as() -> super::HeatmapTransformAs {
        super::HeatmapTransformAs::Variant0("image".to_string())
    }
    pub(super) fn heatmap_transform_resolve() -> super::HeatmapTransformResolve {
        super::HeatmapTransformResolve::Variant0(
            super::HeatmapTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn impute_transform_method() -> super::ImputeTransformMethod {
        super::ImputeTransformMethod::Variant0(super::ImputeTransformMethodVariant0::Value)
    }
    pub(super) fn isocontour_transform_as() -> super::IsocontourTransformAs {
        super::IsocontourTransformAs::Variant0("contour".to_string())
    }
    pub(super) fn isocontour_transform_resolve() -> super::IsocontourTransformResolve {
        super::IsocontourTransformResolve::Variant0(
            super::IsocontourTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn isocontour_transform_smooth() -> super::IsocontourTransformSmooth {
        super::IsocontourTransformSmooth::Variant0(true)
    }
    pub(super) fn isocontour_transform_zero() -> super::IsocontourTransformZero {
        super::IsocontourTransformZero::Variant0(true)
    }
    pub(super) fn kde2d_transform_as() -> super::Kde2dTransformAs {
        super::Kde2dTransformAs::Variant0("grid".to_string())
    }
    pub(super) fn kde_transform_as() -> super::KdeTransformAs {
        super::KdeTransformAs::Variant0(vec![
            super::KdeTransformAsVariant0Item::Variant0("value".to_string()),
            super::KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn kde_transform_maxsteps() -> super::KdeTransformMaxsteps {
        super::KdeTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn kde_transform_minsteps() -> super::KdeTransformMinsteps {
        super::KdeTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn kde_transform_resolve() -> super::KdeTransformResolve {
        super::KdeTransformResolve::Variant0(super::KdeTransformResolveVariant0::Independent)
    }
    pub(super) fn label_transform_anchor() -> super::LabelTransformAnchor {
        super::LabelTransformAnchor::Variant0(vec![
            super::LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
    pub(super) fn label_transform_as() -> super::LabelTransformAs {
        super::LabelTransformAs::Variant0([
            super::LabelTransformAsVariant0Item::Variant0("x".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("y".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("opacity".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("align".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("baseline".to_string()),
        ])
    }
    pub(super) fn label_transform_avoid_base_mark() -> super::LabelTransformAvoidBaseMark {
        super::LabelTransformAvoidBaseMark::Variant0(true)
    }
    pub(super) fn label_transform_line_anchor() -> super::LabelTransformLineAnchor {
        super::LabelTransformLineAnchor::Variant0("end".to_string())
    }
    pub(super) fn label_transform_method() -> super::LabelTransformMethod {
        super::LabelTransformMethod::Variant0("naive".to_string())
    }
    pub(super) fn label_transform_offset() -> super::LabelTransformOffset {
        super::LabelTransformOffset::Variant0(vec![
            super::LabelTransformOffsetVariant0Item::Variant0(1_f64),
        ])
    }
    pub(super) fn linkpath_transform_as() -> super::LinkpathTransformAs {
        super::LinkpathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn linkpath_transform_orient() -> super::LinkpathTransformOrient {
        super::LinkpathTransformOrient::Variant0(super::LinkpathTransformOrientVariant0::Vertical)
    }
    pub(super) fn linkpath_transform_shape() -> super::LinkpathTransformShape {
        super::LinkpathTransformShape::Variant0(super::LinkpathTransformShapeVariant0::Line)
    }
    pub(super) fn linkpath_transform_source_x() -> super::LinkpathTransformSourceX {
        super::LinkpathTransformSourceX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_source_y() -> super::LinkpathTransformSourceY {
        super::LinkpathTransformSourceY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.y".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_x() -> super::LinkpathTransformTargetX {
        super::LinkpathTransformTargetX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_y() -> super::LinkpathTransformTargetY {
        super::LinkpathTransformTargetY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.y".to_string()),
        ))
    }
    pub(super) fn loess_transform_bandwidth() -> super::LoessTransformBandwidth {
        super::LoessTransformBandwidth::Variant0(0.3_f64)
    }
    pub(super) fn pack_transform_as() -> super::PackTransformAs {
        super::PackTransformAs::Variant0([
            super::PackTransformAsVariant0Item::Variant0("x".to_string()),
            super::PackTransformAsVariant0Item::Variant0("y".to_string()),
            super::PackTransformAsVariant0Item::Variant0("r".to_string()),
            super::PackTransformAsVariant0Item::Variant0("depth".to_string()),
            super::PackTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn partition_transform_as() -> super::PartitionTransformAs {
        super::PartitionTransformAs::Variant0([
            super::PartitionTransformAsVariant0Item::Variant0("x0".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("y0".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("x1".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("y1".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("depth".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn pie_transform_as() -> super::PieTransformAs {
        super::PieTransformAs::Variant0([
            super::PieTransformAsVariant0Item::Variant0("startAngle".to_string()),
            super::PieTransformAsVariant0Item::Variant0("endAngle".to_string()),
        ])
    }
    pub(super) fn pie_transform_end_angle() -> super::PieTransformEndAngle {
        super::PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
    pub(super) fn pivot_transform_op() -> super::PivotTransformOp {
        super::PivotTransformOp::Variant0(super::PivotTransformOpVariant0::Sum)
    }
    pub(super) fn quantile_transform_as() -> super::QuantileTransformAs {
        super::QuantileTransformAs::Variant0(vec![
            super::QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            super::QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn quantile_transform_step() -> super::QuantileTransformStep {
        super::QuantileTransformStep::Variant0(0.01_f64)
    }
    pub(super) fn regression_transform_method() -> super::RegressionTransformMethod {
        super::RegressionTransformMethod::Variant0("linear".to_string())
    }
    pub(super) fn regression_transform_order() -> super::RegressionTransformOrder {
        super::RegressionTransformOrder::Variant0(3_f64)
    }
    pub(super) fn sample_transform_size() -> super::SampleTransformSize {
        super::SampleTransformSize::Variant0(1000_f64)
    }
    pub(super) fn sequence_transform_as() -> super::SequenceTransformAs {
        super::SequenceTransformAs::Variant0("data".to_string())
    }
    pub(super) fn sequence_transform_step() -> super::SequenceTransformStep {
        super::SequenceTransformStep::Variant0(1_f64)
    }
    pub(super) fn stack_transform_as() -> super::StackTransformAs {
        super::StackTransformAs::Variant0([
            super::StackTransformAsVariant0Item::Variant0("y0".to_string()),
            super::StackTransformAsVariant0Item::Variant0("y1".to_string()),
        ])
    }
    pub(super) fn stack_transform_offset() -> super::StackTransformOffset {
        super::StackTransformOffset::Variant0(super::StackTransformOffsetVariant0::Zero)
    }
    pub(super) fn timeunit_transform_as() -> super::TimeunitTransformAs {
        super::TimeunitTransformAs::Variant0([
            super::TimeunitTransformAsVariant0Item::Variant0("unit0".to_string()),
            super::TimeunitTransformAsVariant0Item::Variant0("unit1".to_string()),
        ])
    }
    pub(super) fn timeunit_transform_interval() -> super::TimeunitTransformInterval {
        super::TimeunitTransformInterval::Variant0(true)
    }
    pub(super) fn timeunit_transform_maxbins() -> super::TimeunitTransformMaxbins {
        super::TimeunitTransformMaxbins::Variant0(40_f64)
    }
    pub(super) fn timeunit_transform_step() -> super::TimeunitTransformStep {
        super::TimeunitTransformStep::Variant0(1_f64)
    }
    pub(super) fn timeunit_transform_timezone() -> super::TimeunitTransformTimezone {
        super::TimeunitTransformTimezone::Variant0(super::TimeunitTransformTimezoneVariant0::Local)
    }
    pub(super) fn tree_transform_as() -> super::TreeTransformAs {
        super::TreeTransformAs::Variant0([
            super::TreeTransformAsVariant0Item::Variant0("x".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("y".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("depth".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn tree_transform_method() -> super::TreeTransformMethod {
        super::TreeTransformMethod::Variant0(super::TreeTransformMethodVariant0::Tidy)
    }
    pub(super) fn tree_transform_separation() -> super::TreeTransformSeparation {
        super::TreeTransformSeparation::Variant0(true)
    }
    pub(super) fn treemap_transform_as() -> super::TreemapTransformAs {
        super::TreemapTransformAs::Variant0([
            super::TreemapTransformAsVariant0Item::Variant0("x0".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("y0".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("x1".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("y1".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("depth".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn treemap_transform_method() -> super::TreemapTransformMethod {
        super::TreemapTransformMethod::Variant0(super::TreemapTransformMethodVariant0::Squarify)
    }
    pub(super) fn treemap_transform_ratio() -> super::TreemapTransformRatio {
        super::TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
    pub(super) fn voronoi_transform_as() -> super::VoronoiTransformAs {
        super::VoronoiTransformAs::Variant0("path".to_string())
    }
    pub(super) fn voronoi_transform_extent() -> super::VoronoiTransformExtent {
        super::VoronoiTransformExtent::Variant0([
            ::serde_json::from_str::<::serde_json::Value>("[-100000,-100000]").unwrap(),
            ::serde_json::from_str::<::serde_json::Value>("[100000,100000]").unwrap(),
        ])
    }
    pub(super) fn window_transform_frame() -> super::WindowTransformFrame {
        super::WindowTransformFrame::Variant0([
            super::WindowTransformFrameVariant0Item::Variant2,
            super::WindowTransformFrameVariant0Item::Variant0(0_f64),
        ])
    }
    pub(super) fn wordcloud_transform_as() -> super::WordcloudTransformAs {
        super::WordcloudTransformAs::Variant0([
            super::WordcloudTransformAsVariant0Item::Variant0("x".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("y".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("font".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontSize".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontStyle".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontWeight".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("angle".to_string()),
        ])
    }
    pub(super) fn wordcloud_transform_font() -> super::WordcloudTransformFont {
        super::WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
    pub(super) fn wordcloud_transform_font_size() -> super::WordcloudTransformFontSize {
        super::WordcloudTransformFontSize::Variant0(14_f64)
    }
    pub(super) fn wordcloud_transform_font_size_range() -> super::WordcloudTransformFontSizeRange {
        super::WordcloudTransformFontSizeRange::Variant0(vec![
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
    pub(super) fn wordcloud_transform_font_style() -> super::WordcloudTransformFontStyle {
        super::WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
    pub(super) fn wordcloud_transform_font_weight() -> super::WordcloudTransformFontWeight {
        super::WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
