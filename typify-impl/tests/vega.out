#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a TryFrom or FromStr implementation."]
    pub struct ConversionError(std::borrow::Cow<'static, str>);
    impl std::error::Error for ConversionError {}
    impl std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
            std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "AggregateTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cross\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"drop\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"aggregate\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<AggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<AggregateTransformCross>,
    #[serde(default = "defaults::aggregate_transform_drop")]
    pub drop: AggregateTransformDrop,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<AggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<AggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<AggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<AggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: AggregateTransformType,
}
impl From<&Self> for AggregateTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AggregateTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformAs {
    Variant0(Vec<AggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AggregateTransformAsVariant0Item>> for AggregateTransformAs {
    fn from(value: Vec<AggregateTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for AggregateTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for AggregateTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformCross"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformCross {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformCross {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for AggregateTransformCross {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformCross {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformDrop"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformDrop {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformDrop {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for AggregateTransformDrop {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for AggregateTransformDrop {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformDrop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformFields {
    Variant0(Vec<AggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AggregateTransformFieldsVariant0Item>> for AggregateTransformFields {
    fn from(value: Vec<AggregateTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&Self> for AggregateTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for AggregateTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl From<ParamField> for AggregateTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for AggregateTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AggregateTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformGroupby {
    Variant0(Vec<AggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AggregateTransformGroupbyVariant0Item>> for AggregateTransformGroupby {
    fn from(value: Vec<AggregateTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for AggregateTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for AggregateTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for AggregateTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for AggregateTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "AggregateTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for AggregateTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for AggregateTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for AggregateTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for AggregateTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "AggregateTransformOps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformOps {
    Variant0(Vec<AggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformOps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AggregateTransformOpsVariant0Item>> for AggregateTransformOps {
    fn from(value: Vec<AggregateTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformOpsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AggregateTransformOpsVariant0Item {
    Variant0(AggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for AggregateTransformOpsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AggregateTransformOpsVariant0ItemVariant0> for AggregateTransformOpsVariant0Item {
    fn from(value: AggregateTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AggregateTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AggregateTransformOpsVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&Self> for AggregateTransformOpsVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AggregateTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"aggregate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AggregateTransformType {
    #[serde(rename = "aggregate")]
    Aggregate,
}
impl From<&Self> for AggregateTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Aggregate => "aggregate".to_string(),
        }
    }
}
impl std::str::FromStr for AggregateTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "aggregate" => Ok(Self::Aggregate),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AlignValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"left\","]
#[doc = "                              \"right\","]
#[doc = "                              \"center\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"center\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValue {
    Variant0(Vec<AlignValueVariant0Item>),
    Variant1(AlignValueVariant1),
}
impl From<&Self> for AlignValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AlignValueVariant0Item>> for AlignValue {
    fn from(value: Vec<AlignValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValueVariant1> for AlignValue {
    fn from(value: AlignValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AlignValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"center\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: AlignValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: AlignValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for AlignValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AlignValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlignValueVariant0ItemVariant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for AlignValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AlignValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AlignValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AlignValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AlignValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AlignValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AlignValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AlignValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AlignValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"left\","]
#[doc = "                    \"right\","]
#[doc = "                    \"center\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: AlignValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: AlignValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for AlignValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AlignValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AlignValueVariant1Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for AlignValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AlignValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AlignValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AlignValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AlignValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AlignValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AlignValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AlignValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AlignValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AlignValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AlignValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AlignValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AlignValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnchorValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"start\","]
#[doc = "                              \"middle\","]
#[doc = "                              \"end\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValue {
    Variant0(Vec<AnchorValueVariant0Item>),
    Variant1(AnchorValueVariant1),
}
impl From<&Self> for AnchorValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AnchorValueVariant0Item>> for AnchorValue {
    fn from(value: Vec<AnchorValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValueVariant1> for AnchorValue {
    fn from(value: AnchorValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnchorValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: AnchorValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: AnchorValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for AnchorValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AnchorValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AnchorValueVariant0ItemVariant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for AnchorValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AnchorValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AnchorValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AnchorValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnchorValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AnchorValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AnchorValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AnchorValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnchorValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"start\","]
#[doc = "                    \"middle\","]
#[doc = "                    \"end\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: AnchorValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: AnchorValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for AnchorValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AnchorValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AnchorValueVariant1Variant1Value {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for AnchorValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AnchorValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AnchorValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AnchorValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnchorValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AnchorValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnchorValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AnchorValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnchorValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnchorValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AnchorValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AnchorValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AnchorValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnyValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {}"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValue {
    Variant0(Vec<AnyValueVariant0Item>),
    Variant1(AnyValueVariant1),
}
impl From<&Self> for AnyValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<AnyValueVariant0Item>> for AnyValue {
    fn from(value: Vec<AnyValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnyValueVariant1> for AnyValue {
    fn from(value: AnyValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnyValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: AnyValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for AnyValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AnyValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AnyValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnyValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AnyValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnyValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnyValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AnyValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AnyValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AnyValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AnyValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {}"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: serde_json::Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: AnyValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for AnyValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AnyValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AnyValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for AnyValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for AnyValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for AnyValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AnyValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AnyValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for AnyValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for AnyValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for AnyValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ArrayOrSignal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayOrSignal {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&Self> for ArrayOrSignal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ArrayOrSignal {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ArrayOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ArrayValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"array\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"array\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValue {
    Variant0(Vec<ArrayValueVariant0Item>),
    Variant1(ArrayValueVariant1),
}
impl From<&Self> for ArrayValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ArrayValueVariant0Item>> for ArrayValue {
    fn from(value: Vec<ArrayValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValueVariant1> for ArrayValue {
    fn from(value: ArrayValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ArrayValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"array\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: ArrayValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for ArrayValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ArrayValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for ArrayValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ArrayValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for ArrayValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ArrayValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ArrayValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for ArrayValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for ArrayValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for ArrayValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ArrayValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"array\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: Vec<serde_json::Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: ArrayValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for ArrayValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ArrayValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ArrayValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for ArrayValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ArrayValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for ArrayValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ArrayValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ArrayValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for ArrayValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for ArrayValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for ArrayValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Autosize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"pad\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"pad\","]
#[doc = "        \"fit\","]
#[doc = "        \"fit-x\","]
#[doc = "        \"fit-y\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"contains\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"content\","]
#[doc = "            \"padding\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"resize\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"default\": \"pad\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"pad\","]
#[doc = "            \"fit\","]
#[doc = "            \"fit-x\","]
#[doc = "            \"fit-y\","]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Autosize {
    Variant0(AutosizeVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        contains: Option<AutosizeVariant1Contains>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        resize: Option<bool>,
        #[serde(rename = "type")]
        type_: AutosizeVariant1Type,
    },
    Variant2(SignalRef),
}
impl From<&Self> for Autosize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AutosizeVariant0> for Autosize {
    fn from(value: AutosizeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Autosize {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AutosizeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pad\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pad\","]
#[doc = "    \"fit\","]
#[doc = "    \"fit-x\","]
#[doc = "    \"fit-y\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant0 {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for AutosizeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AutosizeVariant1Contains"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"content\","]
#[doc = "    \"padding\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant1Contains {
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "padding")]
    Padding,
}
impl From<&Self> for AutosizeVariant1Contains {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant1Contains {
    fn to_string(&self) -> String {
        match *self {
            Self::Content => "content".to_string(),
            Self::Padding => "padding".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Contains {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "content" => Ok(Self::Content),
            "padding" => Ok(Self::Padding),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant1Contains {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AutosizeVariant1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pad\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"pad\","]
#[doc = "    \"fit\","]
#[doc = "    \"fit-x\","]
#[doc = "    \"fit-y\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AutosizeVariant1Type {
    #[serde(rename = "pad")]
    Pad,
    #[serde(rename = "fit")]
    Fit,
    #[serde(rename = "fit-x")]
    FitX,
    #[serde(rename = "fit-y")]
    FitY,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for AutosizeVariant1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AutosizeVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pad => "pad".to_string(),
            Self::Fit => "fit".to_string(),
            Self::FitX => "fit-x".to_string(),
            Self::FitY => "fit-y".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for AutosizeVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pad" => Ok(Self::Pad),
            "fit" => Ok(Self::Fit),
            "fit-x" => Ok(Self::FitX),
            "fit-y" => Ok(Self::FitY),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AutosizeVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl Default for AutosizeVariant1Type {
    fn default() -> Self {
        Self::Pad
    }
}
#[doc = "Axis"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"orient\","]
#[doc = "    \"scale\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"aria\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"bandPosition\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"domain\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"domainCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"domainWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"axis\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"grid\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"ticks\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"format\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"date\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"day\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"hours\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"milliseconds\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"minutes\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"month\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"quarter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"seconds\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"week\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"year\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"formatType\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"number\","]
#[doc = "            \"time\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"grid\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"gridCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gridScale\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gridWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelAlign\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"left\","]
#[doc = "            \"right\","]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/alignValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelAngle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelBaseline\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"middle\","]
#[doc = "            \"bottom\","]
#[doc = "            \"alphabetic\","]
#[doc = "            \"line-top\","]
#[doc = "            \"line-bottom\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelBound\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFlush\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFlushOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"labelFont\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontStyle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelFontWeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"normal\","]
#[doc = "            \"bold\","]
#[doc = "            \"lighter\","]
#[doc = "            \"bolder\","]
#[doc = "            \"100\","]
#[doc = "            \"200\","]
#[doc = "            \"300\","]
#[doc = "            \"400\","]
#[doc = "            \"500\","]
#[doc = "            \"600\","]
#[doc = "            \"700\","]
#[doc = "            \"800\","]
#[doc = "            \"900\","]
#[doc = "            100,"]
#[doc = "            200,"]
#[doc = "            300,"]
#[doc = "            400,"]
#[doc = "            500,"]
#[doc = "            600,"]
#[doc = "            700,"]
#[doc = "            800,"]
#[doc = "            900"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelLimit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelLineHeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelOverlap\": {"]
#[doc = "      \"$ref\": \"#/definitions/labelOverlap\""]
#[doc = "    },"]
#[doc = "    \"labelPadding\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"labelSeparation\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"maxExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"bottom\","]
#[doc = "            \"left\","]
#[doc = "            \"right\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"position\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tickBand\": {"]
#[doc = "      \"$ref\": \"#/definitions/tickBand\""]
#[doc = "    },"]
#[doc = "    \"tickCap\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickCount\": {"]
#[doc = "      \"$ref\": \"#/definitions/tickCount\""]
#[doc = "    },"]
#[doc = "    \"tickDash\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickDashOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickExtra\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"tickMinStep\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"tickOffset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickRound\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tickWidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ticks\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "    },"]
#[doc = "    \"titleAlign\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"left\","]
#[doc = "            \"right\","]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/alignValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleAnchor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"start\","]
#[doc = "            \"middle\","]
#[doc = "            \"end\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleAngle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleBaseline\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"top\","]
#[doc = "            \"middle\","]
#[doc = "            \"bottom\","]
#[doc = "            \"alphabetic\","]
#[doc = "            \"line-top\","]
#[doc = "            \"line-bottom\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleColor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/colorValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFont\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontStyle\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleFontWeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            null,"]
#[doc = "            \"normal\","]
#[doc = "            \"bold\","]
#[doc = "            \"lighter\","]
#[doc = "            \"bolder\","]
#[doc = "            \"100\","]
#[doc = "            \"200\","]
#[doc = "            \"300\","]
#[doc = "            \"400\","]
#[doc = "            \"500\","]
#[doc = "            \"600\","]
#[doc = "            \"700\","]
#[doc = "            \"800\","]
#[doc = "            \"900\","]
#[doc = "            100,"]
#[doc = "            200,"]
#[doc = "            300,"]
#[doc = "            400,"]
#[doc = "            500,"]
#[doc = "            600,"]
#[doc = "            700,"]
#[doc = "            800,"]
#[doc = "            900"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleLimit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleLineHeight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleOpacity\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titlePadding\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleX\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"titleY\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/arrayOrSignal\""]
#[doc = "    },"]
#[doc = "    \"zindex\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Axis {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(
        rename = "bandPosition",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub band_position: Option<AxisBandPosition>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<bool>,
    #[serde(rename = "domainCap", default, skip_serializing_if = "Option::is_none")]
    pub domain_cap: Option<AxisDomainCap>,
    #[serde(
        rename = "domainColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_color: Option<AxisDomainColor>,
    #[serde(
        rename = "domainDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash: Option<AxisDomainDash>,
    #[serde(
        rename = "domainDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_dash_offset: Option<AxisDomainDashOffset>,
    #[serde(
        rename = "domainOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_opacity: Option<AxisDomainOpacity>,
    #[serde(
        rename = "domainWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub domain_width: Option<AxisDomainWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<AxisEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub format: Option<AxisFormat>,
    #[serde(
        rename = "formatType",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub format_type: Option<AxisFormatType>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<bool>,
    #[serde(rename = "gridCap", default, skip_serializing_if = "Option::is_none")]
    pub grid_cap: Option<AxisGridCap>,
    #[serde(rename = "gridColor", default, skip_serializing_if = "Option::is_none")]
    pub grid_color: Option<AxisGridColor>,
    #[serde(rename = "gridDash", default, skip_serializing_if = "Option::is_none")]
    pub grid_dash: Option<AxisGridDash>,
    #[serde(
        rename = "gridDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_dash_offset: Option<AxisGridDashOffset>,
    #[serde(
        rename = "gridOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub grid_opacity: Option<AxisGridOpacity>,
    #[serde(rename = "gridScale", default, skip_serializing_if = "Option::is_none")]
    pub grid_scale: Option<String>,
    #[serde(rename = "gridWidth", default, skip_serializing_if = "Option::is_none")]
    pub grid_width: Option<AxisGridWidth>,
    #[serde(
        rename = "labelAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_align: Option<AxisLabelAlign>,
    #[serde(
        rename = "labelAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_angle: Option<AxisLabelAngle>,
    #[serde(
        rename = "labelBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_baseline: Option<AxisLabelBaseline>,
    #[serde(
        rename = "labelBound",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_bound: Option<AxisLabelBound>,
    #[serde(
        rename = "labelColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_color: Option<AxisLabelColor>,
    #[serde(
        rename = "labelFlush",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush: Option<AxisLabelFlush>,
    #[serde(
        rename = "labelFlushOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_flush_offset: Option<NumberOrSignal>,
    #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
    pub label_font: Option<AxisLabelFont>,
    #[serde(
        rename = "labelFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_size: Option<AxisLabelFontSize>,
    #[serde(
        rename = "labelFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_style: Option<AxisLabelFontStyle>,
    #[serde(
        rename = "labelFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_font_weight: Option<AxisLabelFontWeight>,
    #[serde(
        rename = "labelLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_limit: Option<AxisLabelLimit>,
    #[serde(
        rename = "labelLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_line_height: Option<AxisLabelLineHeight>,
    #[serde(
        rename = "labelOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_offset: Option<AxisLabelOffset>,
    #[serde(
        rename = "labelOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_opacity: Option<AxisLabelOpacity>,
    #[serde(
        rename = "labelOverlap",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_overlap: Option<LabelOverlap>,
    #[serde(
        rename = "labelPadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_padding: Option<AxisLabelPadding>,
    #[serde(
        rename = "labelSeparation",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub label_separation: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<bool>,
    #[serde(rename = "maxExtent", default, skip_serializing_if = "Option::is_none")]
    pub max_extent: Option<AxisMaxExtent>,
    #[serde(rename = "minExtent", default, skip_serializing_if = "Option::is_none")]
    pub min_extent: Option<AxisMinExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<AxisOffset>,
    pub orient: AxisOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub position: Option<AxisPosition>,
    pub scale: String,
    #[serde(rename = "tickBand", default, skip_serializing_if = "Option::is_none")]
    pub tick_band: Option<TickBand>,
    #[serde(rename = "tickCap", default, skip_serializing_if = "Option::is_none")]
    pub tick_cap: Option<AxisTickCap>,
    #[serde(rename = "tickColor", default, skip_serializing_if = "Option::is_none")]
    pub tick_color: Option<AxisTickColor>,
    #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
    pub tick_count: Option<TickCount>,
    #[serde(rename = "tickDash", default, skip_serializing_if = "Option::is_none")]
    pub tick_dash: Option<AxisTickDash>,
    #[serde(
        rename = "tickDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_dash_offset: Option<AxisTickDashOffset>,
    #[serde(rename = "tickExtra", default, skip_serializing_if = "Option::is_none")]
    pub tick_extra: Option<BooleanOrSignal>,
    #[serde(
        rename = "tickMinStep",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_min_step: Option<NumberOrSignal>,
    #[serde(
        rename = "tickOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_offset: Option<AxisTickOffset>,
    #[serde(
        rename = "tickOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub tick_opacity: Option<AxisTickOpacity>,
    #[serde(rename = "tickRound", default, skip_serializing_if = "Option::is_none")]
    pub tick_round: Option<AxisTickRound>,
    #[serde(rename = "tickSize", default, skip_serializing_if = "Option::is_none")]
    pub tick_size: Option<AxisTickSize>,
    #[serde(rename = "tickWidth", default, skip_serializing_if = "Option::is_none")]
    pub tick_width: Option<AxisTickWidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<TextOrSignal>,
    #[serde(
        rename = "titleAlign",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_align: Option<AxisTitleAlign>,
    #[serde(
        rename = "titleAnchor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_anchor: Option<AxisTitleAnchor>,
    #[serde(
        rename = "titleAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_angle: Option<AxisTitleAngle>,
    #[serde(
        rename = "titleBaseline",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_baseline: Option<AxisTitleBaseline>,
    #[serde(
        rename = "titleColor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_color: Option<AxisTitleColor>,
    #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
    pub title_font: Option<AxisTitleFont>,
    #[serde(
        rename = "titleFontSize",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_size: Option<AxisTitleFontSize>,
    #[serde(
        rename = "titleFontStyle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_style: Option<AxisTitleFontStyle>,
    #[serde(
        rename = "titleFontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_font_weight: Option<AxisTitleFontWeight>,
    #[serde(
        rename = "titleLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_limit: Option<AxisTitleLimit>,
    #[serde(
        rename = "titleLineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_line_height: Option<AxisTitleLineHeight>,
    #[serde(
        rename = "titleOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_opacity: Option<AxisTitleOpacity>,
    #[serde(
        rename = "titlePadding",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub title_padding: Option<AxisTitlePadding>,
    #[serde(rename = "titleX", default, skip_serializing_if = "Option::is_none")]
    pub title_x: Option<AxisTitleX>,
    #[serde(rename = "titleY", default, skip_serializing_if = "Option::is_none")]
    pub title_y: Option<AxisTitleY>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<AxisTranslate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ArrayOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<f64>,
}
impl From<&Self> for Axis {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AxisBandPosition"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisBandPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisBandPosition {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisBandPosition {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisBandPosition {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisDomainCap"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisDomainCap {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisDomainCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisDomainColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for AxisDomainColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for AxisDomainColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisDomainDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for AxisDomainDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for AxisDomainDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for AxisDomainDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisDomainDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisDomainDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisDomainDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisDomainDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisDomainOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisDomainOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisDomainOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisDomainOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisDomainWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisDomainWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisDomainWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisDomainWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisDomainWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisEncode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"axis\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"domain\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"grid\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"ticks\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct AxisEncode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub axis: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub domain: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub grid: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ticks: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for AxisEncode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "AxisFormat"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum AxisFormat {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for AxisFormat {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for AxisFormat {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisFormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisFormatType {
    Variant0(AxisFormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for AxisFormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisFormatTypeVariant0> for AxisFormatType {
    fn from(value: AxisFormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AxisFormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisFormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisFormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for AxisFormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisFormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for AxisFormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisFormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisGridCap"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisGridCap {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisGridCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisGridColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for AxisGridColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for AxisGridColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisGridDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for AxisGridDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for AxisGridDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for AxisGridDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisGridDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisGridDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisGridDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisGridDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisGridOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisGridOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisGridOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisGridOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisGridWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisGridWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisGridWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisGridWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisGridWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelAlign {
    Variant0(AxisLabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for AxisLabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisLabelAlignVariant0> for AxisLabelAlign {
    fn from(value: AxisLabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for AxisLabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisLabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for AxisLabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisLabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisLabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisLabelAngle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelAngle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelAngle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelBaseline {
    Variant0(AxisLabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for AxisLabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisLabelBaselineVariant0> for AxisLabelBaseline {
    fn from(value: AxisLabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for AxisLabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisLabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for AxisLabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisLabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisLabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisLabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisLabelBound"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelBound {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for AxisLabelBound {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for AxisLabelBound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for AxisLabelBound {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for AxisLabelBound {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisLabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for AxisLabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for AxisLabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisLabelFlush"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFlush {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for AxisLabelFlush {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for AxisLabelFlush {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for AxisLabelFlush {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for AxisLabelFlush {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisLabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisLabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisLabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisLabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisLabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for AxisLabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for AxisLabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for AxisLabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisLabelPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisLabelPadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisLabelPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisLabelPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisLabelPadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisMaxExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisMaxExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisMaxExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisMaxExtent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisMaxExtent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisMinExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisMinExtent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisMinExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisMinExtent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisMinExtent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"left\","]
#[doc = "        \"right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisOrient {
    Variant0(AxisOrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for AxisOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisOrientVariant0> for AxisOrient {
    fn from(value: AxisOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for AxisOrient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"left\","]
#[doc = "    \"right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisOrientVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
}
impl From<&Self> for AxisOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
        }
    }
}
impl std::str::FromStr for AxisOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisPosition"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisPosition {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisPosition {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisPosition {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisPosition {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickCap"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickCap {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisTickCap {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisTickCap {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for AxisTickColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for AxisTickColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisTickDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for AxisTickDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for AxisTickDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for AxisTickDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTickDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTickDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTickDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTickOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTickOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTickOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTickOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTickOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTickOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickRound"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickRound {
    Variant0(bool),
    Variant1(BooleanValue),
}
impl From<&Self> for AxisTickRound {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for AxisTickRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<BooleanValue> for AxisTickRound {
    fn from(value: BooleanValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTickSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTickSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTickSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTickWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTickWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTickWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTickWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTickWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAlign {
    Variant0(AxisTitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for AxisTitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisTitleAlignVariant0> for AxisTitleAlign {
    fn from(value: AxisTitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for AxisTitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for AxisTitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisTitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAnchor {
    Variant0(Option<AxisTitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for AxisTitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<AxisTitleAnchorVariant0>> for AxisTitleAnchor {
    fn from(value: Option<AxisTitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for AxisTitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for AxisTitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisTitleAngle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleAngle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleAngle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleAngle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleBaseline {
    Variant0(AxisTitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for AxisTitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<AxisTitleBaselineVariant0> for AxisTitleBaseline {
    fn from(value: AxisTitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for AxisTitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum AxisTitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for AxisTitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for AxisTitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for AxisTitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for AxisTitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "AxisTitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for AxisTitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for AxisTitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "AxisTitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisTitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisTitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for AxisTitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for AxisTitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for AxisTitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for AxisTitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for AxisTitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTitleY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTitleY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTitleY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTitleY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTitleY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "AxisTranslate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum AxisTranslate {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for AxisTranslate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for AxisTranslate {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for AxisTranslate {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Background"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Background(pub StringOrSignal);
impl std::ops::Deref for Background {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl From<Background> for StringOrSignal {
    fn from(value: Background) -> Self {
        value.0
    }
}
impl From<&Self> for Background {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringOrSignal> for Background {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[doc = "BaseColorValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"null\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/linearGradient\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {"]
#[doc = "          \"$ref\": \"#/definitions/radialGradient\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"gradient\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"gradient\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"start\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        \"stop\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"color\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"color\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum BaseColorValue {
    Variant0(BaseColorValueVariant0),
    Variant1 {
        value: LinearGradient,
    },
    Variant2 {
        value: RadialGradient,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<f64>,
        gradient: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start: Option<[f64; 2usize]>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        stop: Option<[f64; 2usize]>,
    },
    Variant4 {
        color: BaseColorValueVariant4Color,
    },
}
impl From<&Self> for BaseColorValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<BaseColorValueVariant0> for BaseColorValue {
    fn from(value: BaseColorValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "BaseColorValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"null\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: Option<String>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: BaseColorValueVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for BaseColorValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BaseColorValueVariant0Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BaseColorValueVariant0Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaseColorValueVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BaseColorValueVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaseColorValueVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaseColorValueVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BaseColorValueVariant0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BaseColorValueVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BaseColorValueVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BaseColorValueVariant4Color"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaseColorValueVariant4Color {
    Rgb(ColorRgb),
    Hsl(ColorHsl),
    Lab(ColorLab),
    Hcl(ColorHcl),
}
impl From<&Self> for BaseColorValueVariant4Color {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorRgb> for BaseColorValueVariant4Color {
    fn from(value: ColorRgb) -> Self {
        Self::Rgb(value)
    }
}
impl From<ColorHsl> for BaseColorValueVariant4Color {
    fn from(value: ColorHsl) -> Self {
        Self::Hsl(value)
    }
}
impl From<ColorLab> for BaseColorValueVariant4Color {
    fn from(value: ColorLab) -> Self {
        Self::Lab(value)
    }
}
impl From<ColorHcl> for BaseColorValueVariant4Color {
    fn from(value: ColorHcl) -> Self {
        Self::Hcl(value)
    }
}
#[doc = "BaselineValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"top\","]
#[doc = "                              \"middle\","]
#[doc = "                              \"bottom\","]
#[doc = "                              \"alphabetic\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"top\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"bottom\","]
#[doc = "                        \"alphabetic\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValue {
    Variant0(Vec<BaselineValueVariant0Item>),
    Variant1(BaselineValueVariant1),
}
impl From<&Self> for BaselineValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<BaselineValueVariant0Item>> for BaselineValue {
    fn from(value: Vec<BaselineValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValueVariant1> for BaselineValue {
    fn from(value: BaselineValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BaselineValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"top\","]
#[doc = "                        \"middle\","]
#[doc = "                        \"bottom\","]
#[doc = "                        \"alphabetic\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: BaselineValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: BaselineValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for BaselineValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BaselineValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BaselineValueVariant0ItemVariant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl From<&Self> for BaselineValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BaselineValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BaselineValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BaselineValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaselineValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BaselineValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BaselineValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BaselineValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BaselineValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"top\","]
#[doc = "                    \"middle\","]
#[doc = "                    \"bottom\","]
#[doc = "                    \"alphabetic\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: BaselineValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: BaselineValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for BaselineValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BaselineValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BaselineValueVariant1Variant1Value {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
}
impl From<&Self> for BaselineValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BaselineValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
        }
    }
}
impl std::str::FromStr for BaselineValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BaselineValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BaselineValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BaselineValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BaselineValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BaselineValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BaselineValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BaselineValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BaselineValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BaselineValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BaselineValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extent\","]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"anchor\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"bin0\","]
#[doc = "        \"bin1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"default\": 10,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"divide\": {"]
#[doc = "      \"default\": ["]
#[doc = "        5,"]
#[doc = "        2"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"interval\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxbins\": {"]
#[doc = "      \"default\": 20,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minstep\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"span\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"bin\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct BinTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub anchor: Option<BinTransformAnchor>,
    #[serde(rename = "as", default = "defaults::bin_transform_as")]
    pub as_: BinTransformAs,
    #[serde(default = "defaults::bin_transform_base")]
    pub base: BinTransformBase,
    #[serde(default = "defaults::bin_transform_divide")]
    pub divide: BinTransformDivide,
    pub extent: BinTransformExtent,
    pub field: BinTransformField,
    #[serde(default = "defaults::bin_transform_interval")]
    pub interval: BinTransformInterval,
    #[serde(default = "defaults::bin_transform_maxbins")]
    pub maxbins: BinTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub minstep: Option<BinTransformMinstep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<BinTransformName>,
    #[serde(default = "defaults::bin_transform_nice")]
    pub nice: BinTransformNice,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub span: Option<BinTransformSpan>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<BinTransformStep>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<BinTransformSteps>,
    #[serde(rename = "type")]
    pub type_: BinTransformType,
}
impl From<&Self> for BinTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BinTransformAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAnchor {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformAnchor {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"bin0\","]
#[doc = "    \"bin1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAs {
    Variant0([BinTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformAs {
    fn default() -> Self {
        Self::Variant0([
            BinTransformAsVariant0Item::Variant0("bin0".to_string()),
            BinTransformAsVariant0Item::Variant0("bin1".to_string()),
        ])
    }
}
impl From<[BinTransformAsVariant0Item; 2usize]> for BinTransformAs {
    fn from(value: [BinTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for BinTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformBase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 10,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformBase {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformBase {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformBase {
    fn default() -> Self {
        Self::Variant0(10_f64)
    }
}
impl From<f64> for BinTransformBase {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformBase {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformDivide"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    5,"]
#[doc = "    2"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformDivide {
    Variant0(Vec<BinTransformDivideVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformDivide {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformDivide {
    fn default() -> Self {
        Self::Variant0(vec![
            BinTransformDivideVariant0Item::Variant0(5_f64),
            BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
}
impl From<Vec<BinTransformDivideVariant0Item>> for BinTransformDivide {
    fn from(value: Vec<BinTransformDivideVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformDivide {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformDivideVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformDivideVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformDivideVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformDivideVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformDivideVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformExtent {
    Variant0([BinTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[BinTransformExtentVariant0Item; 2usize]> for BinTransformExtent {
    fn from(value: [BinTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for BinTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for BinTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for BinTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for BinTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "BinTransformInterval"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformInterval {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformInterval {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for BinTransformInterval {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformInterval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformMaxbins"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 20,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformMaxbins {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformMaxbins {
    fn default() -> Self {
        Self::Variant0(20_f64)
    }
}
impl From<f64> for BinTransformMaxbins {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformMaxbins {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformMinstep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformMinstep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformMinstep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformMinstep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformMinstep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformName {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformName {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for BinTransformName {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformNice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformNice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for BinTransformNice {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for BinTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformSpan"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformSpan {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformSpan {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformSpan {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformSpan {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformSteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformSteps {
    Variant0(Vec<BinTransformStepsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformSteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<BinTransformStepsVariant0Item>> for BinTransformSteps {
    fn from(value: Vec<BinTransformStepsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformStepsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BinTransformStepsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for BinTransformStepsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for BinTransformStepsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BinTransformStepsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BinTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"bin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BinTransformType {
    #[serde(rename = "bin")]
    Bin,
}
impl From<&Self> for BinTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Bin => "bin".to_string(),
        }
    }
}
impl std::str::FromStr for BinTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "bin" => Ok(Self::Bin),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Bind"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"checkbox\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\","]
#[doc = "        \"options\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"radio\","]
#[doc = "            \"select\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labels\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"options\": {"]
#[doc = "          \"type\": \"array\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"range\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"max\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"min\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"input\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"input\": {"]
#[doc = "          \"not\": {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"checkbox\","]
#[doc = "              \"radio\","]
#[doc = "              \"range\","]
#[doc = "              \"select\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"element\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"element\": {"]
#[doc = "          \"$ref\": \"#/definitions/element\""]
#[doc = "        },"]
#[doc = "        \"event\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Bind {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant0Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant1Input,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        labels: Vec<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        options: Vec<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant2Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        max: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        element: Option<Element>,
        input: BindVariant3Input,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        element: Element,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        event: Option<String>,
    },
}
impl From<&Self> for Bind {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BindVariant0Input"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"checkbox\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant0Input {
    #[serde(rename = "checkbox")]
    Checkbox,
}
impl From<&Self> for BindVariant0Input {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant0Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Checkbox => "checkbox".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant0Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "checkbox" => Ok(Self::Checkbox),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant0Input {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BindVariant1Input"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"radio\","]
#[doc = "    \"select\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant1Input {
    #[serde(rename = "radio")]
    Radio,
    #[serde(rename = "select")]
    Select,
}
impl From<&Self> for BindVariant1Input {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant1Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Radio => "radio".to_string(),
            Self::Select => "select".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant1Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "radio" => Ok(Self::Radio),
            "select" => Ok(Self::Select),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant1Input {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BindVariant2Input"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"range\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BindVariant2Input {
    #[serde(rename = "range")]
    Range,
}
impl From<&Self> for BindVariant2Input {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BindVariant2Input {
    fn to_string(&self) -> String {
        match *self {
            Self::Range => "range".to_string(),
        }
    }
}
impl std::str::FromStr for BindVariant2Input {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "range" => Ok(Self::Range),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BindVariant2Input {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BindVariant3Input"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"not\": {"]
#[doc = "    \"enum\": ["]
#[doc = "      \"checkbox\","]
#[doc = "      \"radio\","]
#[doc = "      \"range\","]
#[doc = "      \"select\""]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct BindVariant3Input(String);
impl std::ops::Deref for BindVariant3Input {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<BindVariant3Input> for String {
    fn from(value: BindVariant3Input) -> Self {
        value.0
    }
}
impl From<&Self> for BindVariant3Input {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<String> for BindVariant3Input {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        if [
            "checkbox".to_string(),
            "radio".to_string(),
            "range".to_string(),
            "select".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for BindVariant3Input {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(<String>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "BlendValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              null,"]
#[doc = "                              \"multiply\","]
#[doc = "                              \"screen\","]
#[doc = "                              \"overlay\","]
#[doc = "                              \"darken\","]
#[doc = "                              \"lighten\","]
#[doc = "                              \"color-dodge\","]
#[doc = "                              \"color-burn\","]
#[doc = "                              \"hard-light\","]
#[doc = "                              \"soft-light\","]
#[doc = "                              \"difference\","]
#[doc = "                              \"exclusion\","]
#[doc = "                              \"hue\","]
#[doc = "                              \"saturation\","]
#[doc = "                              \"color\","]
#[doc = "                              \"luminosity\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"multiply\","]
#[doc = "                        \"screen\","]
#[doc = "                        \"overlay\","]
#[doc = "                        \"darken\","]
#[doc = "                        \"lighten\","]
#[doc = "                        \"color-dodge\","]
#[doc = "                        \"color-burn\","]
#[doc = "                        \"hard-light\","]
#[doc = "                        \"soft-light\","]
#[doc = "                        \"difference\","]
#[doc = "                        \"exclusion\","]
#[doc = "                        \"hue\","]
#[doc = "                        \"saturation\","]
#[doc = "                        \"color\","]
#[doc = "                        \"luminosity\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValue {
    Variant0(Vec<BlendValueVariant0Item>),
    Variant1(BlendValueVariant1),
}
impl From<&Self> for BlendValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<BlendValueVariant0Item>> for BlendValue {
    fn from(value: Vec<BlendValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<BlendValueVariant1> for BlendValue {
    fn from(value: BlendValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BlendValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"multiply\","]
#[doc = "                        \"screen\","]
#[doc = "                        \"overlay\","]
#[doc = "                        \"darken\","]
#[doc = "                        \"lighten\","]
#[doc = "                        \"color-dodge\","]
#[doc = "                        \"color-burn\","]
#[doc = "                        \"hard-light\","]
#[doc = "                        \"soft-light\","]
#[doc = "                        \"difference\","]
#[doc = "                        \"exclusion\","]
#[doc = "                        \"hue\","]
#[doc = "                        \"saturation\","]
#[doc = "                        \"color\","]
#[doc = "                        \"luminosity\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: Option<BlendValueVariant0ItemVariant1Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: BlendValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for BlendValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BlendValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"multiply\","]
#[doc = "    \"screen\","]
#[doc = "    \"overlay\","]
#[doc = "    \"darken\","]
#[doc = "    \"lighten\","]
#[doc = "    \"color-dodge\","]
#[doc = "    \"color-burn\","]
#[doc = "    \"hard-light\","]
#[doc = "    \"soft-light\","]
#[doc = "    \"difference\","]
#[doc = "    \"exclusion\","]
#[doc = "    \"hue\","]
#[doc = "    \"saturation\","]
#[doc = "    \"color\","]
#[doc = "    \"luminosity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BlendValueVariant0ItemVariant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl From<&Self> for BlendValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BlendValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlendValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BlendValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BlendValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BlendValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BlendValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BlendValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BlendValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    null,"]
#[doc = "                    \"multiply\","]
#[doc = "                    \"screen\","]
#[doc = "                    \"overlay\","]
#[doc = "                    \"darken\","]
#[doc = "                    \"lighten\","]
#[doc = "                    \"color-dodge\","]
#[doc = "                    \"color-burn\","]
#[doc = "                    \"hard-light\","]
#[doc = "                    \"soft-light\","]
#[doc = "                    \"difference\","]
#[doc = "                    \"exclusion\","]
#[doc = "                    \"hue\","]
#[doc = "                    \"saturation\","]
#[doc = "                    \"color\","]
#[doc = "                    \"luminosity\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: Option<BlendValueVariant1Variant1Value>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: BlendValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for BlendValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BlendValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"multiply\","]
#[doc = "    \"screen\","]
#[doc = "    \"overlay\","]
#[doc = "    \"darken\","]
#[doc = "    \"lighten\","]
#[doc = "    \"color-dodge\","]
#[doc = "    \"color-burn\","]
#[doc = "    \"hard-light\","]
#[doc = "    \"soft-light\","]
#[doc = "    \"difference\","]
#[doc = "    \"exclusion\","]
#[doc = "    \"hue\","]
#[doc = "    \"saturation\","]
#[doc = "    \"color\","]
#[doc = "    \"luminosity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum BlendValueVariant1Variant1Value {
    #[serde(rename = "multiply")]
    Multiply,
    #[serde(rename = "screen")]
    Screen,
    #[serde(rename = "overlay")]
    Overlay,
    #[serde(rename = "darken")]
    Darken,
    #[serde(rename = "lighten")]
    Lighten,
    #[serde(rename = "color-dodge")]
    ColorDodge,
    #[serde(rename = "color-burn")]
    ColorBurn,
    #[serde(rename = "hard-light")]
    HardLight,
    #[serde(rename = "soft-light")]
    SoftLight,
    #[serde(rename = "difference")]
    Difference,
    #[serde(rename = "exclusion")]
    Exclusion,
    #[serde(rename = "hue")]
    Hue,
    #[serde(rename = "saturation")]
    Saturation,
    #[serde(rename = "color")]
    Color,
    #[serde(rename = "luminosity")]
    Luminosity,
}
impl From<&Self> for BlendValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for BlendValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Multiply => "multiply".to_string(),
            Self::Screen => "screen".to_string(),
            Self::Overlay => "overlay".to_string(),
            Self::Darken => "darken".to_string(),
            Self::Lighten => "lighten".to_string(),
            Self::ColorDodge => "color-dodge".to_string(),
            Self::ColorBurn => "color-burn".to_string(),
            Self::HardLight => "hard-light".to_string(),
            Self::SoftLight => "soft-light".to_string(),
            Self::Difference => "difference".to_string(),
            Self::Exclusion => "exclusion".to_string(),
            Self::Hue => "hue".to_string(),
            Self::Saturation => "saturation".to_string(),
            Self::Color => "color".to_string(),
            Self::Luminosity => "luminosity".to_string(),
        }
    }
}
impl std::str::FromStr for BlendValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "multiply" => Ok(Self::Multiply),
            "screen" => Ok(Self::Screen),
            "overlay" => Ok(Self::Overlay),
            "darken" => Ok(Self::Darken),
            "lighten" => Ok(Self::Lighten),
            "color-dodge" => Ok(Self::ColorDodge),
            "color-burn" => Ok(Self::ColorBurn),
            "hard-light" => Ok(Self::HardLight),
            "soft-light" => Ok(Self::SoftLight),
            "difference" => Ok(Self::Difference),
            "exclusion" => Ok(Self::Exclusion),
            "hue" => Ok(Self::Hue),
            "saturation" => Ok(Self::Saturation),
            "color" => Ok(Self::Color),
            "luminosity" => Ok(Self::Luminosity),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "BlendValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BlendValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BlendValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BlendValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BlendValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BlendValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BlendValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BlendValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BlendValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BlendValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BooleanOrSignal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanOrSignal {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for BooleanOrSignal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for BooleanOrSignal {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for BooleanOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BooleanValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"boolean\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValue {
    Variant0(Vec<BooleanValueVariant0Item>),
    Variant1(BooleanValueVariant1),
}
impl From<&Self> for BooleanValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<BooleanValueVariant0Item>> for BooleanValue {
    fn from(value: Vec<BooleanValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<BooleanValueVariant1> for BooleanValue {
    fn from(value: BooleanValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BooleanValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: bool,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: BooleanValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for BooleanValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BooleanValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BooleanValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BooleanValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BooleanValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BooleanValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BooleanValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BooleanValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BooleanValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BooleanValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "BooleanValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: bool,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: BooleanValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for BooleanValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "BooleanValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum BooleanValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for BooleanValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for BooleanValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for BooleanValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for BooleanValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for BooleanValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for BooleanValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for BooleanValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for BooleanValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CollectTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"collect\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CollectTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: CollectTransformType,
}
impl From<&Self> for CollectTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "CollectTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"collect\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CollectTransformType {
    #[serde(rename = "collect")]
    Collect,
}
impl From<&Self> for CollectTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for CollectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Collect => "collect".to_string(),
        }
    }
}
impl std::str::FromStr for CollectTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "collect" => Ok(Self::Collect),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CollectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ColorHcl"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"c\","]
#[doc = "    \"h\","]
#[doc = "    \"l\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"c\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"h\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorHcl {
    pub c: NumberValue,
    pub h: NumberValue,
    pub l: NumberValue,
}
impl From<&Self> for ColorHcl {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ColorHsl"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"h\","]
#[doc = "    \"l\","]
#[doc = "    \"s\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"h\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"s\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorHsl {
    pub h: NumberValue,
    pub l: NumberValue,
    pub s: NumberValue,
}
impl From<&Self> for ColorHsl {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ColorLab"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"a\","]
#[doc = "    \"b\","]
#[doc = "    \"l\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"a\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"b\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"l\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorLab {
    pub a: NumberValue,
    pub b: NumberValue,
    pub l: NumberValue,
}
impl From<&Self> for ColorLab {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ColorRgb"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"b\","]
#[doc = "    \"g\","]
#[doc = "    \"r\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"b\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"g\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"r\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ColorRgb {
    pub b: NumberValue,
    pub g: NumberValue,
    pub r: NumberValue,
}
impl From<&Self> for ColorRgb {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ColorValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/baseColorValue\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baseColorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ColorValue {
    Variant0(Vec<ColorValueVariant0Item>),
    Variant1(BaseColorValue),
}
impl From<&Self> for ColorValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ColorValueVariant0Item>> for ColorValue {
    fn from(value: Vec<ColorValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaseColorValue> for ColorValue {
    fn from(value: BaseColorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ColorValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baseColorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ColorValueVariant0Item {
    Variant0(ColorValueVariant0ItemVariant0),
    Variant1 {
        value: LinearGradient,
    },
    Variant2 {
        value: RadialGradient,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<f64>,
        gradient: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start: Option<[f64; 2usize]>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        stop: Option<[f64; 2usize]>,
    },
    Variant4 {
        color: ColorValueVariant0ItemVariant4Color,
    },
}
impl From<&Self> for ColorValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValueVariant0ItemVariant0> for ColorValueVariant0Item {
    fn from(value: ColorValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ColorValueVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"null\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"value\": {"]
#[doc = "            \"$ref\": \"#/definitions/linearGradient\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"value\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"value\": {"]
#[doc = "            \"$ref\": \"#/definitions/radialGradient\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"gradient\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"count\": {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          \"gradient\": {"]
#[doc = "            \"$ref\": \"#/definitions/field\""]
#[doc = "          },"]
#[doc = "          \"start\": {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          },"]
#[doc = "          \"stop\": {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"color\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"color\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"additionalProperties\": false"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ColorValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: Option<String>,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: ColorValueVariant0ItemVariant0Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for ColorValueVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ColorValueVariant0ItemVariant0Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ColorValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for ColorValueVariant0ItemVariant0Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ColorValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for ColorValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ColorValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ColorValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for ColorValueVariant0ItemVariant0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for ColorValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for ColorValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ColorValueVariant0ItemVariant4Color"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorRGB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHSL\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorLAB\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorHCL\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ColorValueVariant0ItemVariant4Color {
    Rgb(ColorRgb),
    Hsl(ColorHsl),
    Lab(ColorLab),
    Hcl(ColorHcl),
}
impl From<&Self> for ColorValueVariant0ItemVariant4Color {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorRgb> for ColorValueVariant0ItemVariant4Color {
    fn from(value: ColorRgb) -> Self {
        Self::Rgb(value)
    }
}
impl From<ColorHsl> for ColorValueVariant0ItemVariant4Color {
    fn from(value: ColorHsl) -> Self {
        Self::Hsl(value)
    }
}
impl From<ColorLab> for ColorValueVariant0ItemVariant4Color {
    fn from(value: ColorLab) -> Self {
        Self::Lab(value)
    }
}
impl From<ColorHcl> for ColorValueVariant0ItemVariant4Color {
    fn from(value: ColorHcl) -> Self {
        Self::Hcl(value)
    }
}
#[doc = "Compare"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Compare {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<CompareVariant0Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        field: Vec<CompareVariant1FieldItem>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        order: Vec<SortOrder>,
    },
}
impl From<&Self> for Compare {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "CompareVariant0Field"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CompareVariant0Field {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl From<&Self> for CompareVariant0Field {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for CompareVariant0Field {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<Expr> for CompareVariant0Field {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "CompareVariant1FieldItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CompareVariant1FieldItem {
    ScaleField(ScaleField),
    Expr(Expr),
}
impl From<&Self> for CompareVariant1FieldItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for CompareVariant1FieldItem {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<Expr> for CompareVariant1FieldItem {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ContourTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cellSize\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"count\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"thresholds\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"contour\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"weight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ContourTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<ContourTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<ContourTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub count: Option<ContourTransformCount>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<ContourTransformNice>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: ContourTransformSize,
    #[serde(default = "defaults::contour_transform_smooth")]
    pub smooth: ContourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<ContourTransformThresholds>,
    #[serde(rename = "type")]
    pub type_: ContourTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ContourTransformValues>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<ContourTransformWeight>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<ContourTransformX>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<ContourTransformY>,
}
impl From<&Self> for ContourTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ContourTransformBandwidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformBandwidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformCellSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformCellSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformCellSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformCellSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformCount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformCount {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformCount {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformCount {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformCount {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformNice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformNice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ContourTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSize {
    Variant0([ContourTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[ContourTransformSizeVariant0Item; 2usize]> for ContourTransformSize {
    fn from(value: [ContourTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformSmooth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformSmooth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ContourTransformSmooth {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for ContourTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformThresholds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformThresholds {
    Variant0(Vec<ContourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformThresholds {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ContourTransformThresholdsVariant0Item>> for ContourTransformThresholds {
    fn from(value: Vec<ContourTransformThresholdsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformThresholds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformThresholdsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformThresholdsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformThresholdsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformThresholdsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"contour\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ContourTransformType {
    #[serde(rename = "contour")]
    Contour,
}
impl From<&Self> for ContourTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ContourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Contour => "contour".to_string(),
        }
    }
}
impl std::str::FromStr for ContourTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "contour" => Ok(Self::Contour),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ContourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ContourTransformValues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformValues {
    Variant0(Vec<ContourTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformValues {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ContourTransformValuesVariant0Item>> for ContourTransformValues {
    fn from(value: Vec<ContourTransformValuesVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformValues {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformValuesVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformValuesVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ContourTransformValuesVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ContourTransformValuesVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ContourTransformValuesVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ContourTransformWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ContourTransformWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ContourTransformWeight {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ContourTransformWeight {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ContourTransformWeight {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ContourTransformX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ContourTransformX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ContourTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ContourTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ContourTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ContourTransformY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ContourTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ContourTransformY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ContourTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ContourTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ContourTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "CountpatternTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"text\","]
#[doc = "        \"count\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"case\": {"]
#[doc = "      \"default\": \"mixed\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"upper\","]
#[doc = "            \"lower\","]
#[doc = "            \"mixed\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pattern\": {"]
#[doc = "      \"default\": \"[\\\\w\\\"]+\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stopwords\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"countpattern\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CountpatternTransform {
    #[serde(rename = "as", default = "defaults::countpattern_transform_as")]
    pub as_: CountpatternTransformAs,
    #[serde(default = "defaults::countpattern_transform_case")]
    pub case: CountpatternTransformCase,
    pub field: CountpatternTransformField,
    #[serde(default = "defaults::countpattern_transform_pattern")]
    pub pattern: CountpatternTransformPattern,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stopwords: Option<CountpatternTransformStopwords>,
    #[serde(rename = "type")]
    pub type_: CountpatternTransformType,
}
impl From<&Self> for CountpatternTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "CountpatternTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"text\","]
#[doc = "    \"count\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformAs {
    Variant0([CountpatternTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for CountpatternTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformAs {
    fn default() -> Self {
        Self::Variant0([
            CountpatternTransformAsVariant0Item::Variant0("text".to_string()),
            CountpatternTransformAsVariant0Item::Variant0("count".to_string()),
        ])
    }
}
impl From<[CountpatternTransformAsVariant0Item; 2usize]> for CountpatternTransformAs {
    fn from(value: [CountpatternTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for CountpatternTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CountpatternTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for CountpatternTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for CountpatternTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CountpatternTransformCase"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"mixed\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"upper\","]
#[doc = "        \"lower\","]
#[doc = "        \"mixed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformCase {
    Variant0(CountpatternTransformCaseVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for CountpatternTransformCase {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformCase {
    fn default() -> Self {
        Self::Variant0(CountpatternTransformCaseVariant0::Mixed)
    }
}
impl From<CountpatternTransformCaseVariant0> for CountpatternTransformCase {
    fn from(value: CountpatternTransformCaseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for CountpatternTransformCase {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CountpatternTransformCaseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"upper\","]
#[doc = "    \"lower\","]
#[doc = "    \"mixed\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CountpatternTransformCaseVariant0 {
    #[serde(rename = "upper")]
    Upper,
    #[serde(rename = "lower")]
    Lower,
    #[serde(rename = "mixed")]
    Mixed,
}
impl From<&Self> for CountpatternTransformCaseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for CountpatternTransformCaseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Upper => "upper".to_string(),
            Self::Lower => "lower".to_string(),
            Self::Mixed => "mixed".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformCaseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "upper" => Ok(Self::Upper),
            "lower" => Ok(Self::Lower),
            "mixed" => Ok(Self::Mixed),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CountpatternTransformCaseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "CountpatternTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for CountpatternTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for CountpatternTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for CountpatternTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for CountpatternTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "CountpatternTransformPattern"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"[\\\\w\\\"]+\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformPattern {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for CountpatternTransformPattern {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for CountpatternTransformPattern {
    fn default() -> Self {
        Self::Variant0("[\\w\"]+".to_string())
    }
}
impl From<SignalRef> for CountpatternTransformPattern {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CountpatternTransformStopwords"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CountpatternTransformStopwords {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for CountpatternTransformStopwords {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for CountpatternTransformStopwords {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CountpatternTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"countpattern\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CountpatternTransformType {
    #[serde(rename = "countpattern")]
    Countpattern,
}
impl From<&Self> for CountpatternTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for CountpatternTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Countpattern => "countpattern".to_string(),
        }
    }
}
impl std::str::FromStr for CountpatternTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "countpattern" => Ok(Self::Countpattern),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CountpatternTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "CrossTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"a\","]
#[doc = "        \"b\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"filter\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"cross\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossTransform {
    #[serde(rename = "as", default = "defaults::cross_transform_as")]
    pub as_: CrossTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub filter: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossTransformType,
}
impl From<&Self> for CrossTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "CrossTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"a\","]
#[doc = "    \"b\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossTransformAs {
    Variant0([CrossTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for CrossTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for CrossTransformAs {
    fn default() -> Self {
        Self::Variant0([
            CrossTransformAsVariant0Item::Variant0("a".to_string()),
            CrossTransformAsVariant0Item::Variant0("b".to_string()),
        ])
    }
}
impl From<[CrossTransformAsVariant0Item; 2usize]> for CrossTransformAs {
    fn from(value: [CrossTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for CrossTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CrossTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for CrossTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for CrossTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CrossTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"cross\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CrossTransformType {
    #[serde(rename = "cross")]
    Cross,
}
impl From<&Self> for CrossTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for CrossTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Cross => "cross".to_string(),
        }
    }
}
impl std::str::FromStr for CrossTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "cross" => Ok(Self::Cross),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CrossTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "CrossfilterTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"query\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"query\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"crossfilter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct CrossfilterTransform {
    pub fields: CrossfilterTransformFields,
    pub query: CrossfilterTransformQuery,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: CrossfilterTransformType,
}
impl From<&Self> for CrossfilterTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "CrossfilterTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformFields {
    Variant0(Vec<CrossfilterTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for CrossfilterTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<CrossfilterTransformFieldsVariant0Item>> for CrossfilterTransformFields {
    fn from(value: Vec<CrossfilterTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for CrossfilterTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CrossfilterTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for CrossfilterTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "CrossfilterTransformQuery"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum CrossfilterTransformQuery {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&Self> for CrossfilterTransformQuery {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for CrossfilterTransformQuery {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for CrossfilterTransformQuery {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "CrossfilterTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"crossfilter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum CrossfilterTransformType {
    #[serde(rename = "crossfilter")]
    Crossfilter,
}
impl From<&Self> for CrossfilterTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for CrossfilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Crossfilter => "crossfilter".to_string(),
        }
    }
}
impl std::str::FromStr for CrossfilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "crossfilter" => Ok(Self::Crossfilter),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for CrossfilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Data"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"source\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"source\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"url\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"async\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"copy\": {"]
#[doc = "                      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"property\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"json\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"csv\","]
#[doc = "                        \"tsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"delimiter\","]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"delimiter\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"dsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"feature\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"feature\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"mesh\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"filter\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"interior\","]
#[doc = "                            \"exterior\","]
#[doc = "                            null"]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        \"mesh\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"url\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"values\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"async\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"copy\": {"]
#[doc = "                      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"property\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"json\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"csv\","]
#[doc = "                        \"tsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"delimiter\","]
#[doc = "                    \"type\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"delimiter\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"header\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"parse\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"auto\""]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"additionalProperties\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"enum\": ["]
#[doc = "                                  \"boolean\","]
#[doc = "                                  \"number\","]
#[doc = "                                  \"date\","]
#[doc = "                                  \"string\""]
#[doc = "                                ]"]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\","]
#[doc = "                                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"type\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"dsv\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"feature\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"feature\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"required\": ["]
#[doc = "                        \"mesh\","]
#[doc = "                        \"type\""]
#[doc = "                      ],"]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"filter\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"interior\","]
#[doc = "                            \"exterior\","]
#[doc = "                            null"]
#[doc = "                          ]"]
#[doc = "                        },"]
#[doc = "                        \"mesh\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"property\": {"]
#[doc = "                          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                        },"]
#[doc = "                        \"type\": {"]
#[doc = "                          \"enum\": ["]
#[doc = "                            \"topojson\""]
#[doc = "                          ]"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      \"additionalProperties\": false"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onTrigger\""]
#[doc = "        },"]
#[doc = "        \"transform\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/transform\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"values\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {},"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Data {
    Variant0 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant1 {
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        source: DataVariant1Source,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
    },
    Variant2 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant2Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        url: StringOrSignal,
    },
    Variant3 {
        #[serde(rename = "async", default, skip_serializing_if = "Option::is_none")]
        async_: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<DataVariant3Format>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnTrigger>,
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        transform: Vec<Transform>,
        values: DataVariant3Values,
    },
}
impl From<&Self> for Data {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant1Source"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant1Source {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for DataVariant1Source {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for DataVariant1Source {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"copy\": {"]
#[doc = "              \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"property\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"csv\","]
#[doc = "                \"tsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delimiter\","]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delimiter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"dsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"feature\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"feature\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"mesh\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"filter\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"interior\","]
#[doc = "                    \"exterior\","]
#[doc = "                    null"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"mesh\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2Format {
    Variant0 {
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_0: Option<DataVariant2FormatVariant0Subtype0>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_1: Option<DataVariant2FormatVariant0Subtype1>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_2: Option<DataVariant2FormatVariant0Subtype2>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_3: Option<DataVariant2FormatVariant0Subtype3>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_4: Option<DataVariant2FormatVariant0Subtype4>,
    },
    Variant1(SignalRef),
}
impl From<&Self> for DataVariant2Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for DataVariant2Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0Parse {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant2FormatVariant0Subtype0ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant2FormatVariant0Subtype0ParseVariant0>
    for DataVariant2FormatVariant0Subtype0Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant2FormatVariant0Subtype0ParseVariant1Value>>
    for DataVariant2FormatVariant0Subtype0Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype0ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant2FormatVariant0Subtype0Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant2FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"copy\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"property\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant2FormatVariant0Subtype1Type>,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1Parse {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant2FormatVariant0Subtype1ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant2FormatVariant0Subtype1ParseVariant0>
    for DataVariant2FormatVariant0Subtype1Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant2FormatVariant0Subtype1ParseVariant1Value>>
    for DataVariant2FormatVariant0Subtype1Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype1ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant2FormatVariant0Subtype1Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant2FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant2FormatVariant0Subtype1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"csv\","]
#[doc = "        \"tsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype2Type,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2Parse {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant2FormatVariant0Subtype2ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant2FormatVariant0Subtype2ParseVariant0>
    for DataVariant2FormatVariant0Subtype2Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant2FormatVariant0Subtype2ParseVariant1Value>>
    for DataVariant2FormatVariant0Subtype2Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype2ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant2FormatVariant0Subtype2Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant2FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant2FormatVariant0Subtype2Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"csv\","]
#[doc = "    \"tsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype2Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delimiter\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delimiter\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant2FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant2FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant2FormatVariant0Subtype3Type,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3Parse {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant2FormatVariant0Subtype3ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant2FormatVariant0Subtype3ParseVariant0>
    for DataVariant2FormatVariant0Subtype3Parse
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant2FormatVariant0Subtype3ParseVariant1Value>>
    for DataVariant2FormatVariant0Subtype3Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant2FormatVariant0Subtype3ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant2FormatVariant0Subtype3Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    Variant0(DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0),
    Variant1(DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant2FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant2FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant2FormatVariant0Subtype3Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype3Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype4"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"feature\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"feature\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"mesh\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"filter\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"interior\","]
#[doc = "            \"exterior\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mesh\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant2FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant2FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant2FormatVariant0Subtype4Variant1Type,
    },
}
impl From<&Self> for DataVariant2FormatVariant0Subtype4 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype4Variant0Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype4Variant1Filter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"interior\","]
#[doc = "    \"exterior\","]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant2FormatVariant0Subtype4Variant1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant2FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&Self> for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant2FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant2FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"copy\": {"]
#[doc = "              \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"property\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"json\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"csv\","]
#[doc = "                \"tsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delimiter\","]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delimiter\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"header\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"parse\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"auto\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"enum\": ["]
#[doc = "                          \"boolean\","]
#[doc = "                          \"number\","]
#[doc = "                          \"date\","]
#[doc = "                          \"string\""]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"string\","]
#[doc = "                        \"pattern\": \"^(date|utc):.*$\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"dsv\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"feature\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"feature\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"mesh\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"filter\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"interior\","]
#[doc = "                    \"exterior\","]
#[doc = "                    null"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"mesh\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"property\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"type\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"topojson\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3Format {
    Variant0 {
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_0: Option<DataVariant3FormatVariant0Subtype0>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_1: Option<DataVariant3FormatVariant0Subtype1>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_2: Option<DataVariant3FormatVariant0Subtype2>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_3: Option<DataVariant3FormatVariant0Subtype3>,
        #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
        subtype_4: Option<DataVariant3FormatVariant0Subtype4>,
    },
    Variant1(SignalRef),
}
impl From<&Self> for DataVariant3Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for DataVariant3Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype0Parse>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0Parse {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant3FormatVariant0Subtype0ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant3FormatVariant0Subtype0ParseVariant0>
    for DataVariant3FormatVariant0Subtype0Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant3FormatVariant0Subtype0ParseVariant1Value>>
    for DataVariant3FormatVariant0Subtype0Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype0ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant3FormatVariant0Subtype0Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype0ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype0ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant3FormatVariant0Subtype0ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"copy\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"property\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"json\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub copy: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype1Parse>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub property: Option<StringOrSignal>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<DataVariant3FormatVariant0Subtype1Type>,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1Parse {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant3FormatVariant0Subtype1ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant3FormatVariant0Subtype1ParseVariant0>
    for DataVariant3FormatVariant0Subtype1Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant3FormatVariant0Subtype1ParseVariant1Value>>
    for DataVariant3FormatVariant0Subtype1Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype1ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant3FormatVariant0Subtype1Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype1ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant3FormatVariant0Subtype1ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant3FormatVariant0Subtype1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"json\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype1Type {
    #[serde(rename = "json")]
    Json,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Json => "json".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "json" => Ok(Self::Json),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"csv\","]
#[doc = "        \"tsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype2 {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype2Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype2Type,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2Parse {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant3FormatVariant0Subtype2ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant3FormatVariant0Subtype2ParseVariant0>
    for DataVariant3FormatVariant0Subtype2Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant3FormatVariant0Subtype2ParseVariant1Value>>
    for DataVariant3FormatVariant0Subtype2Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype2ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant3FormatVariant0Subtype2Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype2ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant3FormatVariant0Subtype2ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant3FormatVariant0Subtype2Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"csv\","]
#[doc = "    \"tsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype2Type {
    #[serde(rename = "csv")]
    Csv,
    #[serde(rename = "tsv")]
    Tsv,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype2Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Csv => "csv".to_string(),
            Self::Tsv => "tsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "csv" => Ok(Self::Csv),
            "tsv" => Ok(Self::Tsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delimiter\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delimiter\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"parse\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"auto\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"boolean\","]
#[doc = "                  \"number\","]
#[doc = "                  \"date\","]
#[doc = "                  \"string\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"string\","]
#[doc = "                \"pattern\": \"^(date|utc):.*$\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dsv\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DataVariant3FormatVariant0Subtype3 {
    pub delimiter: String,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub header: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parse: Option<DataVariant3FormatVariant0Subtype3Parse>,
    #[serde(rename = "type")]
    pub type_: DataVariant3FormatVariant0Subtype3Type,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3Parse"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"auto\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"boolean\","]
#[doc = "              \"number\","]
#[doc = "              \"date\","]
#[doc = "              \"string\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\","]
#[doc = "            \"pattern\": \"^(date|utc):.*$\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3Parse {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant0),
    Variant1(
        std::collections::HashMap<String, DataVariant3FormatVariant0Subtype3ParseVariant1Value>,
    ),
    Variant2(SignalRef),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3Parse {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<DataVariant3FormatVariant0Subtype3ParseVariant0>
    for DataVariant3FormatVariant0Subtype3Parse
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<std::collections::HashMap<String, DataVariant3FormatVariant0Subtype3ParseVariant1Value>>
    for DataVariant3FormatVariant0Subtype3Parse
{
    fn from(
        value: std::collections::HashMap<
            String,
            DataVariant3FormatVariant0Subtype3ParseVariant1Value,
        >,
    ) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for DataVariant3FormatVariant0Subtype3Parse {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3ParseVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"auto\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant0 {
    #[serde(rename = "auto")]
    Auto,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Auto => "auto".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "auto" => Ok(Self::Auto),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3ParseVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3ParseVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"boolean\","]
#[doc = "        \"number\","]
#[doc = "        \"date\","]
#[doc = "        \"string\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^(date|utc):.*$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    Variant0(DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0),
    Variant1(DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1),
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant1Value {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1>
    for DataVariant3FormatVariant0Subtype3ParseVariant1Value
{
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"boolean\","]
#[doc = "    \"number\","]
#[doc = "    \"date\","]
#[doc = "    \"string\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    #[serde(rename = "boolean")]
    Boolean,
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "string")]
    String,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Boolean => "boolean".to_string(),
            Self::Number => "number".to_string(),
            Self::Date => "date".to_string(),
            Self::String => "string".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "boolean" => Ok(Self::Boolean),
            "number" => Ok(Self::Number),
            "date" => Ok(Self::Date),
            "string" => Ok(Self::String),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant0
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(date|utc):.*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1(String);
impl std::ops::Deref for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1> for String {
    fn from(value: DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1) -> Self {
        value.0
    }
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^(date|utc):.*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^(date|utc):.*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String>
    for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1
{
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> serde::Deserialize<'de> for DataVariant3FormatVariant0Subtype3ParseVariant1ValueVariant1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "DataVariant3FormatVariant0Subtype3Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dsv\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype3Type {
    #[serde(rename = "dsv")]
    Dsv,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype3Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Dsv => "dsv".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "dsv" => Ok(Self::Dsv),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype4"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"feature\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"feature\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"mesh\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"filter\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"interior\","]
#[doc = "            \"exterior\","]
#[doc = "            null"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mesh\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"property\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"topojson\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum DataVariant3FormatVariant0Subtype4 {
    Variant0 {
        feature: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<DataVariant3FormatVariant0Subtype4Variant1Filter>,
        mesh: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        property: Option<StringOrSignal>,
        #[serde(rename = "type")]
        type_: DataVariant3FormatVariant0Subtype4Variant1Type,
    },
}
impl From<&Self> for DataVariant3FormatVariant0Subtype4 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype4Variant0Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant0Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype4Variant1Filter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"interior\","]
#[doc = "    \"exterior\","]
#[doc = "    null"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Filter {
    #[serde(rename = "interior")]
    Interior,
    #[serde(rename = "exterior")]
    Exterior,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Filter {
    fn to_string(&self) -> String {
        match *self {
            Self::Interior => "interior".to_string(),
            Self::Exterior => "exterior".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "interior" => Ok(Self::Interior),
            "exterior" => Ok(Self::Exterior),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant1Filter {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3FormatVariant0Subtype4Variant1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"topojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DataVariant3FormatVariant0Subtype4Variant1Type {
    #[serde(rename = "topojson")]
    Topojson,
}
impl From<&Self> for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DataVariant3FormatVariant0Subtype4Variant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Topojson => "topojson".to_string(),
        }
    }
}
impl std::str::FromStr for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "topojson" => Ok(Self::Topojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DataVariant3FormatVariant0Subtype4Variant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DataVariant3Values"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {},"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DataVariant3Values {
    Variant0(serde_json::Value),
    Variant1(SignalRef),
}
impl From<&Self> for DataVariant3Values {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<serde_json::Value> for DataVariant3Values {
    fn from(value: serde_json::Value) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DataVariant3Values {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"value\","]
#[doc = "        \"density\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"distribution\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"normal\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"mean\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"stdev\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"lognormal\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"mean\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"stdev\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"uniform\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"max\": {"]
#[doc = "              \"default\": 1,"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"min\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\","]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"bandwidth\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/paramField\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/expr\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"from\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"kde\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"function\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"distributions\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {}"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"function\": {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"mixture\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"weights\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"anyOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"type\": \"number\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxsteps\": {"]
#[doc = "      \"default\": 200,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"pdf\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minsteps\": {"]
#[doc = "      \"default\": 25,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"density\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DensityTransform {
    #[serde(rename = "as", default = "defaults::density_transform_as")]
    pub as_: DensityTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub distribution: Option<DensityTransformDistribution>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<DensityTransformExtent>,
    #[serde(default = "defaults::density_transform_maxsteps")]
    pub maxsteps: DensityTransformMaxsteps,
    #[serde(default = "defaults::density_transform_method")]
    pub method: DensityTransformMethod,
    #[serde(default = "defaults::density_transform_minsteps")]
    pub minsteps: DensityTransformMinsteps,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<DensityTransformSteps>,
    #[serde(rename = "type")]
    pub type_: DensityTransformType,
}
impl From<&Self> for DensityTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DensityTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"value\","]
#[doc = "    \"density\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformAs {
    Variant0(Vec<DensityTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformAs {
    fn default() -> Self {
        Self::Variant0(vec![
            DensityTransformAsVariant0Item::Variant0("value".to_string()),
            DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
impl From<Vec<DensityTransformAsVariant0Item>> for DensityTransformAs {
    fn from(value: Vec<DensityTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for DensityTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistribution"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"normal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mean\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"stdev\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"lognormal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"mean\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"stdev\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"uniform\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"max\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"min\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bandwidth\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"from\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"kde\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"function\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distributions\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {}"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"function\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"mixture\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"weights\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "function", deny_unknown_fields)]
pub enum DensityTransformDistribution {
    #[serde(rename = "normal")]
    Normal {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionMean>,
        #[serde(default = "defaults::density_transform_distribution_normal_stdev")]
        stdev: DensityTransformDistributionStdev,
    },
    #[serde(rename = "lognormal")]
    Lognormal {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mean: Option<DensityTransformDistributionMean>,
        #[serde(default = "defaults::density_transform_distribution_lognormal_stdev")]
        stdev: DensityTransformDistributionStdev,
    },
    #[serde(rename = "uniform")]
    Uniform {
        #[serde(default = "defaults::density_transform_distribution_uniform_max")]
        max: DensityTransformDistributionMax,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        min: Option<DensityTransformDistributionMin>,
    },
    #[serde(rename = "kde")]
    Kde {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bandwidth: Option<DensityTransformDistributionBandwidth>,
        field: DensityTransformDistributionField,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        from: Option<String>,
    },
    #[serde(rename = "mixture")]
    Mixture {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        distributions: Option<DensityTransformDistributionDistributions>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        weights: Option<DensityTransformDistributionWeights>,
    },
}
impl From<&Self> for DensityTransformDistribution {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DensityTransformDistributionBandwidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionBandwidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformDistributionBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionDistributions"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionDistributions {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionDistributions {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for DensityTransformDistributionDistributions {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionDistributions {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for DensityTransformDistributionField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for DensityTransformDistributionField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for DensityTransformDistributionField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for DensityTransformDistributionField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "DensityTransformDistributionMax"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionMax {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionMax {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformDistributionMax {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for DensityTransformDistributionMax {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionMax {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionMean"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionMean {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionMean {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformDistributionMean {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionMean {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionMin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionMin {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformDistributionMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionStdev"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionStdev {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionStdev {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformDistributionStdev {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for DensityTransformDistributionStdev {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionStdev {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionWeights"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionWeights {
    Variant0(Vec<DensityTransformDistributionWeightsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionWeights {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<DensityTransformDistributionWeightsVariant0Item>>
    for DensityTransformDistributionWeights
{
    fn from(value: Vec<DensityTransformDistributionWeightsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionWeights {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformDistributionWeightsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformDistributionWeightsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformDistributionWeightsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformExtent {
    Variant0([DensityTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[DensityTransformExtentVariant0Item; 2usize]> for DensityTransformExtent {
    fn from(value: [DensityTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformMaxsteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 200,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformMaxsteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMaxsteps {
    fn default() -> Self {
        Self::Variant0(200_f64)
    }
}
impl From<f64> for DensityTransformMaxsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformMaxsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"pdf\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMethod {
    fn default() -> Self {
        Self::Variant0("pdf".to_string())
    }
}
impl From<SignalRef> for DensityTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformMinsteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 25,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformMinsteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DensityTransformMinsteps {
    fn default() -> Self {
        Self::Variant0(25_f64)
    }
}
impl From<f64> for DensityTransformMinsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformMinsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformSteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DensityTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DensityTransformSteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DensityTransformSteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DensityTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DensityTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"density\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DensityTransformType {
    #[serde(rename = "density")]
    Density,
}
impl From<&Self> for DensityTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DensityTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Density => "density".to_string(),
        }
    }
}
impl std::str::FromStr for DensityTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "density" => Ok(Self::Density),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DensityTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DirectionValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"horizontal\","]
#[doc = "                              \"vertical\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"horizontal\","]
#[doc = "                        \"vertical\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValue {
    Variant0(Vec<DirectionValueVariant0Item>),
    Variant1(DirectionValueVariant1),
}
impl From<&Self> for DirectionValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<DirectionValueVariant0Item>> for DirectionValue {
    fn from(value: Vec<DirectionValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<DirectionValueVariant1> for DirectionValue {
    fn from(value: DirectionValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DirectionValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"horizontal\","]
#[doc = "                        \"vertical\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: DirectionValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: DirectionValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for DirectionValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DirectionValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DirectionValueVariant0ItemVariant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl From<&Self> for DirectionValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DirectionValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DirectionValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for DirectionValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DirectionValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DirectionValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for DirectionValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for DirectionValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DirectionValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"horizontal\","]
#[doc = "                    \"vertical\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: DirectionValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: DirectionValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for DirectionValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DirectionValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DirectionValueVariant1Variant1Value {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
}
impl From<&Self> for DirectionValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DirectionValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
        }
    }
}
impl std::str::FromStr for DirectionValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "DirectionValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DirectionValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for DirectionValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for DirectionValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for DirectionValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DirectionValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DirectionValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for DirectionValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for DirectionValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for DirectionValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DotbinTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"bin\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"dotbin\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct DotbinTransform {
    #[serde(rename = "as", default = "defaults::dotbin_transform_as")]
    pub as_: DotbinTransformAs,
    pub field: DotbinTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<DotbinTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<DotbinTransformSmooth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<DotbinTransformStep>,
    #[serde(rename = "type")]
    pub type_: DotbinTransformType,
}
impl From<&Self> for DotbinTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "DotbinTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"bin\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for DotbinTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for DotbinTransformAs {
    fn default() -> Self {
        Self::Variant0("bin".to_string())
    }
}
impl From<SignalRef> for DotbinTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DotbinTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for DotbinTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for DotbinTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for DotbinTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for DotbinTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "DotbinTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformGroupby {
    Variant0(Vec<DotbinTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for DotbinTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<DotbinTransformGroupbyVariant0Item>> for DotbinTransformGroupby {
    fn from(value: Vec<DotbinTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DotbinTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DotbinTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for DotbinTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for DotbinTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for DotbinTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for DotbinTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "DotbinTransformSmooth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for DotbinTransformSmooth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for DotbinTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DotbinTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DotbinTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum DotbinTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for DotbinTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for DotbinTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for DotbinTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "DotbinTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"dotbin\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum DotbinTransformType {
    #[serde(rename = "dotbin")]
    Dotbin,
}
impl From<&Self> for DotbinTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for DotbinTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Dotbin => "dotbin".to_string(),
        }
    }
}
impl std::str::FromStr for DotbinTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "dotbin" => Ok(Self::Dotbin),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for DotbinTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Element"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Element(pub String);
impl std::ops::Deref for Element {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Element> for String {
    fn from(value: Element) -> Self {
        value.0
    }
}
impl From<&Self> for Element {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<String> for Element {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Element {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Element {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[doc = "Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"patternProperties\": {"]
#[doc = "    \"^.+$\": {"]
#[doc = "      \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Encode {}
impl From<&Self> for Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "EncodeEntry"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"align\": {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    },"]
#[doc = "    \"angle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"aria\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"ariaRole\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"ariaRoleDescription\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"aspect\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"baseline\": {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    },"]
#[doc = "    \"blend\": {"]
#[doc = "      \"$ref\": \"#/definitions/blendValue\""]
#[doc = "    },"]
#[doc = "    \"clip\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusBottomLeft\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusBottomRight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusTopLeft\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cornerRadiusTopRight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"cursor\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"defined\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"dir\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"dx\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"dy\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"ellipsis\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"endAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"fill\": {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    },"]
#[doc = "    \"fillOpacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"font\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"fontSize\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"fontStyle\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"fontWeight\": {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"innerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"interpolate\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"limit\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"lineBreak\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"lineHeight\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"opacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"$ref\": \"#/definitions/directionValue\""]
#[doc = "    },"]
#[doc = "    \"outerRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"padAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"path\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"radius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"scaleX\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"scaleY\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"shape\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"startAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"stroke\": {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    },"]
#[doc = "    \"strokeCap\": {"]
#[doc = "      \"$ref\": \"#/definitions/strokeCapValue\""]
#[doc = "    },"]
#[doc = "    \"strokeDash\": {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    },"]
#[doc = "    \"strokeDashOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeForeground\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanValue\""]
#[doc = "    },"]
#[doc = "    \"strokeJoin\": {"]
#[doc = "      \"$ref\": \"#/definitions/strokeJoinValue\""]
#[doc = "    },"]
#[doc = "    \"strokeMiterLimit\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeOffset\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeOpacity\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"strokeWidth\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"tension\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"$ref\": \"#/definitions/textValue\""]
#[doc = "    },"]
#[doc = "    \"theta\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"tooltip\": {"]
#[doc = "      \"$ref\": \"#/definitions/anyValue\""]
#[doc = "    },"]
#[doc = "    \"url\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    },"]
#[doc = "    \"width\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"xc\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"yc\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    },"]
#[doc = "    \"zindex\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct EncodeEntry {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub align: Option<AlignValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<BooleanValue>,
    #[serde(rename = "ariaRole", default, skip_serializing_if = "Option::is_none")]
    pub aria_role: Option<StringValue>,
    #[serde(
        rename = "ariaRoleDescription",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub aria_role_description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aspect: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub baseline: Option<BaselineValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub blend: Option<BlendValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<BooleanValue>,
    #[serde(
        rename = "cornerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusBottomRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_bottom_right: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_left: Option<NumberValue>,
    #[serde(
        rename = "cornerRadiusTopRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub corner_radius_top_right: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cursor: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub defined: Option<BooleanValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dir: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dx: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub dy: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ellipsis: Option<StringValue>,
    #[serde(rename = "endAngle", default, skip_serializing_if = "Option::is_none")]
    pub end_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fill: Option<ColorValue>,
    #[serde(
        rename = "fillOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub fill_opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub font: Option<StringValue>,
    #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
    pub font_size: Option<NumberValue>,
    #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
    pub font_style: Option<StringValue>,
    #[serde(
        rename = "fontWeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub font_weight: Option<FontWeightValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberValue>,
    #[serde(
        rename = "innerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub inner_radius: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interpolate: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<NumberValue>,
    #[serde(rename = "lineBreak", default, skip_serializing_if = "Option::is_none")]
    pub line_break: Option<StringValue>,
    #[serde(
        rename = "lineHeight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub line_height: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub orient: Option<DirectionValue>,
    #[serde(
        rename = "outerRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub outer_radius: Option<NumberValue>,
    #[serde(rename = "padAngle", default, skip_serializing_if = "Option::is_none")]
    pub pad_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub path: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<NumberValue>,
    #[serde(rename = "scaleX", default, skip_serializing_if = "Option::is_none")]
    pub scale_x: Option<NumberValue>,
    #[serde(rename = "scaleY", default, skip_serializing_if = "Option::is_none")]
    pub scale_y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub shape: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub smooth: Option<BooleanValue>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub stroke: Option<ColorValue>,
    #[serde(rename = "strokeCap", default, skip_serializing_if = "Option::is_none")]
    pub stroke_cap: Option<StrokeCapValue>,
    #[serde(
        rename = "strokeDash",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash: Option<ArrayValue>,
    #[serde(
        rename = "strokeDashOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_dash_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeForeground",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_foreground: Option<BooleanValue>,
    #[serde(
        rename = "strokeJoin",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_join: Option<StrokeJoinValue>,
    #[serde(
        rename = "strokeMiterLimit",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_miter_limit: Option<NumberValue>,
    #[serde(
        rename = "strokeOffset",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_offset: Option<NumberValue>,
    #[serde(
        rename = "strokeOpacity",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_opacity: Option<NumberValue>,
    #[serde(
        rename = "strokeWidth",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub stroke_width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tension: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<TextValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub theta: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tooltip: Option<AnyValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub url: Option<StringValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub xc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub yc: Option<NumberValue>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub zindex: Option<NumberValue>,
}
impl From<&Self> for EncodeEntry {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "Everything"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Everything\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scope\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"properties\": {"]
#[doc = "        \"$schema\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"uri\""]
#[doc = "        },"]
#[doc = "        \"autosize\": {"]
#[doc = "          \"$ref\": \"#/definitions/autosize\""]
#[doc = "        },"]
#[doc = "        \"background\": {"]
#[doc = "          \"$ref\": \"#/definitions/background\""]
#[doc = "        },"]
#[doc = "        \"config\": {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"height\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/padding\""]
#[doc = "        },"]
#[doc = "        \"style\": {"]
#[doc = "          \"$ref\": \"#/definitions/style\""]
#[doc = "        },"]
#[doc = "        \"width\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Everything {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub autosize: Option<Autosize>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub axes: Vec<Axis>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub background: Option<Background>,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub config: serde_json::Map<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub height: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<Layout>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub legends: Vec<Legend>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub marks: Vec<EverythingMarksItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<Padding>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub projections: Vec<Projection>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub scales: Vec<Scale>,
    #[serde(rename = "$schema", default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub signals: Vec<Signal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<Title>,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub usermeta: serde_json::Map<String, serde_json::Value>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub width: Option<NumberOrSignal>,
}
impl From<&Self> for Everything {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "EverythingMarksItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum EverythingMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl From<&Self> for EverythingMarksItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MarkGroup> for EverythingMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl From<MarkVisual> for EverythingMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "Expr"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expr\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"expr\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Expr {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub expr: String,
}
impl From<&Self> for Expr {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ExprString"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct ExprString(pub String);
impl std::ops::Deref for ExprString {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<ExprString> for String {
    fn from(value: ExprString) -> Self {
        value.0
    }
}
impl From<&Self> for ExprString {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<String> for ExprString {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for ExprString {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for ExprString {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[doc = "ExtentTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"extent\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ExtentTransform {
    pub field: ExtentTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ExtentTransformType,
}
impl From<&Self> for ExtentTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ExtentTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ExtentTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ExtentTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ExtentTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ExtentTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ExtentTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ExtentTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"extent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ExtentTransformType {
    #[serde(rename = "extent")]
    Extent,
}
impl From<&Self> for ExtentTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ExtentTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for ExtentTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ExtentTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Facet"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"facet\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"facet\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"field\","]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"groupby\","]
#[doc = "            \"name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"aggregate\": {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"as\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"cross\": {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                \"fields\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"ops\": {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"groupby\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"array\","]
#[doc = "                  \"items\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Facet {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
    pub facet: FacetFacet,
}
impl From<&Self> for Facet {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FacetFacet"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"groupby\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"aggregate\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"as\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"cross\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"ops\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"groupby\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum FacetFacet {
    Variant0 {
        data: String,
        field: String,
        name: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aggregate: Option<FacetFacetVariant1Aggregate>,
        data: String,
        groupby: FacetFacetVariant1Groupby,
        name: String,
    },
}
impl From<&Self> for FacetFacet {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FacetFacetVariant1Aggregate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"cross\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FacetFacetVariant1Aggregate {
    #[serde(rename = "as", default, skip_serializing_if = "Vec::is_empty")]
    pub as_: Vec<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cross: Option<bool>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub fields: Vec<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub ops: Vec<String>,
}
impl From<&Self> for FacetFacetVariant1Aggregate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FacetFacetVariant1Groupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FacetFacetVariant1Groupby {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for FacetFacetVariant1Groupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for FacetFacetVariant1Groupby {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Field"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"datum\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"datum\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"group\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"group\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"level\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"parent\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"level\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"parent\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Field {
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        datum: Box<Field>,
    },
    Variant3 {
        group: Box<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        level: Option<f64>,
        parent: Box<Field>,
    },
}
impl From<&Self> for Field {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for Field {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FilterTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"expr\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expr\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"filter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FilterTransform {
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FilterTransformType,
}
impl From<&Self> for FilterTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FilterTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"filter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FilterTransformType {
    #[serde(rename = "filter")]
    Filter,
}
impl From<&Self> for FilterTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for FilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Filter => "filter".to_string(),
        }
    }
}
impl std::str::FromStr for FilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "filter" => Ok(Self::Filter),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "FlattenTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"index\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"flatten\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FlattenTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<FlattenTransformAs>,
    pub fields: FlattenTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub index: Option<FlattenTransformIndex>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FlattenTransformType,
}
impl From<&Self> for FlattenTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FlattenTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformAs {
    Variant0(Vec<FlattenTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for FlattenTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<FlattenTransformAsVariant0Item>> for FlattenTransformAs {
    fn from(value: Vec<FlattenTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for FlattenTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FlattenTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for FlattenTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for FlattenTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FlattenTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformFields {
    Variant0(Vec<FlattenTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for FlattenTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<FlattenTransformFieldsVariant0Item>> for FlattenTransformFields {
    fn from(value: Vec<FlattenTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for FlattenTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FlattenTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for FlattenTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for FlattenTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for FlattenTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for FlattenTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "FlattenTransformIndex"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FlattenTransformIndex {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for FlattenTransformIndex {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for FlattenTransformIndex {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FlattenTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"flatten\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FlattenTransformType {
    #[serde(rename = "flatten")]
    Flatten,
}
impl From<&Self> for FlattenTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for FlattenTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Flatten => "flatten".to_string(),
        }
    }
}
impl std::str::FromStr for FlattenTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "flatten" => Ok(Self::Flatten),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FlattenTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "FoldTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"key\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"fold\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FoldTransform {
    #[serde(rename = "as", default = "defaults::fold_transform_as")]
    pub as_: FoldTransformAs,
    pub fields: FoldTransformFields,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FoldTransformType,
}
impl From<&Self> for FoldTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FoldTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"key\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformAs {
    Variant0([FoldTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for FoldTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for FoldTransformAs {
    fn default() -> Self {
        Self::Variant0([
            FoldTransformAsVariant0Item::Variant0("key".to_string()),
            FoldTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
}
impl From<[FoldTransformAsVariant0Item; 2usize]> for FoldTransformAs {
    fn from(value: [FoldTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for FoldTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FoldTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for FoldTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for FoldTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FoldTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformFields {
    Variant0(Vec<FoldTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for FoldTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<FoldTransformFieldsVariant0Item>> for FoldTransformFields {
    fn from(value: Vec<FoldTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for FoldTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FoldTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FoldTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for FoldTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for FoldTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for FoldTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for FoldTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "FoldTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"fold\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FoldTransformType {
    #[serde(rename = "fold")]
    Fold,
}
impl From<&Self> for FoldTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for FoldTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Fold => "fold".to_string(),
        }
    }
}
impl std::str::FromStr for FoldTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "fold" => Ok(Self::Fold),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FoldTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "FontWeightValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              null,"]
#[doc = "                              \"normal\","]
#[doc = "                              \"bold\","]
#[doc = "                              \"lighter\","]
#[doc = "                              \"bolder\","]
#[doc = "                              \"100\","]
#[doc = "                              \"200\","]
#[doc = "                              \"300\","]
#[doc = "                              \"400\","]
#[doc = "                              \"500\","]
#[doc = "                              \"600\","]
#[doc = "                              \"700\","]
#[doc = "                              \"800\","]
#[doc = "                              \"900\","]
#[doc = "                              100,"]
#[doc = "                              200,"]
#[doc = "                              300,"]
#[doc = "                              400,"]
#[doc = "                              500,"]
#[doc = "                              600,"]
#[doc = "                              700,"]
#[doc = "                              800,"]
#[doc = "                              900"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"normal\","]
#[doc = "                        \"bold\","]
#[doc = "                        \"lighter\","]
#[doc = "                        \"bolder\","]
#[doc = "                        \"100\","]
#[doc = "                        \"200\","]
#[doc = "                        \"300\","]
#[doc = "                        \"400\","]
#[doc = "                        \"500\","]
#[doc = "                        \"600\","]
#[doc = "                        \"700\","]
#[doc = "                        \"800\","]
#[doc = "                        \"900\","]
#[doc = "                        100,"]
#[doc = "                        200,"]
#[doc = "                        300,"]
#[doc = "                        400,"]
#[doc = "                        500,"]
#[doc = "                        600,"]
#[doc = "                        700,"]
#[doc = "                        800,"]
#[doc = "                        900"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValue {
    Variant0(Vec<FontWeightValueVariant0Item>),
    Variant1(FontWeightValueVariant1),
}
impl From<&Self> for FontWeightValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<FontWeightValueVariant0Item>> for FontWeightValue {
    fn from(value: Vec<FontWeightValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValueVariant1> for FontWeightValue {
    fn from(value: FontWeightValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FontWeightValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        null,"]
#[doc = "                        \"normal\","]
#[doc = "                        \"bold\","]
#[doc = "                        \"lighter\","]
#[doc = "                        \"bolder\","]
#[doc = "                        \"100\","]
#[doc = "                        \"200\","]
#[doc = "                        \"300\","]
#[doc = "                        \"400\","]
#[doc = "                        \"500\","]
#[doc = "                        \"600\","]
#[doc = "                        \"700\","]
#[doc = "                        \"800\","]
#[doc = "                        \"900\","]
#[doc = "                        100,"]
#[doc = "                        200,"]
#[doc = "                        300,"]
#[doc = "                        400,"]
#[doc = "                        500,"]
#[doc = "                        600,"]
#[doc = "                        700,"]
#[doc = "                        800,"]
#[doc = "                        900"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: MyEnum,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: FontWeightValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for FontWeightValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FontWeightValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for FontWeightValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for FontWeightValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for FontWeightValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FontWeightValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FontWeightValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for FontWeightValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for FontWeightValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for FontWeightValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FontWeightValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    null,"]
#[doc = "                    \"normal\","]
#[doc = "                    \"bold\","]
#[doc = "                    \"lighter\","]
#[doc = "                    \"bolder\","]
#[doc = "                    \"100\","]
#[doc = "                    \"200\","]
#[doc = "                    \"300\","]
#[doc = "                    \"400\","]
#[doc = "                    \"500\","]
#[doc = "                    \"600\","]
#[doc = "                    \"700\","]
#[doc = "                    \"800\","]
#[doc = "                    \"900\","]
#[doc = "                    100,"]
#[doc = "                    200,"]
#[doc = "                    300,"]
#[doc = "                    400,"]
#[doc = "                    500,"]
#[doc = "                    600,"]
#[doc = "                    700,"]
#[doc = "                    800,"]
#[doc = "                    900"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: MyEnum,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: FontWeightValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for FontWeightValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FontWeightValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FontWeightValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for FontWeightValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for FontWeightValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for FontWeightValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FontWeightValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FontWeightValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for FontWeightValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for FontWeightValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for FontWeightValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"alpha\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alphaMin\": {"]
#[doc = "      \"default\": 0.001,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"alphaTarget\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"vx\","]
#[doc = "        \"vy\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"forces\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"center\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"x\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"y\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"collide\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"iterations\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"radius\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.7,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"distanceMax\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"distanceMin\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"nbody\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": -30,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"theta\": {"]
#[doc = "                \"default\": 0.9,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"distance\": {"]
#[doc = "                \"default\": 30,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"link\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"id\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"iterations\": {"]
#[doc = "                \"default\": 1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"links\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"x\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"x\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"force\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"force\": {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"y\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"strength\": {"]
#[doc = "                \"default\": 0.1,"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"y\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/scaleField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/paramField\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"additionalProperties\": false"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"iterations\": {"]
#[doc = "      \"default\": 300,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"restart\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"static\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"force\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"velocityDecay\": {"]
#[doc = "      \"default\": 0.4,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ForceTransform {
    #[serde(default = "defaults::force_transform_alpha")]
    pub alpha: ForceTransformAlpha,
    #[serde(rename = "alphaMin", default = "defaults::force_transform_alpha_min")]
    pub alpha_min: ForceTransformAlphaMin,
    #[serde(
        rename = "alphaTarget",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub alpha_target: Option<ForceTransformAlphaTarget>,
    #[serde(rename = "as", default = "defaults::force_transform_as")]
    pub as_: ForceTransformAs,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub forces: Vec<ForceTransformForcesItem>,
    #[serde(default = "defaults::force_transform_iterations")]
    pub iterations: ForceTransformIterations,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub restart: Option<ForceTransformRestart>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "static", default, skip_serializing_if = "Option::is_none")]
    pub static_: Option<ForceTransformStatic>,
    #[serde(rename = "type")]
    pub type_: ForceTransformType,
    #[serde(
        rename = "velocityDecay",
        default = "defaults::force_transform_velocity_decay"
    )]
    pub velocity_decay: ForceTransformVelocityDecay,
}
impl From<&Self> for ForceTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ForceTransformAlpha"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlpha {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformAlpha {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAlpha {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for ForceTransformAlpha {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformAlpha {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformAlphaMin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.001,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlphaMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformAlphaMin {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAlphaMin {
    fn default() -> Self {
        Self::Variant0(0.001_f64)
    }
}
impl From<f64> for ForceTransformAlphaMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformAlphaMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformAlphaTarget"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAlphaTarget {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformAlphaTarget {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ForceTransformAlphaTarget {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformAlphaTarget {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"vx\","]
#[doc = "    \"vy\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAs {
    Variant0(Vec<ForceTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformAs {
    fn default() -> Self {
        Self::Variant0(vec![
            ForceTransformAsVariant0Item::Variant0("x".to_string()),
            ForceTransformAsVariant0Item::Variant0("y".to_string()),
            ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
}
impl From<Vec<ForceTransformAsVariant0Item>> for ForceTransformAs {
    fn from(value: Vec<ForceTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ForceTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"center\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"x\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"y\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"collide\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"iterations\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"radius\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.7,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distanceMax\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"distanceMin\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"nbody\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": -30,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"theta\": {"]
#[doc = "          \"default\": 0.9,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"distance\": {"]
#[doc = "          \"default\": 30,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"link\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"iterations\": {"]
#[doc = "          \"default\": 1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"links\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"x\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"x\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"force\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"force\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"y\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strength\": {"]
#[doc = "          \"default\": 0.1,"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"y\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/paramField\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/expr\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "force", deny_unknown_fields)]
pub enum ForceTransformForcesItem {
    #[serde(rename = "center")]
    Center {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemX>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemY>,
    },
    #[serde(rename = "collide")]
    Collide {
        #[serde(default = "defaults::force_transform_forces_item_collide_iterations")]
        iterations: ForceTransformForcesItemIterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        radius: Option<ForceTransformForcesItemRadius>,
        #[serde(default = "defaults::force_transform_forces_item_collide_strength")]
        strength: ForceTransformForcesItemStrength,
    },
    #[serde(rename = "nbody")]
    Nbody {
        #[serde(
            rename = "distanceMax",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        distance_max: Option<ForceTransformForcesItemDistanceMax>,
        #[serde(
            rename = "distanceMin",
            default = "defaults::force_transform_forces_item_nbody_distance_min"
        )]
        distance_min: ForceTransformForcesItemDistanceMin,
        #[serde(default = "defaults::force_transform_forces_item_nbody_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default = "defaults::force_transform_forces_item_nbody_theta")]
        theta: ForceTransformForcesItemTheta,
    },
    #[serde(rename = "link")]
    Link {
        #[serde(default = "defaults::force_transform_forces_item_link_distance")]
        distance: ForceTransformForcesItemDistance,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        id: Option<ForceTransformForcesItemId>,
        #[serde(default = "defaults::force_transform_forces_item_link_iterations")]
        iterations: ForceTransformForcesItemIterations,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        links: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        strength: Option<ForceTransformForcesItemStrength>,
    },
    #[serde(rename = "x")]
    X {
        #[serde(default = "defaults::force_transform_forces_item_x_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        x: Option<ForceTransformForcesItemX>,
    },
    #[serde(rename = "y")]
    Y {
        #[serde(default = "defaults::force_transform_forces_item_y_strength")]
        strength: ForceTransformForcesItemStrength,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        y: Option<ForceTransformForcesItemY>,
    },
}
impl From<&Self> for ForceTransformForcesItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ForceTransformForcesItemDistance"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 30,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistance {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for ForceTransformForcesItemDistance {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemDistance {
    fn default() -> Self {
        Self::Variant0(30_f64)
    }
}
impl From<f64> for ForceTransformForcesItemDistance {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemDistance {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for ForceTransformForcesItemDistance {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for ForceTransformForcesItemDistance {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ForceTransformForcesItemDistanceMax"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistanceMax {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemDistanceMax {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ForceTransformForcesItemDistanceMax {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemDistanceMax {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemDistanceMin"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemDistanceMin {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemDistanceMin {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemDistanceMin {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for ForceTransformForcesItemDistanceMin {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemDistanceMin {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemId"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemId {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ForceTransformForcesItemId {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ForceTransformForcesItemId {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ForceTransformForcesItemId {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ForceTransformForcesItemId {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ForceTransformForcesItemIterations"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemIterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemIterations {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemIterations {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for ForceTransformForcesItemIterations {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemIterations {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for ForceTransformForcesItemRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ForceTransformForcesItemRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for ForceTransformForcesItemRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for ForceTransformForcesItemRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ForceTransformForcesItemStrength"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.7,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemStrength {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemStrength {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemStrength {
    fn default() -> Self {
        Self::Variant0(0.7_f64)
    }
}
impl From<f64> for ForceTransformForcesItemStrength {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemStrength {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemTheta"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.9,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemTheta {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemTheta {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformForcesItemTheta {
    fn default() -> Self {
        Self::Variant0(0.9_f64)
    }
}
impl From<f64> for ForceTransformForcesItemTheta {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemTheta {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemX {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ForceTransformForcesItemX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemX {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformForcesItemY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformForcesItemY {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformForcesItemY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ForceTransformForcesItemY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformForcesItemY {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformIterations"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 300,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformIterations {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformIterations {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformIterations {
    fn default() -> Self {
        Self::Variant0(300_f64)
    }
}
impl From<f64> for ForceTransformIterations {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformIterations {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformRestart"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformRestart {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformRestart {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ForceTransformRestart {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformRestart {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformStatic"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformStatic {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformStatic {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ForceTransformStatic {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformStatic {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ForceTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"force\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ForceTransformType {
    #[serde(rename = "force")]
    Force,
}
impl From<&Self> for ForceTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ForceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Force => "force".to_string(),
        }
    }
}
impl std::str::FromStr for ForceTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "force" => Ok(Self::Force),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ForceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ForceTransformVelocityDecay"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.4,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ForceTransformVelocityDecay {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ForceTransformVelocityDecay {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ForceTransformVelocityDecay {
    fn default() -> Self {
        Self::Variant0(0.4_f64)
    }
}
impl From<f64> for ForceTransformVelocityDecay {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ForceTransformVelocityDecay {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FormulaTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"as\","]
#[doc = "    \"expr\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"expr\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"initonly\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"formula\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct FormulaTransform {
    #[serde(rename = "as")]
    pub as_: FormulaTransformAs,
    pub expr: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub initonly: Option<FormulaTransformInitonly>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: FormulaTransformType,
}
impl From<&Self> for FormulaTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "FormulaTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FormulaTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for FormulaTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for FormulaTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FormulaTransformInitonly"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum FormulaTransformInitonly {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for FormulaTransformInitonly {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for FormulaTransformInitonly {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for FormulaTransformInitonly {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "FormulaTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"formula\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum FormulaTransformType {
    #[serde(rename = "formula")]
    Formula,
}
impl From<&Self> for FormulaTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for FormulaTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Formula => "formula".to_string(),
        }
    }
}
impl std::str::FromStr for FormulaTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "formula" => Ok(Self::Formula),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for FormulaTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "From"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct From {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub data: Option<String>,
}
impl From<&Self> for From {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GeojsonTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"geojson\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geojson\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeojsonTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<GeojsonTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub geojson: Option<GeojsonTransformGeojson>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeojsonTransformType,
}
impl From<&Self> for GeojsonTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GeojsonTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformFields {
    Variant0([GeojsonTransformFieldsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GeojsonTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[GeojsonTransformFieldsVariant0Item; 2usize]> for GeojsonTransformFields {
    fn from(value: [GeojsonTransformFieldsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GeojsonTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeojsonTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for GeojsonTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for GeojsonTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for GeojsonTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for GeojsonTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "GeojsonTransformGeojson"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeojsonTransformGeojson {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for GeojsonTransformGeojson {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for GeojsonTransformGeojson {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for GeojsonTransformGeojson {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for GeojsonTransformGeojson {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "GeojsonTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geojson\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeojsonTransformType {
    #[serde(rename = "geojson")]
    Geojson,
}
impl From<&Self> for GeojsonTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for GeojsonTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geojson => "geojson".to_string(),
        }
    }
}
impl std::str::FromStr for GeojsonTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "geojson" => Ok(Self::Geojson),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeojsonTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GeopathTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geopath\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopathTransform {
    #[serde(rename = "as", default = "defaults::geopath_transform_as")]
    pub as_: GeopathTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<GeopathTransformField>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeopathTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopathTransformType,
}
impl From<&Self> for GeopathTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GeopathTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for GeopathTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GeopathTransformAs {
    fn default() -> Self {
        Self::Variant0("path".to_string())
    }
}
impl From<SignalRef> for GeopathTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeopathTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for GeopathTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for GeopathTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for GeopathTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for GeopathTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "GeopathTransformPointRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopathTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for GeopathTransformPointRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for GeopathTransformPointRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GeopathTransformPointRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for GeopathTransformPointRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for GeopathTransformPointRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "GeopathTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geopath\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeopathTransformType {
    #[serde(rename = "geopath")]
    Geopath,
}
impl From<&Self> for GeopathTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for GeopathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopath => "geopath".to_string(),
        }
    }
}
impl std::str::FromStr for GeopathTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "geopath" => Ok(Self::Geopath),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeopathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GeopointTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"projection\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geopoint\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeopointTransform {
    #[serde(rename = "as", default = "defaults::geopoint_transform_as")]
    pub as_: GeopointTransformAs,
    pub fields: GeopointTransformFields,
    pub projection: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeopointTransformType,
}
impl From<&Self> for GeopointTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GeopointTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformAs {
    Variant0([GeopointTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GeopointTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GeopointTransformAs {
    fn default() -> Self {
        Self::Variant0([
            GeopointTransformAsVariant0Item::Variant0("x".to_string()),
            GeopointTransformAsVariant0Item::Variant0("y".to_string()),
        ])
    }
}
impl From<[GeopointTransformAsVariant0Item; 2usize]> for GeopointTransformAs {
    fn from(value: [GeopointTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GeopointTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeopointTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for GeopointTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for GeopointTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeopointTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformFields {
    Variant0([GeopointTransformFieldsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GeopointTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[GeopointTransformFieldsVariant0Item; 2usize]> for GeopointTransformFields {
    fn from(value: [GeopointTransformFieldsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GeopointTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeopointTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeopointTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for GeopointTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for GeopointTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for GeopointTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for GeopointTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "GeopointTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geopoint\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeopointTransformType {
    #[serde(rename = "geopoint")]
    Geopoint,
}
impl From<&Self> for GeopointTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for GeopointTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geopoint => "geopoint".to_string(),
        }
    }
}
impl std::str::FromStr for GeopointTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "geopoint" => Ok(Self::Geopoint),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeopointTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GeoshapeTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"shape\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"default\": \"datum\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"projection\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"geoshape\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GeoshapeTransform {
    #[serde(rename = "as", default = "defaults::geoshape_transform_as")]
    pub as_: GeoshapeTransformAs,
    #[serde(default = "defaults::geoshape_transform_field")]
    pub field: GeoshapeTransformField,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<GeoshapeTransformPointRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub projection: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: GeoshapeTransformType,
}
impl From<&Self> for GeoshapeTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GeoshapeTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"shape\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for GeoshapeTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GeoshapeTransformAs {
    fn default() -> Self {
        Self::Variant0("shape".to_string())
    }
}
impl From<SignalRef> for GeoshapeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GeoshapeTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"datum\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for GeoshapeTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GeoshapeTransformField {
    fn default() -> Self {
        Self::ScaleField(ScaleField(StringOrSignal::Variant0("datum".to_string())))
    }
}
impl From<ScaleField> for GeoshapeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for GeoshapeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for GeoshapeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "GeoshapeTransformPointRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GeoshapeTransformPointRadius {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for GeoshapeTransformPointRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for GeoshapeTransformPointRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GeoshapeTransformPointRadius {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for GeoshapeTransformPointRadius {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for GeoshapeTransformPointRadius {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "GeoshapeTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"geoshape\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GeoshapeTransformType {
    #[serde(rename = "geoshape")]
    Geoshape,
}
impl From<&Self> for GeoshapeTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for GeoshapeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Geoshape => "geoshape".to_string(),
        }
    }
}
impl std::str::FromStr for GeoshapeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "geoshape" => Ok(Self::Geoshape),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GeoshapeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GradientStops"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"color\","]
#[doc = "      \"offset\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"color\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      },"]
#[doc = "      \"offset\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GradientStops(pub Vec<GradientStopsItem>);
impl std::ops::Deref for GradientStops {
    type Target = Vec<GradientStopsItem>;
    fn deref(&self) -> &Vec<GradientStopsItem> {
        &self.0
    }
}
impl From<GradientStops> for Vec<GradientStopsItem> {
    fn from(value: GradientStops) -> Self {
        value.0
    }
}
impl From<&Self> for GradientStops {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<GradientStopsItem>> for GradientStops {
    fn from(value: Vec<GradientStopsItem>) -> Self {
        Self(value)
    }
}
#[doc = "GradientStopsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"color\","]
#[doc = "    \"offset\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"color\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GradientStopsItem {
    pub color: String,
    pub offset: f64,
}
impl From<&Self> for GradientStopsItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GraticuleTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extentMajor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extentMinor\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"precision\": {"]
#[doc = "      \"default\": 2.5,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stepMajor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        90,"]
#[doc = "        360"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stepMinor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        10,"]
#[doc = "        10"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"graticule\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GraticuleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<GraticuleTransformExtent>,
    #[serde(
        rename = "extentMajor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_major: Option<GraticuleTransformExtentMajor>,
    #[serde(
        rename = "extentMinor",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub extent_minor: Option<GraticuleTransformExtentMinor>,
    #[serde(default = "defaults::graticule_transform_precision")]
    pub precision: GraticuleTransformPrecision,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub step: Option<GraticuleTransformStep>,
    #[serde(
        rename = "stepMajor",
        default = "defaults::graticule_transform_step_major"
    )]
    pub step_major: GraticuleTransformStepMajor,
    #[serde(
        rename = "stepMinor",
        default = "defaults::graticule_transform_step_minor"
    )]
    pub step_minor: GraticuleTransformStepMinor,
    #[serde(rename = "type")]
    pub type_: GraticuleTransformType,
}
impl From<&Self> for GraticuleTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "GraticuleTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtent {
    Variant0([serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[serde_json::Value; 2usize]> for GraticuleTransformExtent {
    fn from(value: [serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformExtentMajor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMajor {
    Variant0([serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformExtentMajor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[serde_json::Value; 2usize]> for GraticuleTransformExtentMajor {
    fn from(value: [serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformExtentMajor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformExtentMinor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformExtentMinor {
    Variant0([serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformExtentMinor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[serde_json::Value; 2usize]> for GraticuleTransformExtentMinor {
    fn from(value: [serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformExtentMinor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformPrecision"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 2.5,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformPrecision {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformPrecision {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformPrecision {
    fn default() -> Self {
        Self::Variant0(2.5_f64)
    }
}
impl From<f64> for GraticuleTransformPrecision {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformPrecision {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStep {
    Variant0([GraticuleTransformStepVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[GraticuleTransformStepVariant0Item; 2usize]> for GraticuleTransformStep {
    fn from(value: [GraticuleTransformStepVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStepMajor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    90,"]
#[doc = "    360"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajor {
    Variant0([GraticuleTransformStepMajorVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStepMajor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformStepMajor {
    fn default() -> Self {
        Self::Variant0([
            GraticuleTransformStepMajorVariant0Item::Variant0(90_f64),
            GraticuleTransformStepMajorVariant0Item::Variant0(360_f64),
        ])
    }
}
impl From<[GraticuleTransformStepMajorVariant0Item; 2usize]> for GraticuleTransformStepMajor {
    fn from(value: [GraticuleTransformStepMajorVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStepMajor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStepMajorVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMajorVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStepMajorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStepMinor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    10,"]
#[doc = "    10"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinor {
    Variant0([GraticuleTransformStepMinorVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStepMinor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for GraticuleTransformStepMinor {
    fn default() -> Self {
        Self::Variant0([
            GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
            GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
        ])
    }
}
impl From<[GraticuleTransformStepMinorVariant0Item; 2usize]> for GraticuleTransformStepMinor {
    fn from(value: [GraticuleTransformStepMinorVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStepMinor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStepMinorVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepMinorVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStepMinorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformStepVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum GraticuleTransformStepVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for GraticuleTransformStepVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for GraticuleTransformStepVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for GraticuleTransformStepVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "GraticuleTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"graticule\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum GraticuleTransformType {
    #[serde(rename = "graticule")]
    Graticule,
}
impl From<&Self> for GraticuleTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for GraticuleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Graticule => "graticule".to_string(),
        }
    }
}
impl std::str::FromStr for GraticuleTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "graticule" => Ok(Self::Graticule),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for GraticuleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "GuideEncode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"interactive\": {"]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"style\": {"]
#[doc = "      \"$ref\": \"#/definitions/style\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"patternProperties\": {"]
#[doc = "    \"^(?!interactive|name|style).+$\": {"]
#[doc = "      \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct GuideEncode {
    #[serde(default)]
    pub interactive: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
}
impl From<&Self> for GuideEncode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "HeatmapTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"image\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"color\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"opacity\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct HeatmapTransform {
    #[serde(rename = "as", default = "defaults::heatmap_transform_as")]
    pub as_: HeatmapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub color: Option<HeatmapTransformColor>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<HeatmapTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub opacity: Option<HeatmapTransformOpacity>,
    #[serde(default = "defaults::heatmap_transform_resolve")]
    pub resolve: HeatmapTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: HeatmapTransformType,
}
impl From<&Self> for HeatmapTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "HeatmapTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"image\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for HeatmapTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for HeatmapTransformAs {
    fn default() -> Self {
        Self::Variant0("image".to_string())
    }
}
impl From<SignalRef> for HeatmapTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "HeatmapTransformColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformColor {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for HeatmapTransformColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for HeatmapTransformColor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for HeatmapTransformColor {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for HeatmapTransformColor {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "HeatmapTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for HeatmapTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for HeatmapTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for HeatmapTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for HeatmapTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "HeatmapTransformOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformOpacity {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for HeatmapTransformOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for HeatmapTransformOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for HeatmapTransformOpacity {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for HeatmapTransformOpacity {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for HeatmapTransformOpacity {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "HeatmapTransformResolve"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum HeatmapTransformResolve {
    Variant0(HeatmapTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for HeatmapTransformResolve {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for HeatmapTransformResolve {
    fn default() -> Self {
        Self::Variant0(HeatmapTransformResolveVariant0::Independent)
    }
}
impl From<HeatmapTransformResolveVariant0> for HeatmapTransformResolve {
    fn from(value: HeatmapTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for HeatmapTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "HeatmapTransformResolveVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum HeatmapTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&Self> for HeatmapTransformResolveVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for HeatmapTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for HeatmapTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "HeatmapTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum HeatmapTransformType {
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for HeatmapTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for HeatmapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for HeatmapTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for HeatmapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IdentifierTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"as\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"identifier\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentifierTransform {
    #[serde(rename = "as")]
    pub as_: IdentifierTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: IdentifierTransformType,
}
impl From<&Self> for IdentifierTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "IdentifierTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IdentifierTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for IdentifierTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for IdentifierTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IdentifierTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"identifier\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IdentifierTransformType {
    #[serde(rename = "identifier")]
    Identifier,
}
impl From<&Self> for IdentifierTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for IdentifierTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Identifier => "identifier".to_string(),
        }
    }
}
impl std::str::FromStr for IdentifierTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "identifier" => Ok(Self::Identifier),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IdentifierTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ImputeTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"key\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"keyvals\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {}"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"value\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"value\","]
#[doc = "            \"mean\","]
#[doc = "            \"median\","]
#[doc = "            \"max\","]
#[doc = "            \"min\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"impute\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"value\": {}"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ImputeTransform {
    pub field: ImputeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<ImputeTransformGroupby>,
    pub key: ImputeTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keyvals: Option<ImputeTransformKeyvals>,
    #[serde(default = "defaults::impute_transform_method")]
    pub method: ImputeTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ImputeTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub value: Option<serde_json::Value>,
}
impl From<&Self> for ImputeTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ImputeTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ImputeTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ImputeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ImputeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ImputeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ImputeTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformGroupby {
    Variant0(Vec<ImputeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ImputeTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ImputeTransformGroupbyVariant0Item>> for ImputeTransformGroupby {
    fn from(value: Vec<ImputeTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ImputeTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ImputeTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ImputeTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ImputeTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ImputeTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ImputeTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ImputeTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ImputeTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ImputeTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ImputeTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ImputeTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ImputeTransformKeyvals"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {}"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformKeyvals {
    Variant0(Vec<serde_json::Value>),
    Variant1(SignalRef),
}
impl From<&Self> for ImputeTransformKeyvals {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ImputeTransformKeyvals {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ImputeTransformKeyvals {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ImputeTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"value\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"value\","]
#[doc = "        \"mean\","]
#[doc = "        \"median\","]
#[doc = "        \"max\","]
#[doc = "        \"min\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ImputeTransformMethod {
    Variant0(ImputeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for ImputeTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for ImputeTransformMethod {
    fn default() -> Self {
        Self::Variant0(ImputeTransformMethodVariant0::Value)
    }
}
impl From<ImputeTransformMethodVariant0> for ImputeTransformMethod {
    fn from(value: ImputeTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ImputeTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ImputeTransformMethodVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"value\","]
#[doc = "    \"mean\","]
#[doc = "    \"median\","]
#[doc = "    \"max\","]
#[doc = "    \"min\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ImputeTransformMethodVariant0 {
    #[serde(rename = "value")]
    Value,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "min")]
    Min,
}
impl From<&Self> for ImputeTransformMethodVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ImputeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Value => "value".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Median => "median".to_string(),
            Self::Max => "max".to_string(),
            Self::Min => "min".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "value" => Ok(Self::Value),
            "mean" => Ok(Self::Mean),
            "median" => Ok(Self::Median),
            "max" => Ok(Self::Max),
            "min" => Ok(Self::Min),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ImputeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ImputeTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"impute\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ImputeTransformType {
    #[serde(rename = "impute")]
    Impute,
}
impl From<&Self> for ImputeTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ImputeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Impute => "impute".to_string(),
        }
    }
}
impl std::str::FromStr for ImputeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "impute" => Ok(Self::Impute),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ImputeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IsocontourTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"contour\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"levels\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nice\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"smooth\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"thresholds\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"isocontour\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"zero\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IsocontourTransform {
    #[serde(rename = "as", default = "defaults::isocontour_transform_as")]
    pub as_: IsocontourTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<IsocontourTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub levels: Option<IsocontourTransformLevels>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub nice: Option<IsocontourTransformNice>,
    #[serde(default = "defaults::isocontour_transform_resolve")]
    pub resolve: IsocontourTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<IsocontourTransformScale>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::isocontour_transform_smooth")]
    pub smooth: IsocontourTransformSmooth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub thresholds: Option<IsocontourTransformThresholds>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<IsocontourTransformTranslate>,
    #[serde(rename = "type")]
    pub type_: IsocontourTransformType,
    #[serde(default = "defaults::isocontour_transform_zero")]
    pub zero: IsocontourTransformZero,
}
impl From<&Self> for IsocontourTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "IsocontourTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"contour\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformAs {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for IsocontourTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformAs {
    fn default() -> Self {
        Self::Variant0("contour".to_string())
    }
}
impl From<SignalRef> for IsocontourTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for IsocontourTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for IsocontourTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for IsocontourTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for IsocontourTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "IsocontourTransformLevels"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformLevels {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformLevels {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for IsocontourTransformLevels {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformLevels {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformNice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformNice {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformNice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for IsocontourTransformNice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformNice {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformResolve"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformResolve {
    Variant0(IsocontourTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformResolve {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformResolve {
    fn default() -> Self {
        Self::Variant0(IsocontourTransformResolveVariant0::Independent)
    }
}
impl From<IsocontourTransformResolveVariant0> for IsocontourTransformResolve {
    fn from(value: IsocontourTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformResolveVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IsocontourTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&Self> for IsocontourTransformResolveVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for IsocontourTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IsocontourTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IsocontourTransformScale"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformScale {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for IsocontourTransformScale {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for IsocontourTransformScale {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformScale {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for IsocontourTransformScale {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for IsocontourTransformScale {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "IsocontourTransformSmooth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformSmooth {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformSmooth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformSmooth {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for IsocontourTransformSmooth {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformSmooth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformThresholds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformThresholds {
    Variant0(Vec<IsocontourTransformThresholdsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformThresholds {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<IsocontourTransformThresholdsVariant0Item>> for IsocontourTransformThresholds {
    fn from(value: Vec<IsocontourTransformThresholdsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformThresholds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformThresholdsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformThresholdsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformThresholdsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformTranslate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformTranslate {
    Variant0(Vec<IsocontourTransformTranslateVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformTranslate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<IsocontourTransformTranslateVariant0Item>> for IsocontourTransformTranslate {
    fn from(value: Vec<IsocontourTransformTranslateVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformTranslate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "IsocontourTransformTranslateVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformTranslateVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for IsocontourTransformTranslateVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for IsocontourTransformTranslateVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformTranslateVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for IsocontourTransformTranslateVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for IsocontourTransformTranslateVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "IsocontourTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"isocontour\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum IsocontourTransformType {
    #[serde(rename = "isocontour")]
    Isocontour,
}
impl From<&Self> for IsocontourTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for IsocontourTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Isocontour => "isocontour".to_string(),
        }
    }
}
impl std::str::FromStr for IsocontourTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "isocontour" => Ok(Self::Isocontour),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for IsocontourTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "IsocontourTransformZero"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum IsocontourTransformZero {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for IsocontourTransformZero {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for IsocontourTransformZero {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for IsocontourTransformZero {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for IsocontourTransformZero {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"joinaggregate\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct JoinaggregateTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<JoinaggregateTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<JoinaggregateTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<JoinaggregateTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<JoinaggregateTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<JoinaggregateTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: JoinaggregateTransformType,
}
impl From<&Self> for JoinaggregateTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "JoinaggregateTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformAs {
    Variant0(Vec<JoinaggregateTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for JoinaggregateTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<JoinaggregateTransformAsVariant0Item>> for JoinaggregateTransformAs {
    fn from(value: Vec<JoinaggregateTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for JoinaggregateTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for JoinaggregateTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for JoinaggregateTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformFields {
    Variant0(Vec<JoinaggregateTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for JoinaggregateTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<JoinaggregateTransformFieldsVariant0Item>> for JoinaggregateTransformFields {
    fn from(value: Vec<JoinaggregateTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for JoinaggregateTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&Self> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl From<ParamField> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for JoinaggregateTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "JoinaggregateTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupby {
    Variant0(Vec<JoinaggregateTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for JoinaggregateTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<JoinaggregateTransformGroupbyVariant0Item>> for JoinaggregateTransformGroupby {
    fn from(value: Vec<JoinaggregateTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for JoinaggregateTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for JoinaggregateTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "JoinaggregateTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for JoinaggregateTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for JoinaggregateTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for JoinaggregateTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for JoinaggregateTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "JoinaggregateTransformOps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformOps {
    Variant0(Vec<JoinaggregateTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for JoinaggregateTransformOps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<JoinaggregateTransformOpsVariant0Item>> for JoinaggregateTransformOps {
    fn from(value: Vec<JoinaggregateTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for JoinaggregateTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformOpsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum JoinaggregateTransformOpsVariant0Item {
    Variant0(JoinaggregateTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<JoinaggregateTransformOpsVariant0ItemVariant0> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: JoinaggregateTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for JoinaggregateTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "JoinaggregateTransformOpsVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum JoinaggregateTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&Self> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for JoinaggregateTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for JoinaggregateTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "JoinaggregateTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"joinaggregate\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum JoinaggregateTransformType {
    #[serde(rename = "joinaggregate")]
    Joinaggregate,
}
impl From<&Self> for JoinaggregateTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for JoinaggregateTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Joinaggregate => "joinaggregate".to_string(),
        }
    }
}
impl std::str::FromStr for JoinaggregateTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "joinaggregate" => Ok(Self::Joinaggregate),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for JoinaggregateTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Kde2dTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"grid\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cellSize\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"counts\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"kde2d\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"weight\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct Kde2dTransform {
    #[serde(rename = "as", default = "defaults::kde2d_transform_as")]
    pub as_: Kde2dTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<Kde2dTransformBandwidth>,
    #[serde(rename = "cellSize", default, skip_serializing_if = "Option::is_none")]
    pub cell_size: Option<Kde2dTransformCellSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<Kde2dTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<Kde2dTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: Kde2dTransformSize,
    #[serde(rename = "type")]
    pub type_: Kde2dTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub weight: Option<Kde2dTransformWeight>,
    pub x: Kde2dTransformX,
    pub y: Kde2dTransformY,
}
impl From<&Self> for Kde2dTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "Kde2dTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"grid\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for Kde2dTransformAs {
    fn default() -> Self {
        Self::Variant0("grid".to_string())
    }
}
impl From<SignalRef> for Kde2dTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformBandwidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidth {
    Variant0([Kde2dTransformBandwidthVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformBandwidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[Kde2dTransformBandwidthVariant0Item; 2usize]> for Kde2dTransformBandwidth {
    fn from(value: [Kde2dTransformBandwidthVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformBandwidthVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformBandwidthVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformBandwidthVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformCellSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformCellSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformCellSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for Kde2dTransformCellSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformCellSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformCounts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformCounts {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for Kde2dTransformCounts {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformCounts {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformGroupby {
    Variant0(Vec<Kde2dTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<Kde2dTransformGroupbyVariant0Item>> for Kde2dTransformGroupby {
    fn from(value: Vec<Kde2dTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for Kde2dTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "Kde2dTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformSize {
    Variant0([Kde2dTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[Kde2dTransformSizeVariant0Item; 2usize]> for Kde2dTransformSize {
    fn from(value: [Kde2dTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for Kde2dTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for Kde2dTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Kde2dTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Kde2dTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"kde2d\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum Kde2dTransformType {
    #[serde(rename = "kde2d")]
    Kde2d,
}
impl From<&Self> for Kde2dTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for Kde2dTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde2d => "kde2d".to_string(),
        }
    }
}
impl std::str::FromStr for Kde2dTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "kde2d" => Ok(Self::Kde2d),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for Kde2dTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Kde2dTransformWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformWeight {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for Kde2dTransformWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for Kde2dTransformWeight {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for Kde2dTransformWeight {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for Kde2dTransformWeight {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "Kde2dTransformX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for Kde2dTransformX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for Kde2dTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for Kde2dTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for Kde2dTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "Kde2dTransformY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Kde2dTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for Kde2dTransformY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for Kde2dTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for Kde2dTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for Kde2dTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "KdeTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"value\","]
#[doc = "        \"density\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"counts\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cumulative\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxsteps\": {"]
#[doc = "      \"default\": 200,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"minsteps\": {"]
#[doc = "      \"default\": 25,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"resolve\": {"]
#[doc = "      \"default\": \"independent\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"shared\","]
#[doc = "            \"independent\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"steps\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"kde\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct KdeTransform {
    #[serde(rename = "as", default = "defaults::kde_transform_as")]
    pub as_: KdeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub bandwidth: Option<KdeTransformBandwidth>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub counts: Option<KdeTransformCounts>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub cumulative: Option<KdeTransformCumulative>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<KdeTransformExtent>,
    pub field: KdeTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<KdeTransformGroupby>,
    #[serde(default = "defaults::kde_transform_maxsteps")]
    pub maxsteps: KdeTransformMaxsteps,
    #[serde(default = "defaults::kde_transform_minsteps")]
    pub minsteps: KdeTransformMinsteps,
    #[serde(default = "defaults::kde_transform_resolve")]
    pub resolve: KdeTransformResolve,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub steps: Option<KdeTransformSteps>,
    #[serde(rename = "type")]
    pub type_: KdeTransformType,
}
impl From<&Self> for KdeTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "KdeTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"value\","]
#[doc = "    \"density\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformAs {
    Variant0(Vec<KdeTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformAs {
    fn default() -> Self {
        Self::Variant0(vec![
            KdeTransformAsVariant0Item::Variant0("value".to_string()),
            KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
}
impl From<Vec<KdeTransformAsVariant0Item>> for KdeTransformAs {
    fn from(value: Vec<KdeTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for KdeTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformBandwidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformBandwidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for KdeTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformCounts"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformCounts {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformCounts {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for KdeTransformCounts {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformCounts {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformCumulative"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformCumulative {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformCumulative {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for KdeTransformCumulative {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformCumulative {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformExtent {
    Variant0([KdeTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[KdeTransformExtentVariant0Item; 2usize]> for KdeTransformExtent {
    fn from(value: [KdeTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for KdeTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for KdeTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for KdeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for KdeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for KdeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "KdeTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformGroupby {
    Variant0(Vec<KdeTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<KdeTransformGroupbyVariant0Item>> for KdeTransformGroupby {
    fn from(value: Vec<KdeTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for KdeTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for KdeTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for KdeTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for KdeTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "KdeTransformMaxsteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 200,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformMaxsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformMaxsteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformMaxsteps {
    fn default() -> Self {
        Self::Variant0(200_f64)
    }
}
impl From<f64> for KdeTransformMaxsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformMaxsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformMinsteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 25,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformMinsteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformMinsteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformMinsteps {
    fn default() -> Self {
        Self::Variant0(25_f64)
    }
}
impl From<f64> for KdeTransformMinsteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformMinsteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformResolve"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"independent\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"shared\","]
#[doc = "        \"independent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformResolve {
    Variant0(KdeTransformResolveVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformResolve {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for KdeTransformResolve {
    fn default() -> Self {
        Self::Variant0(KdeTransformResolveVariant0::Independent)
    }
}
impl From<KdeTransformResolveVariant0> for KdeTransformResolve {
    fn from(value: KdeTransformResolveVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformResolve {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformResolveVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"shared\","]
#[doc = "    \"independent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum KdeTransformResolveVariant0 {
    #[serde(rename = "shared")]
    Shared,
    #[serde(rename = "independent")]
    Independent,
}
impl From<&Self> for KdeTransformResolveVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for KdeTransformResolveVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Shared => "shared".to_string(),
            Self::Independent => "independent".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformResolveVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "shared" => Ok(Self::Shared),
            "independent" => Ok(Self::Independent),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for KdeTransformResolveVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "KdeTransformSteps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum KdeTransformSteps {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for KdeTransformSteps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for KdeTransformSteps {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for KdeTransformSteps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "KdeTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"kde\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum KdeTransformType {
    #[serde(rename = "kde")]
    Kde,
}
impl From<&Self> for KdeTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for KdeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Kde => "kde".to_string(),
        }
    }
}
impl std::str::FromStr for KdeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "kde" => Ok(Self::Kde),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for KdeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LabelOverlap"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"parity\","]
#[doc = "        \"greedy\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelOverlap {
    Variant0(bool),
    Variant1(LabelOverlapVariant1),
    Variant2(SignalRef),
}
impl From<&Self> for LabelOverlap {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for LabelOverlap {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<LabelOverlapVariant1> for LabelOverlap {
    fn from(value: LabelOverlapVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for LabelOverlap {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LabelOverlapVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"parity\","]
#[doc = "    \"greedy\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelOverlapVariant1 {
    #[serde(rename = "parity")]
    Parity,
    #[serde(rename = "greedy")]
    Greedy,
}
impl From<&Self> for LabelOverlapVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LabelOverlapVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Parity => "parity".to_string(),
            Self::Greedy => "greedy".to_string(),
        }
    }
}
impl std::str::FromStr for LabelOverlapVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "parity" => Ok(Self::Parity),
            "greedy" => Ok(Self::Greedy),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelOverlapVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LabelTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"size\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"anchor\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"top-left\","]
#[doc = "        \"left\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-right\","]
#[doc = "        \"right\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"opacity\","]
#[doc = "        \"align\","]
#[doc = "        \"baseline\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 5,"]
#[doc = "          \"minItems\": 5"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"avoidBaseMark\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"avoidMarks\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"lineAnchor\": {"]
#[doc = "      \"default\": \"end\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"markIndex\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"naive\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"default\": ["]
#[doc = "        1"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"label\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LabelTransform {
    #[serde(default = "defaults::label_transform_anchor")]
    pub anchor: LabelTransformAnchor,
    #[serde(rename = "as", default = "defaults::label_transform_as")]
    pub as_: LabelTransformAs,
    #[serde(
        rename = "avoidBaseMark",
        default = "defaults::label_transform_avoid_base_mark"
    )]
    pub avoid_base_mark: LabelTransformAvoidBaseMark,
    #[serde(
        rename = "avoidMarks",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub avoid_marks: Option<LabelTransformAvoidMarks>,
    #[serde(
        rename = "lineAnchor",
        default = "defaults::label_transform_line_anchor"
    )]
    pub line_anchor: LabelTransformLineAnchor,
    #[serde(rename = "markIndex", default, skip_serializing_if = "Option::is_none")]
    pub mark_index: Option<LabelTransformMarkIndex>,
    #[serde(default = "defaults::label_transform_method")]
    pub method: LabelTransformMethod,
    #[serde(default = "defaults::label_transform_offset")]
    pub offset: LabelTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<LabelTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub size: LabelTransformSize,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: LabelTransformType,
}
impl From<&Self> for LabelTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LabelTransformAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"top-left\","]
#[doc = "    \"left\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-right\","]
#[doc = "    \"right\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAnchor {
    Variant0(Vec<LabelTransformAnchorVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAnchor {
    fn default() -> Self {
        Self::Variant0(vec![
            LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
}
impl From<Vec<LabelTransformAnchorVariant0Item>> for LabelTransformAnchor {
    fn from(value: Vec<LabelTransformAnchorVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformAnchorVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAnchorVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAnchorVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LabelTransformAnchorVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"opacity\","]
#[doc = "    \"align\","]
#[doc = "    \"baseline\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 5,"]
#[doc = "      \"minItems\": 5"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAs {
    Variant0([LabelTransformAsVariant0Item; 5usize]),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAs {
    fn default() -> Self {
        Self::Variant0([
            LabelTransformAsVariant0Item::Variant0("x".to_string()),
            LabelTransformAsVariant0Item::Variant0("y".to_string()),
            LabelTransformAsVariant0Item::Variant0("opacity".to_string()),
            LabelTransformAsVariant0Item::Variant0("align".to_string()),
            LabelTransformAsVariant0Item::Variant0("baseline".to_string()),
        ])
    }
}
impl From<[LabelTransformAsVariant0Item; 5usize]> for LabelTransformAs {
    fn from(value: [LabelTransformAsVariant0Item; 5usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LabelTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformAvoidBaseMark"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAvoidBaseMark {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAvoidBaseMark {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformAvoidBaseMark {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for LabelTransformAvoidBaseMark {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformAvoidBaseMark {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformAvoidMarks"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformAvoidMarks {
    Variant0(Vec<String>),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformAvoidMarks {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for LabelTransformAvoidMarks {
    fn from(value: Vec<String>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformAvoidMarks {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformLineAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"end\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformLineAnchor {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformLineAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformLineAnchor {
    fn default() -> Self {
        Self::Variant0("end".to_string())
    }
}
impl From<SignalRef> for LabelTransformLineAnchor {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformMarkIndex"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformMarkIndex {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformMarkIndex {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LabelTransformMarkIndex {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformMarkIndex {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"naive\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformMethod {
    fn default() -> Self {
        Self::Variant0("naive".to_string())
    }
}
impl From<SignalRef> for LabelTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    1"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformOffset {
    Variant0(Vec<LabelTransformOffsetVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LabelTransformOffset {
    fn default() -> Self {
        Self::Variant0(vec![LabelTransformOffsetVariant0Item::Variant0(1_f64)])
    }
}
impl From<Vec<LabelTransformOffsetVariant0Item>> for LabelTransformOffset {
    fn from(value: Vec<LabelTransformOffsetVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformOffset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformOffsetVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformOffsetVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformOffsetVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LabelTransformOffsetVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformOffsetVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for LabelTransformPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LabelTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformSize {
    Variant0([LabelTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[LabelTransformSizeVariant0Item; 2usize]> for LabelTransformSize {
    fn from(value: [LabelTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LabelTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for LabelTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LabelTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LabelTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LabelTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"label\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LabelTransformType {
    #[serde(rename = "label")]
    Label,
}
impl From<&Self> for LabelTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LabelTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Label => "label".to_string(),
        }
    }
}
impl std::str::FromStr for LabelTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "label" => Ok(Self::Label),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LabelTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Layout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"all\","]
#[doc = "                    \"each\","]
#[doc = "                    \"none\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"all\","]
#[doc = "                        \"each\","]
#[doc = "                        \"none\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"all\","]
#[doc = "                        \"each\","]
#[doc = "                        \"none\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"bounds\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"full\","]
#[doc = "                \"flush\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"center\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"columns\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"footerBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"headerBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"columnFooter\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"columnHeader\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"columnTitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowFooter\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowHeader\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"rowTitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleAnchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"start\","]
#[doc = "                    \"end\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"start\","]
#[doc = "                        \"end\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleBand\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"column\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"row\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Layout {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<LayoutVariant0Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bounds: Option<LayoutVariant0Bounds>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        center: Option<LayoutVariant0Center>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "footerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        footer_band: Option<LayoutVariant0FooterBand>,
        #[serde(
            rename = "headerBand",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        header_band: Option<LayoutVariant0HeaderBand>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LayoutVariant0Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LayoutVariant0Padding>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LayoutVariant0TitleAnchor>,
        #[serde(rename = "titleBand", default, skip_serializing_if = "Option::is_none")]
        title_band: Option<LayoutVariant0TitleBand>,
    },
    Variant1(SignalRef),
}
impl From<&Self> for Layout {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for Layout {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0Align"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"all\","]
#[doc = "            \"each\","]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Align {
    Variant0(LayoutVariant0AlignVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0AlignVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0AlignVariant1Row>,
    },
}
impl From<&Self> for LayoutVariant0Align {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0AlignVariant0> for LayoutVariant0Align {
    fn from(value: LayoutVariant0AlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "LayoutVariant0AlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant0 {
    Variant0(LayoutVariant0AlignVariant0Variant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0AlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0AlignVariant0Variant0> for LayoutVariant0AlignVariant0 {
    fn from(value: LayoutVariant0AlignVariant0Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0AlignVariant0 {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0AlignVariant0Variant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant0Variant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LayoutVariant0AlignVariant0Variant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant0Variant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0AlignVariant1Column"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Column {
    Variant0(LayoutVariant0AlignVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0AlignVariant1Column {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0AlignVariant1ColumnVariant0> for LayoutVariant0AlignVariant1Column {
    fn from(value: LayoutVariant0AlignVariant1ColumnVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0AlignVariant1Column {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0AlignVariant1ColumnVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant1ColumnVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0AlignVariant1Row"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0AlignVariant1Row {
    Variant0(LayoutVariant0AlignVariant1RowVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0AlignVariant1Row {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0AlignVariant1RowVariant0> for LayoutVariant0AlignVariant1Row {
    fn from(value: LayoutVariant0AlignVariant1RowVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0AlignVariant1Row {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0AlignVariant1RowVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0AlignVariant1RowVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LayoutVariant0AlignVariant1RowVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0AlignVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0AlignVariant1RowVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0AlignVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0Bounds"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"full\","]
#[doc = "        \"flush\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0Bounds {
    Variant0(LayoutVariant0BoundsVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0Bounds {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0BoundsVariant0> for LayoutVariant0Bounds {
    fn from(value: LayoutVariant0BoundsVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0Bounds {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0BoundsVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"full\","]
#[doc = "    \"flush\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0BoundsVariant0 {
    #[serde(rename = "full")]
    Full,
    #[serde(rename = "flush")]
    Flush,
}
impl From<&Self> for LayoutVariant0BoundsVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0BoundsVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Full => "full".to_string(),
            Self::Flush => "flush".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0BoundsVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "full" => Ok(Self::Full),
            "flush" => Ok(Self::Flush),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0BoundsVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0Center"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Center {
    Variant0(bool),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<BooleanOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0Center {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for LayoutVariant0Center {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0Center {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0FooterBand"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0FooterBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0FooterBand {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<NumberOrSignal> for LayoutVariant0FooterBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "LayoutVariant0HeaderBand"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0HeaderBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0HeaderBand {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<NumberOrSignal> for LayoutVariant0HeaderBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "LayoutVariant0Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"columnFooter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnHeader\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnTitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowFooter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowHeader\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"rowTitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Offset {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(
            rename = "columnFooter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_footer: Option<NumberOrSignal>,
        #[serde(
            rename = "columnHeader",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_header: Option<NumberOrSignal>,
        #[serde(
            rename = "columnTitle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_title: Option<NumberOrSignal>,
        #[serde(rename = "rowFooter", default, skip_serializing_if = "Option::is_none")]
        row_footer: Option<NumberOrSignal>,
        #[serde(rename = "rowHeader", default, skip_serializing_if = "Option::is_none")]
        row_header: Option<NumberOrSignal>,
        #[serde(rename = "rowTitle", default, skip_serializing_if = "Option::is_none")]
        row_title: Option<NumberOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LayoutVariant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0Offset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0Padding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LayoutVariant0Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0Padding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"start\","]
#[doc = "            \"end\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"start\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleAnchor {
    Variant0(LayoutVariant0TitleAnchorVariant0),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<LayoutVariant0TitleAnchorVariant1Column>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<LayoutVariant0TitleAnchorVariant1Row>,
    },
}
impl From<&Self> for LayoutVariant0TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0TitleAnchorVariant0> for LayoutVariant0TitleAnchor {
    fn from(value: LayoutVariant0TitleAnchorVariant0) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant0 {
    Variant0(LayoutVariant0TitleAnchorVariant0Variant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0TitleAnchorVariant0Variant0> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: LayoutVariant0TitleAnchorVariant0Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0TitleAnchorVariant0 {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant0Variant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant0Variant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant0Variant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant0Variant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant1Column"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Column {
    Variant0(LayoutVariant0TitleAnchorVariant1ColumnVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant1Column {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0TitleAnchorVariant1ColumnVariant0>
    for LayoutVariant0TitleAnchorVariant1Column
{
    fn from(value: LayoutVariant0TitleAnchorVariant1ColumnVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0TitleAnchorVariant1Column {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant1ColumnVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant1ColumnVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant1Row"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"start\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LayoutVariant0TitleAnchorVariant1Row {
    Variant0(LayoutVariant0TitleAnchorVariant1RowVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LayoutVariant0TitleAnchorVariant1RowVariant0> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: LayoutVariant0TitleAnchorVariant1RowVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LayoutVariant0TitleAnchorVariant1Row {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LayoutVariant0TitleAnchorVariant1RowVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"start\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LayoutVariant0TitleAnchorVariant1RowVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LayoutVariant0TitleAnchorVariant1RowVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LayoutVariant0TitleBand"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"column\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"row\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LayoutVariant0TitleBand {
    Variant0(NumberOrSignal),
    Variant1,
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        column: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        row: Option<NumberOrSignal>,
    },
}
impl From<&Self> for LayoutVariant0TitleBand {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<NumberOrSignal> for LayoutVariant0TitleBand {
    fn from(value: NumberOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "Legend"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"aria\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"clipHeight\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columnPadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"columns\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"cornerRadius\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"direction\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"vertical\","]
#[doc = "            \"horizontal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"encode\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"entries\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"gradient\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"labels\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"legend\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"symbols\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            },"]
#[doc = "            \"title\": {"]
#[doc = "              \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        \"fill\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fillColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"format\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"date\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"day\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"hours\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"milliseconds\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"minutes\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"month\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"quarter\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"seconds\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"week\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"year\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"formatType\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"number\","]
#[doc = "                \"time\","]
#[doc = "                \"utc\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientLength\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"gradientOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientStrokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientStrokeWidth\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"gradientThickness\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"gridAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"all\","]
#[doc = "                \"each\","]
#[doc = "                \"none\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelBaseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelLimit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"labelOverlap\": {"]
#[doc = "          \"$ref\": \"#/definitions/labelOverlap\""]
#[doc = "        },"]
#[doc = "        \"labelSeparation\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"legendX\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"legendY\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"opacity\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"orient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"default\": \"right\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\","]
#[doc = "                \"top-left\","]
#[doc = "                \"top-right\","]
#[doc = "                \"bottom-left\","]
#[doc = "                \"bottom-right\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"rowPadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"shape\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"size\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"stroke\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"strokeDash\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"strokeWidth\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"symbolDash\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolDashOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolFillColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolLimit\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"symbolOffset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolStrokeColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolStrokeWidth\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"symbolType\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"tickCount\": {"]
#[doc = "          \"$ref\": \"#/definitions/tickCount\""]
#[doc = "        },"]
#[doc = "        \"tickMinStep\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"titleAlign\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleAnchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleBaseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleLimit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleLineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleOpacity\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titleOrient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/orientValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"titlePadding\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"gradient\","]
#[doc = "            \"symbol\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"values\": {"]
#[doc = "          \"$ref\": \"#/definitions/arrayOrSignal\""]
#[doc = "        },"]
#[doc = "        \"zindex\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"size\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"shape\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"fill\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stroke\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"opacity\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"strokeDash\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"strokeWidth\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Legend {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant0CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant0Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant0Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant0FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant0Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant0FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant0GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant0GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant0GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant0GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant0LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant0LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant0LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant0LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant0LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant0LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant0LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant0LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant0LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant0LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant0LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant0LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant0Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant0Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant0Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        size: String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant0StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant0SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant0SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant0SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant0SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant0SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant0SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant0SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant0SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant0SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant0TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant0TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant0TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant0TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant0TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant0TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant0TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant0TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant0TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant0TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant0TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant0TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant0TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant0Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant1CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant1Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant1Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant1FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant1Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant1FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant1GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant1GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant1GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant1GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant1LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant1LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant1LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant1LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant1LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant1LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant1LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant1LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant1LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant1LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant1LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant1LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant1Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant1Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant1Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        shape: String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant1StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant1SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant1SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant1SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant1SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant1SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant1SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant1SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant1SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant1SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant1TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant1TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant1TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant1TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant1TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant1TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant1TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant1TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant1TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant1TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant1TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant1TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant1TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant1Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant2CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant2Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant2Encode>,
        fill: String,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant2FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant2Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant2FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant2GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant2GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant2GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant2GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant2LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant2LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant2LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant2LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant2LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant2LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant2LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant2LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant2LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant2LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant2LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant2LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant2Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant2Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant2Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant2StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant2SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant2SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant2SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant2SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant2SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant2SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant2SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant2SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant2SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant2TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant2TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant2TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant2TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant2TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant2TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant2TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant2TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant2TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant2TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant2TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant2TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant2TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant2Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant3CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant3Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant3Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant3FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant3Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant3FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant3GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant3GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant3GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant3GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant3LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant3LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant3LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant3LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant3LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant3LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant3LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant3LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant3LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant3LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant3LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant3LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant3Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant3Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant3Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        stroke: String,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant3StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant3SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant3SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant3SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant3SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant3SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant3SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant3SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant3SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant3SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant3TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant3TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant3TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant3TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant3TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant3TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant3TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant3TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant3TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant3TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant3TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant3TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant3TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant3Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant4CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant4Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant4Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant4FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant4Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant4FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant4GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant4GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant4GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant4GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant4LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant4LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant4LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant4LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant4LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant4LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant4LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant4LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant4LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant4LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant4LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant4LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant4Offset>,
        opacity: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant4Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant4Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant4StrokeColor>,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant4SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant4SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant4SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant4SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant4SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant4SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant4SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant4SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant4SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant4TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant4TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant4TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant4TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant4TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant4TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant4TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant4TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant4TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant4TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant4TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant4TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant4TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant4Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant5CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant5Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant5Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant5FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant5Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant5FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant5GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant5GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant5GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant5GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant5LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant5LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant5LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant5LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant5LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant5LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant5LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant5LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant5LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant5LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant5LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant5LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant5Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant5Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant5Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant5StrokeColor>,
        #[serde(rename = "strokeDash")]
        stroke_dash: String,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant5SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant5SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant5SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant5SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant5SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant5SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant5SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant5SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant5SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant5TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant5TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant5TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant5TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant5TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant5TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant5TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant5TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant5TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant5TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant5TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant5TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant5TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant5Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(
            rename = "clipHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        clip_height: Option<NumberOrSignal>,
        #[serde(
            rename = "columnPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        column_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        columns: Option<NumberOrSignal>,
        #[serde(
            rename = "cornerRadius",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        corner_radius: Option<LegendVariant6CornerRadius>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        direction: Option<LegendVariant6Direction>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<LegendVariant6Encode>,
        #[serde(rename = "fillColor", default, skip_serializing_if = "Option::is_none")]
        fill_color: Option<LegendVariant6FillColor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        format: Option<LegendVariant6Format>,
        #[serde(
            rename = "formatType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        format_type: Option<LegendVariant6FormatType>,
        #[serde(
            rename = "gradientLength",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_length: Option<NumberOrSignal>,
        #[serde(
            rename = "gradientOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_opacity: Option<LegendVariant6GradientOpacity>,
        #[serde(
            rename = "gradientStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_color: Option<LegendVariant6GradientStrokeColor>,
        #[serde(
            rename = "gradientStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_stroke_width: Option<LegendVariant6GradientStrokeWidth>,
        #[serde(
            rename = "gradientThickness",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        gradient_thickness: Option<NumberOrSignal>,
        #[serde(rename = "gridAlign", default, skip_serializing_if = "Option::is_none")]
        grid_align: Option<LegendVariant6GridAlign>,
        #[serde(
            rename = "labelAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_align: Option<LegendVariant6LabelAlign>,
        #[serde(
            rename = "labelBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_baseline: Option<LegendVariant6LabelBaseline>,
        #[serde(
            rename = "labelColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_color: Option<LegendVariant6LabelColor>,
        #[serde(rename = "labelFont", default, skip_serializing_if = "Option::is_none")]
        label_font: Option<LegendVariant6LabelFont>,
        #[serde(
            rename = "labelFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_size: Option<LegendVariant6LabelFontSize>,
        #[serde(
            rename = "labelFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_style: Option<LegendVariant6LabelFontStyle>,
        #[serde(
            rename = "labelFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_font_weight: Option<LegendVariant6LabelFontWeight>,
        #[serde(
            rename = "labelLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_limit: Option<LegendVariant6LabelLimit>,
        #[serde(
            rename = "labelOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_offset: Option<LegendVariant6LabelOffset>,
        #[serde(
            rename = "labelOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_opacity: Option<LegendVariant6LabelOpacity>,
        #[serde(
            rename = "labelOverlap",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_overlap: Option<LabelOverlap>,
        #[serde(
            rename = "labelSeparation",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        label_separation: Option<NumberOrSignal>,
        #[serde(rename = "legendX", default, skip_serializing_if = "Option::is_none")]
        legend_x: Option<LegendVariant6LegendX>,
        #[serde(rename = "legendY", default, skip_serializing_if = "Option::is_none")]
        legend_y: Option<LegendVariant6LegendY>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<LegendVariant6Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<LegendVariant6Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<LegendVariant6Padding>,
        #[serde(
            rename = "rowPadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        row_padding: Option<NumberOrSignal>,
        #[serde(
            rename = "strokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        stroke_color: Option<LegendVariant6StrokeColor>,
        #[serde(rename = "strokeWidth")]
        stroke_width: String,
        #[serde(
            rename = "symbolDash",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash: Option<LegendVariant6SymbolDash>,
        #[serde(
            rename = "symbolDashOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_dash_offset: Option<LegendVariant6SymbolDashOffset>,
        #[serde(
            rename = "symbolFillColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_fill_color: Option<LegendVariant6SymbolFillColor>,
        #[serde(
            rename = "symbolLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_limit: Option<NumberOrSignal>,
        #[serde(
            rename = "symbolOffset",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_offset: Option<LegendVariant6SymbolOffset>,
        #[serde(
            rename = "symbolOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_opacity: Option<LegendVariant6SymbolOpacity>,
        #[serde(
            rename = "symbolSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_size: Option<LegendVariant6SymbolSize>,
        #[serde(
            rename = "symbolStrokeColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_color: Option<LegendVariant6SymbolStrokeColor>,
        #[serde(
            rename = "symbolStrokeWidth",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_stroke_width: Option<LegendVariant6SymbolStrokeWidth>,
        #[serde(
            rename = "symbolType",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        symbol_type: Option<LegendVariant6SymbolType>,
        #[serde(rename = "tickCount", default, skip_serializing_if = "Option::is_none")]
        tick_count: Option<TickCount>,
        #[serde(
            rename = "tickMinStep",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        tick_min_step: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        title: Option<TextOrSignal>,
        #[serde(
            rename = "titleAlign",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_align: Option<LegendVariant6TitleAlign>,
        #[serde(
            rename = "titleAnchor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_anchor: Option<LegendVariant6TitleAnchor>,
        #[serde(
            rename = "titleBaseline",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_baseline: Option<LegendVariant6TitleBaseline>,
        #[serde(
            rename = "titleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_color: Option<LegendVariant6TitleColor>,
        #[serde(rename = "titleFont", default, skip_serializing_if = "Option::is_none")]
        title_font: Option<LegendVariant6TitleFont>,
        #[serde(
            rename = "titleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_size: Option<LegendVariant6TitleFontSize>,
        #[serde(
            rename = "titleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_style: Option<LegendVariant6TitleFontStyle>,
        #[serde(
            rename = "titleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_font_weight: Option<LegendVariant6TitleFontWeight>,
        #[serde(
            rename = "titleLimit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_limit: Option<LegendVariant6TitleLimit>,
        #[serde(
            rename = "titleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_line_height: Option<LegendVariant6TitleLineHeight>,
        #[serde(
            rename = "titleOpacity",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_opacity: Option<LegendVariant6TitleOpacity>,
        #[serde(
            rename = "titleOrient",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_orient: Option<LegendVariant6TitleOrient>,
        #[serde(
            rename = "titlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        title_padding: Option<LegendVariant6TitlePadding>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<LegendVariant6Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        values: Option<ArrayOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
}
impl From<&Self> for Legend {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant0CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant0Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant0Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant0Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant0FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant0Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant0Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant0Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0FormatType {
    Variant0(LegendVariant0FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant0FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0FormatTypeVariant0> for LegendVariant0FormatType {
    fn from(value: LegendVariant0FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant0FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant0FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0GridAlign {
    Variant0(LegendVariant0GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant0GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0GridAlignVariant0> for LegendVariant0GridAlign {
    fn from(value: LegendVariant0GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant0GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant0GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelAlign {
    Variant0(LegendVariant0LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant0LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0LabelAlignVariant0> for LegendVariant0LabelAlign {
    fn from(value: LegendVariant0LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant0LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant0LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelBaseline {
    Variant0(LegendVariant0LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant0LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0LabelBaselineVariant0> for LegendVariant0LabelBaseline {
    fn from(value: LegendVariant0LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant0LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant0LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant0LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant0LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant0LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant0LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant0LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant0LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant0LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0Orient {
    Variant0(LegendVariant0OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant0Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0OrientVariant0> for LegendVariant0Orient {
    fn from(value: LegendVariant0OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant0Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant0OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant0SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant0SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant0SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant0SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant0SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleAlign {
    Variant0(LegendVariant0TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant0TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0TitleAlignVariant0> for LegendVariant0TitleAlign {
    fn from(value: LegendVariant0TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant0TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant0TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleAnchor {
    Variant0(Option<LegendVariant0TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant0TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant0TitleAnchorVariant0>> for LegendVariant0TitleAnchor {
    fn from(value: Option<LegendVariant0TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant0TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant0TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleBaseline {
    Variant0(LegendVariant0TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant0TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0TitleBaselineVariant0> for LegendVariant0TitleBaseline {
    fn from(value: LegendVariant0TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant0TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant0TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant0TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant0TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant0TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant0TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant0TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant0TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant0TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant0TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant0TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant0TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitleOrient {
    Variant0(LegendVariant0TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant0TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant0TitleOrientVariant0> for LegendVariant0TitleOrient {
    fn from(value: LegendVariant0TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant0TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant0TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant0TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant0TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant0TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant0TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant0TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant0Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant0Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant0Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant1Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant1Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant1Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant1FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant1Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant1Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant1Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1FormatType {
    Variant0(LegendVariant1FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant1FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1FormatTypeVariant0> for LegendVariant1FormatType {
    fn from(value: LegendVariant1FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant1FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant1FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1GridAlign {
    Variant0(LegendVariant1GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant1GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1GridAlignVariant0> for LegendVariant1GridAlign {
    fn from(value: LegendVariant1GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant1GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant1GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelAlign {
    Variant0(LegendVariant1LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant1LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1LabelAlignVariant0> for LegendVariant1LabelAlign {
    fn from(value: LegendVariant1LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant1LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant1LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelBaseline {
    Variant0(LegendVariant1LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant1LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1LabelBaselineVariant0> for LegendVariant1LabelBaseline {
    fn from(value: LegendVariant1LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant1LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant1LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant1LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant1LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant1LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant1LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant1LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant1LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant1LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1Orient {
    Variant0(LegendVariant1OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant1Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1OrientVariant0> for LegendVariant1Orient {
    fn from(value: LegendVariant1OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant1Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant1OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant1SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant1SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant1SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant1SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant1SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleAlign {
    Variant0(LegendVariant1TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant1TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1TitleAlignVariant0> for LegendVariant1TitleAlign {
    fn from(value: LegendVariant1TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant1TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant1TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleAnchor {
    Variant0(Option<LegendVariant1TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant1TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant1TitleAnchorVariant0>> for LegendVariant1TitleAnchor {
    fn from(value: Option<LegendVariant1TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant1TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant1TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleBaseline {
    Variant0(LegendVariant1TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant1TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1TitleBaselineVariant0> for LegendVariant1TitleBaseline {
    fn from(value: LegendVariant1TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant1TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant1TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant1TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant1TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant1TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant1TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant1TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant1TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant1TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant1TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant1TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant1TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitleOrient {
    Variant0(LegendVariant1TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant1TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant1TitleOrientVariant0> for LegendVariant1TitleOrient {
    fn from(value: LegendVariant1TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant1TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant1TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant1TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant1TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant1TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant1TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant1TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant1Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant2Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant2Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant2Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant2FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant2Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant2Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant2Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2FormatType {
    Variant0(LegendVariant2FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant2FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2FormatTypeVariant0> for LegendVariant2FormatType {
    fn from(value: LegendVariant2FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant2FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant2FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2GridAlign {
    Variant0(LegendVariant2GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant2GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2GridAlignVariant0> for LegendVariant2GridAlign {
    fn from(value: LegendVariant2GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant2GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant2GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelAlign {
    Variant0(LegendVariant2LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant2LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2LabelAlignVariant0> for LegendVariant2LabelAlign {
    fn from(value: LegendVariant2LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant2LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant2LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelBaseline {
    Variant0(LegendVariant2LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant2LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2LabelBaselineVariant0> for LegendVariant2LabelBaseline {
    fn from(value: LegendVariant2LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant2LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant2LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant2LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant2LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant2LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant2LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant2LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant2LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant2LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2Orient {
    Variant0(LegendVariant2OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant2Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2OrientVariant0> for LegendVariant2Orient {
    fn from(value: LegendVariant2OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant2Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant2OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant2SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant2SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant2SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant2SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant2SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleAlign {
    Variant0(LegendVariant2TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant2TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2TitleAlignVariant0> for LegendVariant2TitleAlign {
    fn from(value: LegendVariant2TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant2TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant2TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleAnchor {
    Variant0(Option<LegendVariant2TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant2TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant2TitleAnchorVariant0>> for LegendVariant2TitleAnchor {
    fn from(value: Option<LegendVariant2TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant2TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant2TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleBaseline {
    Variant0(LegendVariant2TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant2TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2TitleBaselineVariant0> for LegendVariant2TitleBaseline {
    fn from(value: LegendVariant2TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant2TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant2TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant2TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant2TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant2TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant2TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant2TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant2TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant2TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant2TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant2TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant2TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitleOrient {
    Variant0(LegendVariant2TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant2TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant2TitleOrientVariant0> for LegendVariant2TitleOrient {
    fn from(value: LegendVariant2TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant2TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant2TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant2TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant2TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant2TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant2TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant2TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant2Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant2Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant2Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant3Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant3Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant3Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant3FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant3Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant3Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant3Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3FormatType {
    Variant0(LegendVariant3FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant3FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3FormatTypeVariant0> for LegendVariant3FormatType {
    fn from(value: LegendVariant3FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant3FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant3FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3GridAlign {
    Variant0(LegendVariant3GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant3GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3GridAlignVariant0> for LegendVariant3GridAlign {
    fn from(value: LegendVariant3GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant3GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant3GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelAlign {
    Variant0(LegendVariant3LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant3LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3LabelAlignVariant0> for LegendVariant3LabelAlign {
    fn from(value: LegendVariant3LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant3LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant3LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelBaseline {
    Variant0(LegendVariant3LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant3LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3LabelBaselineVariant0> for LegendVariant3LabelBaseline {
    fn from(value: LegendVariant3LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant3LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant3LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant3LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant3LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant3LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant3LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant3LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant3LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant3LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3Orient {
    Variant0(LegendVariant3OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant3Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3OrientVariant0> for LegendVariant3Orient {
    fn from(value: LegendVariant3OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant3Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant3OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant3SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant3SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant3SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant3SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant3SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleAlign {
    Variant0(LegendVariant3TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant3TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3TitleAlignVariant0> for LegendVariant3TitleAlign {
    fn from(value: LegendVariant3TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant3TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant3TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleAnchor {
    Variant0(Option<LegendVariant3TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant3TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant3TitleAnchorVariant0>> for LegendVariant3TitleAnchor {
    fn from(value: Option<LegendVariant3TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant3TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant3TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleBaseline {
    Variant0(LegendVariant3TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant3TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3TitleBaselineVariant0> for LegendVariant3TitleBaseline {
    fn from(value: LegendVariant3TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant3TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant3TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant3TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant3TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant3TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant3TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant3TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant3TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant3TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant3TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant3TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant3TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitleOrient {
    Variant0(LegendVariant3TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant3TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant3TitleOrientVariant0> for LegendVariant3TitleOrient {
    fn from(value: LegendVariant3TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant3TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant3TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant3TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant3TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant3TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant3TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant3TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant3Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant3Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant3Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant4Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant4Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant4Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant4FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant4Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant4Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant4Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4FormatType {
    Variant0(LegendVariant4FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant4FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4FormatTypeVariant0> for LegendVariant4FormatType {
    fn from(value: LegendVariant4FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant4FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant4FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4GridAlign {
    Variant0(LegendVariant4GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant4GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4GridAlignVariant0> for LegendVariant4GridAlign {
    fn from(value: LegendVariant4GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant4GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant4GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelAlign {
    Variant0(LegendVariant4LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant4LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4LabelAlignVariant0> for LegendVariant4LabelAlign {
    fn from(value: LegendVariant4LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant4LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant4LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelBaseline {
    Variant0(LegendVariant4LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant4LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4LabelBaselineVariant0> for LegendVariant4LabelBaseline {
    fn from(value: LegendVariant4LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant4LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant4LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant4LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant4LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant4LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant4LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant4LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant4LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant4LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4Orient {
    Variant0(LegendVariant4OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant4Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4OrientVariant0> for LegendVariant4Orient {
    fn from(value: LegendVariant4OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant4Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant4OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant4SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant4SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant4SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant4SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant4SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleAlign {
    Variant0(LegendVariant4TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant4TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4TitleAlignVariant0> for LegendVariant4TitleAlign {
    fn from(value: LegendVariant4TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant4TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant4TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleAnchor {
    Variant0(Option<LegendVariant4TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant4TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant4TitleAnchorVariant0>> for LegendVariant4TitleAnchor {
    fn from(value: Option<LegendVariant4TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant4TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant4TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleBaseline {
    Variant0(LegendVariant4TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant4TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4TitleBaselineVariant0> for LegendVariant4TitleBaseline {
    fn from(value: LegendVariant4TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant4TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant4TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant4TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant4TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant4TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant4TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant4TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant4TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant4TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant4TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant4TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant4TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitleOrient {
    Variant0(LegendVariant4TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant4TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant4TitleOrientVariant0> for LegendVariant4TitleOrient {
    fn from(value: LegendVariant4TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant4TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant4TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant4TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant4TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant4TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant4TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant4TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant4Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant4Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant4Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant4Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant4Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant5Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant5Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant5Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant5FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant5Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant5Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant5Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5FormatType {
    Variant0(LegendVariant5FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant5FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5FormatTypeVariant0> for LegendVariant5FormatType {
    fn from(value: LegendVariant5FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant5FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant5FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5GridAlign {
    Variant0(LegendVariant5GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant5GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5GridAlignVariant0> for LegendVariant5GridAlign {
    fn from(value: LegendVariant5GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant5GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant5GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelAlign {
    Variant0(LegendVariant5LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant5LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5LabelAlignVariant0> for LegendVariant5LabelAlign {
    fn from(value: LegendVariant5LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant5LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant5LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelBaseline {
    Variant0(LegendVariant5LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant5LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5LabelBaselineVariant0> for LegendVariant5LabelBaseline {
    fn from(value: LegendVariant5LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant5LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant5LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant5LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant5LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant5LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant5LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant5LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant5LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant5LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5Orient {
    Variant0(LegendVariant5OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant5Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5OrientVariant0> for LegendVariant5Orient {
    fn from(value: LegendVariant5OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant5Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant5OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant5SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant5SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant5SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant5SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant5SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleAlign {
    Variant0(LegendVariant5TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant5TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5TitleAlignVariant0> for LegendVariant5TitleAlign {
    fn from(value: LegendVariant5TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant5TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant5TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleAnchor {
    Variant0(Option<LegendVariant5TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant5TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant5TitleAnchorVariant0>> for LegendVariant5TitleAnchor {
    fn from(value: Option<LegendVariant5TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant5TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant5TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleBaseline {
    Variant0(LegendVariant5TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant5TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5TitleBaselineVariant0> for LegendVariant5TitleBaseline {
    fn from(value: LegendVariant5TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant5TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant5TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant5TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant5TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant5TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant5TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant5TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant5TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant5TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant5TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant5TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant5TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitleOrient {
    Variant0(LegendVariant5TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant5TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant5TitleOrientVariant0> for LegendVariant5TitleOrient {
    fn from(value: LegendVariant5TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant5TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant5TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant5TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant5TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant5TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant5TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant5TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant5Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant5Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant5Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant5Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant5Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6CornerRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6CornerRadius {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6CornerRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6CornerRadius {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6CornerRadius {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6Direction"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"vertical\","]
#[doc = "    \"horizontal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6Direction {
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "horizontal")]
    Horizontal,
}
impl From<&Self> for LegendVariant6Direction {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6Direction {
    fn to_string(&self) -> String {
        match *self {
            Self::Vertical => "vertical".to_string(),
            Self::Horizontal => "horizontal".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "vertical" => Ok(Self::Vertical),
            "horizontal" => Ok(Self::Horizontal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"entries\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"labels\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"legend\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"symbols\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LegendVariant6Encode {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub entries: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub gradient: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub labels: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub legend: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub symbols: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for LegendVariant6Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LegendVariant6FillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6FillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6FillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6FillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6Format"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"date\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"day\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"month\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"quarter\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"week\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"year\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum LegendVariant6Format {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        date: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        day: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        hours: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        milliseconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        minutes: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        month: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        quarter: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        seconds: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        week: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        year: Option<String>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for LegendVariant6Format {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LegendVariant6Format {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6FormatType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"number\","]
#[doc = "        \"time\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6FormatType {
    Variant0(LegendVariant6FormatTypeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant6FormatType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6FormatTypeVariant0> for LegendVariant6FormatType {
    fn from(value: LegendVariant6FormatTypeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant6FormatType {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6FormatTypeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"number\","]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6FormatTypeVariant0 {
    #[serde(rename = "number")]
    Number,
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for LegendVariant6FormatTypeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6FormatTypeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Number => "number".to_string(),
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6FormatTypeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "number" => Ok(Self::Number),
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6FormatTypeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6GradientOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6GradientOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6GradientOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6GradientOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6GradientOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6GradientStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6GradientStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6GradientStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6GradientStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6GradientStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6GradientStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6GradientStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6GradientStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6GradientStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6GridAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"all\","]
#[doc = "        \"each\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6GridAlign {
    Variant0(LegendVariant6GridAlignVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant6GridAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6GridAlignVariant0> for LegendVariant6GridAlign {
    fn from(value: LegendVariant6GridAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant6GridAlign {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6GridAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"all\","]
#[doc = "    \"each\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6GridAlignVariant0 {
    #[serde(rename = "all")]
    All,
    #[serde(rename = "each")]
    Each,
    #[serde(rename = "none")]
    None,
}
impl From<&Self> for LegendVariant6GridAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6GridAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::All => "all".to_string(),
            Self::Each => "each".to_string(),
            Self::None => "none".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6GridAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "all" => Ok(Self::All),
            "each" => Ok(Self::Each),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6GridAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6LabelAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelAlign {
    Variant0(LegendVariant6LabelAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant6LabelAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6LabelAlignVariant0> for LegendVariant6LabelAlign {
    fn from(value: LegendVariant6LabelAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant6LabelAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6LabelAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant6LabelAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6LabelAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6LabelAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6LabelAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6LabelBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelBaseline {
    Variant0(LegendVariant6LabelBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant6LabelBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6LabelBaselineVariant0> for LegendVariant6LabelBaseline {
    fn from(value: LegendVariant6LabelBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant6LabelBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6LabelBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant6LabelBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6LabelBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6LabelBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6LabelBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6LabelColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6LabelColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6LabelColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6LabelFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant6LabelFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant6LabelFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LabelFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LabelFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LabelFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant6LabelFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant6LabelFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant6LabelFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant6LabelFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant6LabelFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LabelLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LabelLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LabelLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LabelOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LabelOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LabelOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LabelOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LabelOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LabelOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LabelOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LabelOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LegendX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LegendX {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LegendX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LegendX {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LegendX {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6LegendY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6LegendY {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6LegendY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6LegendY {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6LegendY {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"right\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\","]
#[doc = "        \"top-left\","]
#[doc = "        \"top-right\","]
#[doc = "        \"bottom-left\","]
#[doc = "        \"bottom-right\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6Orient {
    Variant0(LegendVariant6OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LegendVariant6Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6OrientVariant0> for LegendVariant6Orient {
    fn from(value: LegendVariant6OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LegendVariant6Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"right\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\","]
#[doc = "    \"top-left\","]
#[doc = "    \"top-right\","]
#[doc = "    \"bottom-left\","]
#[doc = "    \"bottom-right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "top-left")]
    TopLeft,
    #[serde(rename = "top-right")]
    TopRight,
    #[serde(rename = "bottom-left")]
    BottomLeft,
    #[serde(rename = "bottom-right")]
    BottomRight,
}
impl From<&Self> for LegendVariant6OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::TopLeft => "top-left".to_string(),
            Self::TopRight => "top-right".to_string(),
            Self::BottomLeft => "bottom-left".to_string(),
            Self::BottomRight => "bottom-right".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            "top-left" => Ok(Self::TopLeft),
            "top-right" => Ok(Self::TopRight),
            "bottom-left" => Ok(Self::BottomLeft),
            "bottom-right" => Ok(Self::BottomRight),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6Padding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6Padding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6StrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6StrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6StrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6StrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6SymbolDash"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"number\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/arrayValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolDash {
    Variant0(Vec<f64>),
    Variant1(ArrayValue),
}
impl From<&Self> for LegendVariant6SymbolDash {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<f64>> for LegendVariant6SymbolDash {
    fn from(value: Vec<f64>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ArrayValue> for LegendVariant6SymbolDash {
    fn from(value: ArrayValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolDashOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolDashOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6SymbolDashOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6SymbolDashOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6SymbolDashOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolFillColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolFillColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6SymbolFillColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6SymbolFillColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6SymbolOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6SymbolOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6SymbolOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6SymbolOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6SymbolOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6SymbolOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6SymbolOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6SymbolSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6SymbolSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6SymbolSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolStrokeColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolStrokeColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6SymbolStrokeColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6SymbolStrokeColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6SymbolStrokeWidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolStrokeWidth {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6SymbolStrokeWidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6SymbolStrokeWidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6SymbolStrokeWidth {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6SymbolType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6SymbolType {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant6SymbolType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant6SymbolType {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleAlign"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleAlign {
    Variant0(LegendVariant6TitleAlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for LegendVariant6TitleAlign {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6TitleAlignVariant0> for LegendVariant6TitleAlign {
    fn from(value: LegendVariant6TitleAlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for LegendVariant6TitleAlign {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleAlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6TitleAlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for LegendVariant6TitleAlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6TitleAlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6TitleAlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6TitleAlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6TitleAnchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleAnchor {
    Variant0(Option<LegendVariant6TitleAnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for LegendVariant6TitleAnchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<LegendVariant6TitleAnchorVariant0>> for LegendVariant6TitleAnchor {
    fn from(value: Option<LegendVariant6TitleAnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for LegendVariant6TitleAnchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleAnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6TitleAnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for LegendVariant6TitleAnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6TitleAnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6TitleAnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6TitleAnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6TitleBaseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleBaseline {
    Variant0(LegendVariant6TitleBaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for LegendVariant6TitleBaseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6TitleBaselineVariant0> for LegendVariant6TitleBaseline {
    fn from(value: LegendVariant6TitleBaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for LegendVariant6TitleBaseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleBaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6TitleBaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for LegendVariant6TitleBaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6TitleBaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6TitleBaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6TitleBaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6TitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for LegendVariant6TitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for LegendVariant6TitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LegendVariant6TitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant6TitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant6TitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6TitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6TitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6TitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for LegendVariant6TitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for LegendVariant6TitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for LegendVariant6TitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for LegendVariant6TitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for LegendVariant6TitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleLimit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6TitleLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6TitleLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6TitleLimit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6TitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6TitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6TitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleOpacity"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleOpacity {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6TitleOpacity {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6TitleOpacity {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6TitleOpacity {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/orientValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitleOrient {
    Variant0(LegendVariant6TitleOrientVariant0),
    Variant1(OrientValue),
}
impl From<&Self> for LegendVariant6TitleOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<LegendVariant6TitleOrientVariant0> for LegendVariant6TitleOrient {
    fn from(value: LegendVariant6TitleOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValue> for LegendVariant6TitleOrient {
    fn from(value: OrientValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6TitleOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6TitleOrientVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for LegendVariant6TitleOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6TitleOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6TitleOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6TitleOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LegendVariant6TitlePadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LegendVariant6TitlePadding {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for LegendVariant6TitlePadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for LegendVariant6TitlePadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for LegendVariant6TitlePadding {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LegendVariant6Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"symbol\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LegendVariant6Type {
    #[serde(rename = "gradient")]
    Gradient,
    #[serde(rename = "symbol")]
    Symbol,
}
impl From<&Self> for LegendVariant6Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LegendVariant6Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Gradient => "gradient".to_string(),
            Self::Symbol => "symbol".to_string(),
        }
    }
}
impl std::str::FromStr for LegendVariant6Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "gradient" => Ok(Self::Gradient),
            "symbol" => Ok(Self::Symbol),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LegendVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LinearGradient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"stops\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"linear\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"stops\": {"]
#[doc = "      \"$ref\": \"#/definitions/gradientStops\""]
#[doc = "    },"]
#[doc = "    \"x1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinearGradient {
    pub gradient: LinearGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
impl From<&Self> for LinearGradient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LinearGradientGradient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linear\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinearGradientGradient {
    #[serde(rename = "linear")]
    Linear,
}
impl From<&Self> for LinearGradientGradient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LinearGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
        }
    }
}
impl std::str::FromStr for LinearGradientGradient {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "linear" => Ok(Self::Linear),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinearGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LinkpathTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"orient\": {"]
#[doc = "      \"default\": \"vertical\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"horizontal\","]
#[doc = "            \"vertical\","]
#[doc = "            \"radial\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"require\": {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    \"shape\": {"]
#[doc = "      \"default\": \"line\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"line\","]
#[doc = "            \"arc\","]
#[doc = "            \"curve\","]
#[doc = "            \"diagonal\","]
#[doc = "            \"orthogonal\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sourceX\": {"]
#[doc = "      \"default\": \"source.x\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sourceY\": {"]
#[doc = "      \"default\": \"source.y\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"targetX\": {"]
#[doc = "      \"default\": \"target.x\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"targetY\": {"]
#[doc = "      \"default\": \"target.y\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"linkpath\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LinkpathTransform {
    #[serde(rename = "as", default = "defaults::linkpath_transform_as")]
    pub as_: LinkpathTransformAs,
    #[serde(default = "defaults::linkpath_transform_orient")]
    pub orient: LinkpathTransformOrient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub require: Option<SignalRef>,
    #[serde(default = "defaults::linkpath_transform_shape")]
    pub shape: LinkpathTransformShape,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "sourceX", default = "defaults::linkpath_transform_source_x")]
    pub source_x: LinkpathTransformSourceX,
    #[serde(rename = "sourceY", default = "defaults::linkpath_transform_source_y")]
    pub source_y: LinkpathTransformSourceY,
    #[serde(rename = "targetX", default = "defaults::linkpath_transform_target_x")]
    pub target_x: LinkpathTransformTargetX,
    #[serde(rename = "targetY", default = "defaults::linkpath_transform_target_y")]
    pub target_y: LinkpathTransformTargetY,
    #[serde(rename = "type")]
    pub type_: LinkpathTransformType,
}
impl From<&Self> for LinkpathTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LinkpathTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LinkpathTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformAs {
    fn default() -> Self {
        Self::Variant0("path".to_string())
    }
}
impl From<SignalRef> for LinkpathTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LinkpathTransformOrient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"vertical\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"horizontal\","]
#[doc = "        \"vertical\","]
#[doc = "        \"radial\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformOrient {
    Variant0(LinkpathTransformOrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LinkpathTransformOrient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformOrient {
    fn default() -> Self {
        Self::Variant0(LinkpathTransformOrientVariant0::Vertical)
    }
}
impl From<LinkpathTransformOrientVariant0> for LinkpathTransformOrient {
    fn from(value: LinkpathTransformOrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LinkpathTransformOrient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LinkpathTransformOrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"horizontal\","]
#[doc = "    \"vertical\","]
#[doc = "    \"radial\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformOrientVariant0 {
    #[serde(rename = "horizontal")]
    Horizontal,
    #[serde(rename = "vertical")]
    Vertical,
    #[serde(rename = "radial")]
    Radial,
}
impl From<&Self> for LinkpathTransformOrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformOrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Horizontal => "horizontal".to_string(),
            Self::Vertical => "vertical".to_string(),
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformOrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "horizontal" => Ok(Self::Horizontal),
            "vertical" => Ok(Self::Vertical),
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformOrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LinkpathTransformShape"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"line\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"line\","]
#[doc = "        \"arc\","]
#[doc = "        \"curve\","]
#[doc = "        \"diagonal\","]
#[doc = "        \"orthogonal\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformShape {
    Variant0(LinkpathTransformShapeVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for LinkpathTransformShape {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformShape {
    fn default() -> Self {
        Self::Variant0(LinkpathTransformShapeVariant0::Line)
    }
}
impl From<LinkpathTransformShapeVariant0> for LinkpathTransformShape {
    fn from(value: LinkpathTransformShapeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LinkpathTransformShape {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LinkpathTransformShapeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"line\","]
#[doc = "    \"arc\","]
#[doc = "    \"curve\","]
#[doc = "    \"diagonal\","]
#[doc = "    \"orthogonal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformShapeVariant0 {
    #[serde(rename = "line")]
    Line,
    #[serde(rename = "arc")]
    Arc,
    #[serde(rename = "curve")]
    Curve,
    #[serde(rename = "diagonal")]
    Diagonal,
    #[serde(rename = "orthogonal")]
    Orthogonal,
}
impl From<&Self> for LinkpathTransformShapeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformShapeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Line => "line".to_string(),
            Self::Arc => "arc".to_string(),
            Self::Curve => "curve".to_string(),
            Self::Diagonal => "diagonal".to_string(),
            Self::Orthogonal => "orthogonal".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformShapeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "line" => Ok(Self::Line),
            "arc" => Ok(Self::Arc),
            "curve" => Ok(Self::Curve),
            "diagonal" => Ok(Self::Diagonal),
            "orthogonal" => Ok(Self::Orthogonal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformShapeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LinkpathTransformSourceX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"source.x\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformSourceX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LinkpathTransformSourceX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformSourceX {
    fn default() -> Self {
        Self::ScaleField(ScaleField(StringOrSignal::Variant0("source.x".to_string())))
    }
}
impl From<ScaleField> for LinkpathTransformSourceX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LinkpathTransformSourceX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LinkpathTransformSourceX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LinkpathTransformSourceY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"source.y\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformSourceY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LinkpathTransformSourceY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformSourceY {
    fn default() -> Self {
        Self::ScaleField(ScaleField(StringOrSignal::Variant0("source.y".to_string())))
    }
}
impl From<ScaleField> for LinkpathTransformSourceY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LinkpathTransformSourceY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LinkpathTransformSourceY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LinkpathTransformTargetX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"target.x\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformTargetX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LinkpathTransformTargetX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformTargetX {
    fn default() -> Self {
        Self::ScaleField(ScaleField(StringOrSignal::Variant0("target.x".to_string())))
    }
}
impl From<ScaleField> for LinkpathTransformTargetX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LinkpathTransformTargetX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LinkpathTransformTargetX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LinkpathTransformTargetY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"target.y\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LinkpathTransformTargetY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LinkpathTransformTargetY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LinkpathTransformTargetY {
    fn default() -> Self {
        Self::ScaleField(ScaleField(StringOrSignal::Variant0("target.y".to_string())))
    }
}
impl From<ScaleField> for LinkpathTransformTargetY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LinkpathTransformTargetY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LinkpathTransformTargetY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LinkpathTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linkpath\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LinkpathTransformType {
    #[serde(rename = "linkpath")]
    Linkpath,
}
impl From<&Self> for LinkpathTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LinkpathTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Linkpath => "linkpath".to_string(),
        }
    }
}
impl std::str::FromStr for LinkpathTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "linkpath" => Ok(Self::Linkpath),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LinkpathTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Listener"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scale\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"scale\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stream\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Listener {
    Variant0(SignalRef),
    Variant1 { scale: String },
    Variant2(Stream),
}
impl From<&Self> for Listener {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for Listener {
    fn from(value: SignalRef) -> Self {
        Self::Variant0(value)
    }
}
impl From<Stream> for Listener {
    fn from(value: Stream) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "LoessTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"bandwidth\": {"]
#[doc = "      \"default\": 0.3,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"loess\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LoessTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LoessTransformAs>,
    #[serde(default = "defaults::loess_transform_bandwidth")]
    pub bandwidth: LoessTransformBandwidth,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<LoessTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LoessTransformType,
    pub x: LoessTransformX,
    pub y: LoessTransformY,
}
impl From<&Self> for LoessTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LoessTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformAs {
    Variant0(Vec<LoessTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LoessTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<LoessTransformAsVariant0Item>> for LoessTransformAs {
    fn from(value: Vec<LoessTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LoessTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LoessTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LoessTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LoessTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LoessTransformBandwidth"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.3,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformBandwidth {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for LoessTransformBandwidth {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for LoessTransformBandwidth {
    fn default() -> Self {
        Self::Variant0(0.3_f64)
    }
}
impl From<f64> for LoessTransformBandwidth {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LoessTransformBandwidth {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LoessTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformGroupby {
    Variant0(Vec<LoessTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LoessTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<LoessTransformGroupbyVariant0Item>> for LoessTransformGroupby {
    fn from(value: Vec<LoessTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LoessTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LoessTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LoessTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LoessTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LoessTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LoessTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LoessTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"loess\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LoessTransformType {
    #[serde(rename = "loess")]
    Loess,
}
impl From<&Self> for LoessTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LoessTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Loess => "loess".to_string(),
        }
    }
}
impl std::str::FromStr for LoessTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "loess" => Ok(Self::Loess),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LoessTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LoessTransformX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LoessTransformX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LoessTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LoessTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LoessTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LoessTransformY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LoessTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LoessTransformY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LoessTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LoessTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LoessTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LookupTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fields\","]
#[doc = "    \"from\","]
#[doc = "    \"key\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"default\": {},"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"from\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"lookup\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct LookupTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<LookupTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,
    pub fields: LookupTransformFields,
    pub from: String,
    pub key: LookupTransformKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: LookupTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<LookupTransformValues>,
}
impl From<&Self> for LookupTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "LookupTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformAs {
    Variant0(Vec<LookupTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LookupTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<LookupTransformAsVariant0Item>> for LookupTransformAs {
    fn from(value: Vec<LookupTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LookupTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LookupTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for LookupTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for LookupTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LookupTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformFields {
    Variant0(Vec<LookupTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LookupTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<LookupTransformFieldsVariant0Item>> for LookupTransformFields {
    fn from(value: Vec<LookupTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LookupTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LookupTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LookupTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LookupTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LookupTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LookupTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LookupTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LookupTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LookupTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LookupTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LookupTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "LookupTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"lookup\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum LookupTransformType {
    #[serde(rename = "lookup")]
    Lookup,
}
impl From<&Self> for LookupTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for LookupTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Lookup => "lookup".to_string(),
        }
    }
}
impl std::str::FromStr for LookupTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "lookup" => Ok(Self::Lookup),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for LookupTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "LookupTransformValues"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformValues {
    Variant0(Vec<LookupTransformValuesVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for LookupTransformValues {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<LookupTransformValuesVariant0Item>> for LookupTransformValues {
    fn from(value: Vec<LookupTransformValuesVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for LookupTransformValues {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "LookupTransformValuesVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum LookupTransformValuesVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for LookupTransformValuesVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for LookupTransformValuesVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for LookupTransformValuesVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for LookupTransformValuesVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "Mark"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"aria\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"clip\": {"]
#[doc = "      \"$ref\": \"#/definitions/markclip\""]
#[doc = "    },"]
#[doc = "    \"description\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"$ref\": \"#/definitions/encode\""]
#[doc = "    },"]
#[doc = "    \"interactive\": {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"on\": {"]
#[doc = "      \"$ref\": \"#/definitions/onMarkTrigger\""]
#[doc = "    },"]
#[doc = "    \"role\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"style\": {"]
#[doc = "      \"$ref\": \"#/definitions/style\""]
#[doc = "    },"]
#[doc = "    \"transform\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/transformMark\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/marktype\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Mark {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<Markclip>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interactive: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on: Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transform: Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
impl From<&Self> for Mark {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "MarkGroup"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/from\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/facet\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"group\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/mark\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scope\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarkGroup {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub axes: Vec<Axis>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<Markclip>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<MarkGroupFrom>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interactive: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<Layout>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub legends: Vec<Legend>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub marks: Vec<MarkGroupMarksItem>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on: Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub projections: Vec<Projection>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub scales: Vec<Scale>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub signals: Vec<Signal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<Title>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transform: Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: MarkGroupType,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub usermeta: serde_json::Map<String, serde_json::Value>,
}
impl From<&Self> for MarkGroup {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "MarkGroupFrom"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/from\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/facet\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarkGroupFrom {
    From(From),
    Facet(Facet),
}
impl From<&Self> for MarkGroupFrom {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<From> for MarkGroupFrom {
    fn from(value: From) -> Self {
        Self::From(value)
    }
}
impl From<Facet> for MarkGroupFrom {
    fn from(value: Facet) -> Self {
        Self::Facet(value)
    }
}
#[doc = "MarkGroupMarksItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum MarkGroupMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl From<&Self> for MarkGroupMarksItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MarkGroup> for MarkGroupMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl From<MarkVisual> for MarkGroupMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "MarkGroupType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"group\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum MarkGroupType {
    #[serde(rename = "group")]
    Group,
}
impl From<&Self> for MarkGroupType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for MarkGroupType {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
        }
    }
}
impl std::str::FromStr for MarkGroupType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "group" => Ok(Self::Group),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for MarkGroupType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "MarkVisual"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"$ref\": \"#/definitions/from\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"not\": {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"group\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/mark\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MarkVisual {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub aria: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub clip: Option<Markclip>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub from: Option<From>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub interactive: Option<BooleanOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on: Option<OnMarkTrigger>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub role: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub style: Option<Style>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub transform: Vec<TransformMark>,
    #[serde(rename = "type")]
    pub type_: Marktype,
}
impl From<&Self> for MarkVisual {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "Markclip"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"path\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"path\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sphere\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sphere\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Markclip {
    Variant0(BooleanOrSignal),
    Variant1 { path: StringOrSignal },
    Variant2 { sphere: StringOrSignal },
}
impl From<&Self> for Markclip {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<BooleanOrSignal> for Markclip {
    fn from(value: BooleanOrSignal) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "Marktype"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Marktype(pub String);
impl std::ops::Deref for Marktype {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Marktype> for String {
    fn from(value: Marktype) -> Self {
        value.0
    }
}
impl From<&Self> for Marktype {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<String> for Marktype {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Marktype {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Marktype {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[doc = "NestTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"generate\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"keys\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"nest\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NestTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub generate: Option<NestTransformGenerate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub keys: Option<NestTransformKeys>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: NestTransformType,
}
impl From<&Self> for NestTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NestTransformGenerate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformGenerate {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for NestTransformGenerate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for NestTransformGenerate {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for NestTransformGenerate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NestTransformKeys"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformKeys {
    Variant0(Vec<NestTransformKeysVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for NestTransformKeys {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<NestTransformKeysVariant0Item>> for NestTransformKeys {
    fn from(value: Vec<NestTransformKeysVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for NestTransformKeys {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NestTransformKeysVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NestTransformKeysVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for NestTransformKeysVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for NestTransformKeysVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for NestTransformKeysVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for NestTransformKeysVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "NestTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"nest\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum NestTransformType {
    #[serde(rename = "nest")]
    Nest,
}
impl From<&Self> for NestTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for NestTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Nest => "nest".to_string(),
        }
    }
}
impl std::str::FromStr for NestTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "nest" => Ok(Self::Nest),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NestTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "NumberModifiers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"band\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"exponent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extra\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"mult\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/field\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NumberModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub band: Option<NumberModifiersBand>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub exponent: Option<NumberModifiersExponent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extra: Option<bool>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mult: Option<NumberModifiersMult>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub offset: Option<NumberModifiersOffset>,
    #[serde(default)]
    pub round: bool,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
impl From<&Self> for NumberModifiers {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NumberModifiersBand"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersBand {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberModifiersBand {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberModifiersBand {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberModifiersBand {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberModifiersBand {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberModifiersBand {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberModifiersBand {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberModifiersExponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersExponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberModifiersExponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberModifiersExponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberModifiersExponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberModifiersMult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersMult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberModifiersMult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberModifiersMult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberModifiersMult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberModifiersOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberModifiersOffset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberModifiersOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberModifiersOffset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberModifiersOffset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberOrSignal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberOrSignal {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for NumberOrSignal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberOrSignal {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for NumberOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"number\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValue {
    Variant0(Vec<NumberValueVariant0Item>),
    Variant1(NumberValueVariant1),
}
impl From<&Self> for NumberValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<NumberValueVariant0Item>> for NumberValue {
    fn from(value: Vec<NumberValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValueVariant1> for NumberValue {
    fn from(value: NumberValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0Item {
    Variant0(NumberValueVariant0ItemVariant0),
    Variant1(NumberValueVariant0ItemVariant1),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant0ItemVariant2Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant0ItemVariant2Mult>,
        offset: NumberValueVariant0ItemVariant2Offset,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for NumberValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<NumberValueVariant0ItemVariant0> for NumberValueVariant0Item {
    fn from(value: NumberValueVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValueVariant0ItemVariant1> for NumberValueVariant0Item {
    fn from(value: NumberValueVariant0ItemVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant0ItemVariant0Variant0Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant0ItemVariant0Variant0Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant0ItemVariant0Variant0Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant0ItemVariant0Variant0Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant0ItemVariant0Variant1Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant0ItemVariant0Variant1Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant0ItemVariant0Variant1Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant0ItemVariant0Variant1Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: f64,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant0ItemVariant0Variant2Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant0ItemVariant0Variant2Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant0ItemVariant0Variant2Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant0ItemVariant0Variant2Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant0ItemVariant0Variant3Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant0ItemVariant0Variant3Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant0ItemVariant0Variant3Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant0ItemVariant0Variant3Offset>,
        range: NumberValueVariant0ItemVariant0Variant3Range,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for NumberValueVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant0Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemVariant0Variant0Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant0ItemVariant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant0ItemVariant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemVariant0Variant0Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant0ItemVariant0Variant0Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant0Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant0Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant0Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant0Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant0Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant1Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemVariant0Variant1Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant0ItemVariant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant0ItemVariant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemVariant0Variant1Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant0ItemVariant0Variant1Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant1Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant1Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant1Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant2Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemVariant0Variant2Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant0ItemVariant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant0ItemVariant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemVariant0Variant2Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant0ItemVariant0Variant2Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant2Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant2Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant2Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant2Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant2Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant3Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemVariant0Variant3Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant0ItemVariant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant0ItemVariant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemVariant0Variant3Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant0ItemVariant0Variant3Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant3Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant3Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant3Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant0Variant3Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant0Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant0ItemVariant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant0ItemVariant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant0ItemVariant0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant0ItemVariant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        },"]
#[doc = "        \"test\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant0ItemVariant1 {}
impl From<&Self> for NumberValueVariant0ItemVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NumberValueVariant0ItemVariant2Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant2Exponent {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant2Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant2Exponent {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant2Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant2Mult {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant2Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant2Mult {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant0ItemVariant2Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant0ItemVariant2Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for NumberValueVariant0ItemVariant2Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant0ItemVariant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for NumberValueVariant0ItemVariant2Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1 {
    Variant0(NumberValueVariant1Variant0),
    Variant1(NumberValueVariant1Variant1),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant1Variant2Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant1Variant2Mult>,
        offset: NumberValueVariant1Variant2Offset,
        #[serde(default)]
        round: bool,
    },
}
impl From<&Self> for NumberValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<NumberValueVariant1Variant0> for NumberValueVariant1 {
    fn from(value: NumberValueVariant1Variant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValueVariant1Variant1> for NumberValueVariant1 {
    fn from(value: NumberValueVariant1Variant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"value\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"value\": {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/field\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"range\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"range\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"number\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"band\","]
#[doc = "          \"scale\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant1Variant0Variant0Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant1Variant0Variant0Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant1Variant0Variant0Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant1Variant0Variant0Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant1Variant0Variant1Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant1Variant0Variant1Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant1Variant0Variant1Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant1Variant0Variant1Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: f64,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant1Variant0Variant2Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant1Variant0Variant2Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant1Variant0Variant2Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant1Variant0Variant2Offset>,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        band: Option<NumberValueVariant1Variant0Variant3Band>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberValueVariant1Variant0Variant3Exponent>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extra: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        mult: Option<NumberValueVariant1Variant0Variant3Mult>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<NumberValueVariant1Variant0Variant3Offset>,
        range: NumberValueVariant1Variant0Variant3Range,
        #[serde(default)]
        round: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for NumberValueVariant1Variant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NumberValueVariant1Variant0Variant0Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Variant0Variant0Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Variant0Variant0Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Variant0Variant0Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant1Variant0Variant0Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant0Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Exponent {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant0Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant0Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant0Exponent {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant0Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Mult {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant0Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant0Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant0Mult {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant0Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant0Offset {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant0Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant0Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant0Offset {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant1Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Variant0Variant1Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Variant0Variant1Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Variant0Variant1Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant1Variant0Variant1Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant1Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Exponent {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant1Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant1Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant1Exponent {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant1Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Mult {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant1Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant1Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant1Mult {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant1Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant1Offset {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant1Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant1Offset {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant2Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Variant0Variant2Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Variant0Variant2Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Variant0Variant2Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant1Variant0Variant2Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant2Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Exponent {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant2Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant2Exponent {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant2Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Mult {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant2Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant2Mult {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant2Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant2Offset {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant2Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant2Offset {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant3Band"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Band {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Variant0Variant3Band {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Variant0Variant3Band {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Variant0Variant3Band {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant1Variant0Variant3Band {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant3Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Exponent {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant3Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant3Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant3Exponent {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant3Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Mult {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant3Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant3Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant3Mult {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant3Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Offset {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant0Variant3Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant3Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant0Variant3Offset {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant0Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant0Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for NumberValueVariant1Variant0Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for NumberValueVariant1Variant0Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for NumberValueVariant1Variant0Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for NumberValueVariant1Variant0Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"band\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"extra\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"mult\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"scale\": {"]
#[doc = "          \"$ref\": \"#/definitions/field\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"band\","]
#[doc = "        \"scale\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"value\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"value\": {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"field\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"field\": {"]
#[doc = "                \"$ref\": \"#/definitions/field\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"range\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"range\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"scale\","]
#[doc = "          \"value\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"not\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"offset\""]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
#[serde(deny_unknown_fields)]
pub enum NumberValueVariant1Variant1 {}
impl From<&Self> for NumberValueVariant1Variant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "NumberValueVariant1Variant2Exponent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant2Exponent {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant2Exponent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant2Exponent {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant2Exponent {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant2Mult"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant2Mult {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant2Mult {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant2Mult {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant2Mult {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "NumberValueVariant1Variant2Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum NumberValueVariant1Variant2Offset {
    Variant0(f64),
    Variant1(Box<NumberValue>),
}
impl From<&Self> for NumberValueVariant1Variant2Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for NumberValueVariant1Variant2Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<Box<NumberValue>> for NumberValueVariant1Variant2Offset {
    fn from(value: Box<NumberValue>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "OnEvents"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"allOf\": ["]
#[doc = "      {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"events\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"events\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/selector\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/listener\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/listener\""]
#[doc = "                },"]
#[doc = "                \"minItems\": 1"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"force\": {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"encode\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"encode\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"required\": ["]
#[doc = "              \"update\""]
#[doc = "            ],"]
#[doc = "            \"properties\": {"]
#[doc = "              \"update\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/exprString\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/expr\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"value\""]
#[doc = "                    ],"]
#[doc = "                    \"properties\": {"]
#[doc = "                      \"value\": {}"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnEvents(pub Vec<OnEventsItem>);
impl std::ops::Deref for OnEvents {
    type Target = Vec<OnEventsItem>;
    fn deref(&self) -> &Vec<OnEventsItem> {
        &self.0
    }
}
impl From<OnEvents> for Vec<OnEventsItem> {
    fn from(value: OnEvents) -> Self {
        value.0
    }
}
impl From<&Self> for OnEvents {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<OnEventsItem>> for OnEvents {
    fn from(value: Vec<OnEventsItem>) -> Self {
        Self(value)
    }
}
#[doc = "OnEventsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"events\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"events\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/selector\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/listener\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/listener\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"force\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"encode\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"encode\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"update\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"update\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/exprString\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/expr\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {}"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItem {
    Variant0 {
        encode: String,
        events: OnEventsItemVariant0Events,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        force: Option<bool>,
    },
    Variant1 {
        events: OnEventsItemVariant1Events,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        force: Option<bool>,
        update: OnEventsItemVariant1Update,
    },
}
impl From<&Self> for OnEventsItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "OnEventsItemVariant0Events"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/selector\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/listener\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/listener\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItemVariant0Events {
    Variant0(Selector),
    Variant1(Listener),
    Variant2(Vec<Listener>),
}
impl From<&Self> for OnEventsItemVariant0Events {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Selector> for OnEventsItemVariant0Events {
    fn from(value: Selector) -> Self {
        Self::Variant0(value)
    }
}
impl From<Listener> for OnEventsItemVariant0Events {
    fn from(value: Listener) -> Self {
        Self::Variant1(value)
    }
}
impl From<Vec<Listener>> for OnEventsItemVariant0Events {
    fn from(value: Vec<Listener>) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "OnEventsItemVariant1Events"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/selector\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/listener\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/listener\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItemVariant1Events {
    Variant0(Selector),
    Variant1(Listener),
    Variant2(Vec<Listener>),
}
impl From<&Self> for OnEventsItemVariant1Events {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Selector> for OnEventsItemVariant1Events {
    fn from(value: Selector) -> Self {
        Self::Variant0(value)
    }
}
impl From<Listener> for OnEventsItemVariant1Events {
    fn from(value: Listener) -> Self {
        Self::Variant1(value)
    }
}
impl From<Vec<Listener>> for OnEventsItemVariant1Events {
    fn from(value: Vec<Listener>) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "OnEventsItemVariant1Update"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"value\": {}"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnEventsItemVariant1Update {
    Variant0(ExprString),
    Variant1(Expr),
    Variant2(SignalRef),
    Variant3 { value: serde_json::Value },
}
impl From<&Self> for OnEventsItemVariant1Update {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ExprString> for OnEventsItemVariant1Update {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl From<Expr> for OnEventsItemVariant1Update {
    fn from(value: Expr) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for OnEventsItemVariant1Update {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "OnMarkTrigger"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"trigger\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"modify\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"trigger\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"values\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnMarkTrigger(pub Vec<OnMarkTriggerItem>);
impl std::ops::Deref for OnMarkTrigger {
    type Target = Vec<OnMarkTriggerItem>;
    fn deref(&self) -> &Vec<OnMarkTriggerItem> {
        &self.0
    }
}
impl From<OnMarkTrigger> for Vec<OnMarkTriggerItem> {
    fn from(value: OnMarkTrigger) -> Self {
        value.0
    }
}
impl From<&Self> for OnMarkTrigger {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<OnMarkTriggerItem>> for OnMarkTrigger {
    fn from(value: Vec<OnMarkTriggerItem>) -> Self {
        Self(value)
    }
}
#[doc = "OnMarkTriggerItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"trigger\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"modify\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"trigger\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnMarkTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
impl From<&Self> for OnMarkTriggerItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "OnTrigger"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"required\": ["]
#[doc = "      \"trigger\""]
#[doc = "    ],"]
#[doc = "    \"properties\": {"]
#[doc = "      \"insert\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"modify\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"remove\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/exprString\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"toggle\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"trigger\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"values\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"additionalProperties\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct OnTrigger(pub Vec<OnTriggerItem>);
impl std::ops::Deref for OnTrigger {
    type Target = Vec<OnTriggerItem>;
    fn deref(&self) -> &Vec<OnTriggerItem> {
        &self.0
    }
}
impl From<OnTrigger> for Vec<OnTriggerItem> {
    fn from(value: OnTrigger) -> Self {
        value.0
    }
}
impl From<&Self> for OnTrigger {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<OnTriggerItem>> for OnTrigger {
    fn from(value: Vec<OnTriggerItem>) -> Self {
        Self(value)
    }
}
#[doc = "OnTriggerItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"trigger\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"insert\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"modify\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"remove\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"toggle\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"trigger\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct OnTriggerItem {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub insert: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub modify: Option<ExprString>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub remove: Option<OnTriggerItemRemove>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub toggle: Option<ExprString>,
    pub trigger: ExprString,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub values: Option<ExprString>,
}
impl From<&Self> for OnTriggerItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "OnTriggerItemRemove"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OnTriggerItemRemove {
    Variant0(bool),
    Variant1(ExprString),
}
impl From<&Self> for OnTriggerItemRemove {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OnTriggerItemRemove {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OnTriggerItemRemove {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for OnTriggerItemRemove {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<bool> for OnTriggerItemRemove {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<ExprString> for OnTriggerItemRemove {
    fn from(value: ExprString) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "OrientValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"left\","]
#[doc = "                              \"right\","]
#[doc = "                              \"top\","]
#[doc = "                              \"bottom\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"top\","]
#[doc = "                        \"bottom\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValue {
    Variant0(Vec<OrientValueVariant0Item>),
    Variant1(OrientValueVariant1),
}
impl From<&Self> for OrientValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<OrientValueVariant0Item>> for OrientValue {
    fn from(value: Vec<OrientValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<OrientValueVariant1> for OrientValue {
    fn from(value: OrientValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "OrientValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"left\","]
#[doc = "                        \"right\","]
#[doc = "                        \"top\","]
#[doc = "                        \"bottom\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: OrientValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: OrientValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for OrientValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "OrientValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrientValueVariant0ItemVariant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for OrientValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for OrientValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "OrientValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for OrientValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OrientValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for OrientValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for OrientValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for OrientValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "OrientValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"left\","]
#[doc = "                    \"right\","]
#[doc = "                    \"top\","]
#[doc = "                    \"bottom\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: OrientValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: OrientValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for OrientValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "OrientValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum OrientValueVariant1Variant1Value {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for OrientValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for OrientValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for OrientValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "OrientValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum OrientValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for OrientValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for OrientValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for OrientValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for OrientValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for OrientValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for OrientValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for OrientValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for OrientValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"r\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 5,"]
#[doc = "          \"minItems\": 5"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"radius\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pack\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PackTransform {
    #[serde(rename = "as", default = "defaults::pack_transform_as")]
    pub as_: PackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PackTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub radius: Option<PackTransformRadius>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PackTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PackTransformType,
}
impl From<&Self> for PackTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "PackTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"r\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 5,"]
#[doc = "      \"minItems\": 5"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformAs {
    Variant0([PackTransformAsVariant0Item; 5usize]),
    Variant1(SignalRef),
}
impl From<&Self> for PackTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for PackTransformAs {
    fn default() -> Self {
        Self::Variant0([
            PackTransformAsVariant0Item::Variant0("x".to_string()),
            PackTransformAsVariant0Item::Variant0("y".to_string()),
            PackTransformAsVariant0Item::Variant0("r".to_string()),
            PackTransformAsVariant0Item::Variant0("depth".to_string()),
            PackTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl From<[PackTransformAsVariant0Item; 5usize]> for PackTransformAs {
    fn from(value: [PackTransformAsVariant0Item; 5usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PackTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for PackTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for PackTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PackTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PackTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PackTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PackTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PackTransformPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PackTransformPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PackTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PackTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransformRadius"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformRadius {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PackTransformRadius {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PackTransformRadius {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PackTransformRadius {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PackTransformRadius {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PackTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformSize {
    Variant0([PackTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for PackTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[PackTransformSizeVariant0Item; 2usize]> for PackTransformSize {
    fn from(value: [PackTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PackTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PackTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PackTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PackTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PackTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PackTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pack\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PackTransformType {
    #[serde(rename = "pack")]
    Pack,
}
impl From<&Self> for PackTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for PackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pack => "pack".to_string(),
        }
    }
}
impl std::str::FromStr for PackTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pack" => Ok(Self::Pack),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Padding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"bottom\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"left\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"right\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"top\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Padding {
    Variant0(f64),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bottom: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        left: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        right: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        top: Option<f64>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for Padding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for Padding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for Padding {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ParamField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParamField {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<String>,
    pub field: String,
}
impl From<&Self> for ParamField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "PartitionTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x0\","]
#[doc = "        \"y0\","]
#[doc = "        \"x1\","]
#[doc = "        \"y1\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 6,"]
#[doc = "          \"minItems\": 6"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"partition\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PartitionTransform {
    #[serde(rename = "as", default = "defaults::partition_transform_as")]
    pub as_: PartitionTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PartitionTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<PartitionTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<PartitionTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<PartitionTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: PartitionTransformType,
}
impl From<&Self> for PartitionTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "PartitionTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x0\","]
#[doc = "    \"y0\","]
#[doc = "    \"x1\","]
#[doc = "    \"y1\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 6,"]
#[doc = "      \"minItems\": 6"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformAs {
    Variant0([PartitionTransformAsVariant0Item; 6usize]),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for PartitionTransformAs {
    fn default() -> Self {
        Self::Variant0([
            PartitionTransformAsVariant0Item::Variant0("x0".to_string()),
            PartitionTransformAsVariant0Item::Variant0("y0".to_string()),
            PartitionTransformAsVariant0Item::Variant0("x1".to_string()),
            PartitionTransformAsVariant0Item::Variant0("y1".to_string()),
            PartitionTransformAsVariant0Item::Variant0("depth".to_string()),
            PartitionTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl From<[PartitionTransformAsVariant0Item; 6usize]> for PartitionTransformAs {
    fn from(value: [PartitionTransformAsVariant0Item; 6usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PartitionTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for PartitionTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PartitionTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PartitionTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PartitionTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PartitionTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PartitionTransformPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PartitionTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PartitionTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformRound"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformRound {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for PartitionTransformRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PartitionTransformRound {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformSize {
    Variant0([PartitionTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[PartitionTransformSizeVariant0Item; 2usize]> for PartitionTransformSize {
    fn from(value: [PartitionTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PartitionTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PartitionTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PartitionTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PartitionTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PartitionTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PartitionTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"partition\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PartitionTransformType {
    #[serde(rename = "partition")]
    Partition,
}
impl From<&Self> for PartitionTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for PartitionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Partition => "partition".to_string(),
        }
    }
}
impl std::str::FromStr for PartitionTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "partition" => Ok(Self::Partition),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PartitionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PieTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"startAngle\","]
#[doc = "        \"endAngle\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"endAngle\": {"]
#[doc = "      \"default\": 6.283185307179586,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"startAngle\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pie\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PieTransform {
    #[serde(rename = "as", default = "defaults::pie_transform_as")]
    pub as_: PieTransformAs,
    #[serde(rename = "endAngle", default = "defaults::pie_transform_end_angle")]
    pub end_angle: PieTransformEndAngle,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<PieTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<PieTransformSort>,
    #[serde(
        rename = "startAngle",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub start_angle: Option<PieTransformStartAngle>,
    #[serde(rename = "type")]
    pub type_: PieTransformType,
}
impl From<&Self> for PieTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "PieTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"startAngle\","]
#[doc = "    \"endAngle\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformAs {
    Variant0([PieTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for PieTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for PieTransformAs {
    fn default() -> Self {
        Self::Variant0([
            PieTransformAsVariant0Item::Variant0("startAngle".to_string()),
            PieTransformAsVariant0Item::Variant0("endAngle".to_string()),
        ])
    }
}
impl From<[PieTransformAsVariant0Item; 2usize]> for PieTransformAs {
    fn from(value: [PieTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PieTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PieTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for PieTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for PieTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PieTransformEndAngle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 6.283185307179586,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformEndAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PieTransformEndAngle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for PieTransformEndAngle {
    fn default() -> Self {
        Self::Variant0(6.283185307179586_f64)
    }
}
impl From<f64> for PieTransformEndAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PieTransformEndAngle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PieTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PieTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PieTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PieTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PieTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PieTransformSort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformSort {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for PieTransformSort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for PieTransformSort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PieTransformSort {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PieTransformStartAngle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PieTransformStartAngle {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PieTransformStartAngle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PieTransformStartAngle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PieTransformStartAngle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PieTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pie\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PieTransformType {
    #[serde(rename = "pie")]
    Pie,
}
impl From<&Self> for PieTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for PieTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pie => "pie".to_string(),
        }
    }
}
impl std::str::FromStr for PieTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pie" => Ok(Self::Pie),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PieTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PivotTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"limit\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"op\": {"]
#[doc = "      \"default\": \"sum\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"values\","]
#[doc = "            \"count\","]
#[doc = "            \"__count__\","]
#[doc = "            \"missing\","]
#[doc = "            \"valid\","]
#[doc = "            \"sum\","]
#[doc = "            \"product\","]
#[doc = "            \"mean\","]
#[doc = "            \"average\","]
#[doc = "            \"variance\","]
#[doc = "            \"variancep\","]
#[doc = "            \"stdev\","]
#[doc = "            \"stdevp\","]
#[doc = "            \"stderr\","]
#[doc = "            \"distinct\","]
#[doc = "            \"ci0\","]
#[doc = "            \"ci1\","]
#[doc = "            \"median\","]
#[doc = "            \"q1\","]
#[doc = "            \"q3\","]
#[doc = "            \"min\","]
#[doc = "            \"max\","]
#[doc = "            \"argmin\","]
#[doc = "            \"argmax\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"pivot\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct PivotTransform {
    pub field: PivotTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<PivotTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub key: Option<PivotTransformKey>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub limit: Option<PivotTransformLimit>,
    #[serde(default = "defaults::pivot_transform_op")]
    pub op: PivotTransformOp,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: PivotTransformType,
    pub value: PivotTransformValue,
}
impl From<&Self> for PivotTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "PivotTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PivotTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PivotTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PivotTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PivotTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PivotTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformGroupby {
    Variant0(Vec<PivotTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for PivotTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<PivotTransformGroupbyVariant0Item>> for PivotTransformGroupby {
    fn from(value: Vec<PivotTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PivotTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PivotTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PivotTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PivotTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PivotTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PivotTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PivotTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PivotTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PivotTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PivotTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PivotTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "PivotTransformLimit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformLimit {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for PivotTransformLimit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for PivotTransformLimit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PivotTransformLimit {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PivotTransformOp"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"sum\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformOp {
    Variant0(PivotTransformOpVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for PivotTransformOp {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for PivotTransformOp {
    fn default() -> Self {
        Self::Variant0(PivotTransformOpVariant0::Sum)
    }
}
impl From<PivotTransformOpVariant0> for PivotTransformOp {
    fn from(value: PivotTransformOpVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for PivotTransformOp {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "PivotTransformOpVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PivotTransformOpVariant0 {
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&Self> for PivotTransformOpVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for PivotTransformOpVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformOpVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PivotTransformOpVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PivotTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pivot\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum PivotTransformType {
    #[serde(rename = "pivot")]
    Pivot,
}
impl From<&Self> for PivotTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for PivotTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Pivot => "pivot".to_string(),
        }
    }
}
impl std::str::FromStr for PivotTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pivot" => Ok(Self::Pivot),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for PivotTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "PivotTransformValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum PivotTransformValue {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for PivotTransformValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for PivotTransformValue {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for PivotTransformValue {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for PivotTransformValue {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ProjectTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"project\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ProjectTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<ProjectTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<ProjectTransformFields>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ProjectTransformType,
}
impl From<&Self> for ProjectTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ProjectTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformAs {
    Variant0(Vec<ProjectTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ProjectTransformAsVariant0Item>> for ProjectTransformAs {
    fn from(value: Vec<ProjectTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for ProjectTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ProjectTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformFields {
    Variant0(Vec<ProjectTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ProjectTransformFieldsVariant0Item>> for ProjectTransformFields {
    fn from(value: Vec<ProjectTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectTransformFieldsVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for ProjectTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for ProjectTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for ProjectTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for ProjectTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ProjectTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"project\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ProjectTransformType {
    #[serde(rename = "project")]
    Project,
}
impl From<&Self> for ProjectTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ProjectTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Project => "project".to_string(),
        }
    }
}
impl std::str::FromStr for ProjectTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "project" => Ok(Self::Project),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ProjectTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Projection"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"center\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"clipAngle\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"clipExtent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"maxItems\": 2,"]
#[doc = "                \"minItems\": 2"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"maxItems\": 2,"]
#[doc = "                \"minItems\": 2"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fit\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"parallels\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pointRadius\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"precision\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"rotate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 3,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"translate\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Projection {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub center: Option<ProjectionCenter>,
    #[serde(rename = "clipAngle", default, skip_serializing_if = "Option::is_none")]
    pub clip_angle: Option<NumberOrSignal>,
    #[serde(
        rename = "clipExtent",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub clip_extent: Option<ProjectionClipExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<ProjectionExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fit: Option<ProjectionFit>,
    pub name: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parallels: Option<ProjectionParallels>,
    #[serde(
        rename = "pointRadius",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub point_radius: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub precision: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<ProjectionRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<NumberOrSignal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<ProjectionSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub translate: Option<ProjectionTranslate>,
    #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
    pub type_: Option<StringOrSignal>,
}
impl From<&Self> for Projection {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ProjectionCenter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionCenter {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionCenter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionCenter {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionCenter {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionClipExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionClipExtent {
    Variant0([ProjectionClipExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionClipExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[ProjectionClipExtentVariant0Item; 2usize]> for ProjectionClipExtent {
    fn from(value: [ProjectionClipExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionClipExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionClipExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionClipExtentVariant0Item {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionClipExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionClipExtentVariant0Item {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionClipExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            },"]
#[doc = "            \"maxItems\": 2,"]
#[doc = "            \"minItems\": 2"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionExtent {
    Variant0([ProjectionExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[ProjectionExtentVariant0Item; 2usize]> for ProjectionExtent {
    fn from(value: [ProjectionExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionExtentVariant0Item {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionExtentVariant0Item {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionFit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionFit {
    Variant0(serde_json::Map<String, serde_json::Value>),
    Variant1(Vec<serde_json::Value>),
}
impl From<&Self> for ProjectionFit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<serde_json::Map<String, serde_json::Value>> for ProjectionFit {
    fn from(value: serde_json::Map<String, serde_json::Value>) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<serde_json::Value>> for ProjectionFit {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionParallels"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionParallels {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionParallels {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionParallels {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionParallels {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionRotate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 3,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionRotate {
    Variant0(Vec<NumberOrSignal>),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionRotate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<NumberOrSignal>> for ProjectionRotate {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionRotate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionSize {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionSize {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ProjectionTranslate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ProjectionTranslate {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ProjectionTranslate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ProjectionTranslate {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ProjectionTranslate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"prob\","]
#[doc = "        \"value\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"probs\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 0.01,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"quantile\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct QuantileTransform {
    #[serde(rename = "as", default = "defaults::quantile_transform_as")]
    pub as_: QuantileTransformAs,
    pub field: QuantileTransformField,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<QuantileTransformGroupby>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub probs: Option<QuantileTransformProbs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::quantile_transform_step")]
    pub step: QuantileTransformStep,
    #[serde(rename = "type")]
    pub type_: QuantileTransformType,
}
impl From<&Self> for QuantileTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "QuantileTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"prob\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformAs {
    Variant0(Vec<QuantileTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for QuantileTransformAs {
    fn default() -> Self {
        Self::Variant0(vec![
            QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
}
impl From<Vec<QuantileTransformAsVariant0Item>> for QuantileTransformAs {
    fn from(value: Vec<QuantileTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for QuantileTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for QuantileTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for QuantileTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for QuantileTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for QuantileTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for QuantileTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "QuantileTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformGroupby {
    Variant0(Vec<QuantileTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<QuantileTransformGroupbyVariant0Item>> for QuantileTransformGroupby {
    fn from(value: Vec<QuantileTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for QuantileTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for QuantileTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for QuantileTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for QuantileTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for QuantileTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "QuantileTransformProbs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformProbs {
    Variant0(Vec<QuantileTransformProbsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformProbs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<QuantileTransformProbsVariant0Item>> for QuantileTransformProbs {
    fn from(value: Vec<QuantileTransformProbsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for QuantileTransformProbs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformProbsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformProbsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformProbsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for QuantileTransformProbsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for QuantileTransformProbsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 0.01,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum QuantileTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for QuantileTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for QuantileTransformStep {
    fn default() -> Self {
        Self::Variant0(0.01_f64)
    }
}
impl From<f64> for QuantileTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for QuantileTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "QuantileTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantile\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum QuantileTransformType {
    #[serde(rename = "quantile")]
    Quantile,
}
impl From<&Self> for QuantileTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for QuantileTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for QuantileTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for QuantileTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "RadialGradient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"gradient\","]
#[doc = "    \"stops\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gradient\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"radial\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"r1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"r2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"stops\": {"]
#[doc = "      \"$ref\": \"#/definitions/gradientStops\""]
#[doc = "    },"]
#[doc = "    \"x1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"x2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y1\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    \"y2\": {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RadialGradient {
    pub gradient: RadialGradientGradient,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub r2: Option<f64>,
    pub stops: GradientStops,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub x2: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y1: Option<f64>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub y2: Option<f64>,
}
impl From<&Self> for RadialGradient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "RadialGradientGradient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"radial\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RadialGradientGradient {
    #[serde(rename = "radial")]
    Radial,
}
impl From<&Self> for RadialGradientGradient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for RadialGradientGradient {
    fn to_string(&self) -> String {
        match *self {
            Self::Radial => "radial".to_string(),
        }
    }
}
impl std::str::FromStr for RadialGradientGradient {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "radial" => Ok(Self::Radial),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RadialGradientGradient {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "RegressionTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"linear\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"order\": {"]
#[doc = "      \"default\": 3,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"regression\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct RegressionTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<RegressionTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<RegressionTransformExtent>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<RegressionTransformGroupby>,
    #[serde(default = "defaults::regression_transform_method")]
    pub method: RegressionTransformMethod,
    #[serde(default = "defaults::regression_transform_order")]
    pub order: RegressionTransformOrder,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<RegressionTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: RegressionTransformType,
    pub x: RegressionTransformX,
    pub y: RegressionTransformY,
}
impl From<&Self> for RegressionTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "RegressionTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformAs {
    Variant0(Vec<RegressionTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<RegressionTransformAsVariant0Item>> for RegressionTransformAs {
    fn from(value: Vec<RegressionTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for RegressionTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformExtent {
    Variant0([RegressionTransformExtentVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[RegressionTransformExtentVariant0Item; 2usize]> for RegressionTransformExtent {
    fn from(value: [RegressionTransformExtentVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for RegressionTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformGroupby {
    Variant0(Vec<RegressionTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<RegressionTransformGroupbyVariant0Item>> for RegressionTransformGroupby {
    fn from(value: Vec<RegressionTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for RegressionTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for RegressionTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for RegressionTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for RegressionTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "RegressionTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"linear\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformMethod {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for RegressionTransformMethod {
    fn default() -> Self {
        Self::Variant0("linear".to_string())
    }
}
impl From<SignalRef> for RegressionTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformOrder"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 3,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformOrder {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformOrder {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for RegressionTransformOrder {
    fn default() -> Self {
        Self::Variant0(3_f64)
    }
}
impl From<f64> for RegressionTransformOrder {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformOrder {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformParams {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for RegressionTransformParams {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for RegressionTransformParams {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for RegressionTransformParams {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RegressionTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"regression\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum RegressionTransformType {
    #[serde(rename = "regression")]
    Regression,
}
impl From<&Self> for RegressionTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for RegressionTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Regression => "regression".to_string(),
        }
    }
}
impl std::str::FromStr for RegressionTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "regression" => Ok(Self::Regression),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for RegressionTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "RegressionTransformX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for RegressionTransformX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for RegressionTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for RegressionTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for RegressionTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "RegressionTransformY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum RegressionTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for RegressionTransformY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for RegressionTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for RegressionTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for RegressionTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "ResolvefilterTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"filter\","]
#[doc = "    \"ignore\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"filter\": {},"]
#[doc = "    \"ignore\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"resolvefilter\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ResolvefilterTransform {
    pub filter: serde_json::Value,
    pub ignore: ResolvefilterTransformIgnore,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: ResolvefilterTransformType,
}
impl From<&Self> for ResolvefilterTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ResolvefilterTransformIgnore"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ResolvefilterTransformIgnore {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for ResolvefilterTransformIgnore {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for ResolvefilterTransformIgnore {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ResolvefilterTransformIgnore {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ResolvefilterTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"resolvefilter\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ResolvefilterTransformType {
    #[serde(rename = "resolvefilter")]
    Resolvefilter,
}
impl From<&Self> for ResolvefilterTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ResolvefilterTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Resolvefilter => "resolvefilter".to_string(),
        }
    }
}
impl std::str::FromStr for ResolvefilterTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "resolvefilter" => Ok(Self::Resolvefilter),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ResolvefilterTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Rule"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"test\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Rule {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub test: Option<String>,
}
impl From<&Self> for Rule {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "SampleTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"default\": 1000,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"sample\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SampleTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::sample_transform_size")]
    pub size: SampleTransformSize,
    #[serde(rename = "type")]
    pub type_: SampleTransformType,
}
impl From<&Self> for SampleTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "SampleTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1000,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SampleTransformSize {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for SampleTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for SampleTransformSize {
    fn default() -> Self {
        Self::Variant0(1000_f64)
    }
}
impl From<f64> for SampleTransformSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for SampleTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SampleTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"sample\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SampleTransformType {
    #[serde(rename = "sample")]
    Sample,
}
impl From<&Self> for SampleTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for SampleTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sample => "sample".to_string(),
        }
    }
}
impl std::str::FromStr for SampleTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "sample" => Ok(Self::Sample),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SampleTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Scale"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"identity\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainImplicit\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"data\","]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"data\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"data\","]
#[doc = "                    \"fields\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"data\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    \"fields\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"minItems\": 1"]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"required\": ["]
#[doc = "                            \"field\","]
#[doc = "                            \"op\""]
#[doc = "                          ],"]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\","]
#[doc = "                                \"min\","]
#[doc = "                                \"max\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"fields\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"fields\": {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"object\","]
#[doc = "                            \"required\": ["]
#[doc = "                              \"data\","]
#[doc = "                              \"field\""]
#[doc = "                            ],"]
#[doc = "                            \"properties\": {"]
#[doc = "                              \"data\": {"]
#[doc = "                                \"type\": \"string\""]
#[doc = "                              },"]
#[doc = "                              \"field\": {"]
#[doc = "                                \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                              }"]
#[doc = "                            },"]
#[doc = "                            \"additionalProperties\": false"]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"type\": \"array\","]
#[doc = "                            \"items\": {"]
#[doc = "                              \"oneOf\": ["]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"string\""]
#[doc = "                                },"]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"number\""]
#[doc = "                                },"]
#[doc = "                                {"]
#[doc = "                                  \"type\": \"boolean\""]
#[doc = "                                }"]
#[doc = "                              ]"]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      },"]
#[doc = "                      \"minItems\": 1"]
#[doc = "                    },"]
#[doc = "                    \"sort\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"object\","]
#[doc = "                          \"required\": ["]
#[doc = "                            \"field\","]
#[doc = "                            \"op\""]
#[doc = "                          ],"]
#[doc = "                          \"properties\": {"]
#[doc = "                            \"field\": {"]
#[doc = "                              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                            },"]
#[doc = "                            \"op\": {"]
#[doc = "                              \"enum\": ["]
#[doc = "                                \"count\","]
#[doc = "                                \"min\","]
#[doc = "                                \"max\""]
#[doc = "                              ]"]
#[doc = "                            },"]
#[doc = "                            \"order\": {"]
#[doc = "                              \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                            }"]
#[doc = "                          },"]
#[doc = "                          \"additionalProperties\": false"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"ordinal\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingInner\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingOuter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"step\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"band\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"paddingOuter\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"step\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"point\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"quantize\","]
#[doc = "            \"threshold\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"quantile\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"bin-ordinal\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"interval\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"interval\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"millisecond\","]
#[doc = "                        \"second\","]
#[doc = "                        \"minute\","]
#[doc = "                        \"hour\","]
#[doc = "                        \"day\","]
#[doc = "                        \"week\","]
#[doc = "                        \"month\","]
#[doc = "                        \"year\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"step\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"time\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"linear\","]
#[doc = "            \"sqrt\","]
#[doc = "            \"sequential\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"base\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"log\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"exponent\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"pow\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bins\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleBins\""]
#[doc = "        },"]
#[doc = "        \"clamp\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"constant\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domain\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/scaleData\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"domainMax\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMid\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainMin\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"domainRaw\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interpolate\": {"]
#[doc = "          \"$ref\": \"#/definitions/scaleInterpolate\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"nice\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"padding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"range\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"width\","]
#[doc = "                \"height\","]
#[doc = "                \"symbol\","]
#[doc = "                \"category\","]
#[doc = "                \"ordinal\","]
#[doc = "                \"ramp\","]
#[doc = "                \"diverging\","]
#[doc = "                \"heatmap\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"null\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"boolean\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"number\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scheme\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"count\": {"]
#[doc = "                  \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                },"]
#[doc = "                \"extent\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "                      },"]
#[doc = "                      \"maxItems\": 2,"]
#[doc = "                      \"minItems\": 2"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"scheme\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"oneOf\": ["]
#[doc = "                          {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          },"]
#[doc = "                          {"]
#[doc = "                            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                          }"]
#[doc = "                        ]"]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"reverse\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"round\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"symlog\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"zero\": {"]
#[doc = "          \"$ref\": \"#/definitions/booleanOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Scale {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant0Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant0DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant0Type,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant1Domain>,
        #[serde(
            rename = "domainImplicit",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        domain_implicit: Option<BooleanOrSignal>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant1DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant1Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant1Type,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant2Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant2DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingInner",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_inner: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant2Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant2Type,
    },
    Variant3 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant3Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant3DomainRaw>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(
            rename = "paddingOuter",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        padding_outer: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant3Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant3Type,
    },
    Variant4 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant4Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant4DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant4Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant4Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant4Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant5 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant5Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant5DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant5Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant5Type,
    },
    Variant6 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant6Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant6DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant6Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant6Type,
    },
    Variant7 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant7Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant7DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant7Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant7Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant7Type,
    },
    Variant8 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant8Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant8DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant8Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant8Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type", default, skip_serializing_if = "Option::is_none")]
        type_: Option<ScaleVariant8Type>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant9 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        base: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant9Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant9DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant9Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant9Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant9Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant10 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant10Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant10DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        exponent: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant10Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant10Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant10Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
    Variant11 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bins: Option<ScaleBins>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        clamp: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        constant: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        domain: Option<ScaleVariant11Domain>,
        #[serde(rename = "domainMax", default, skip_serializing_if = "Option::is_none")]
        domain_max: Option<NumberOrSignal>,
        #[serde(rename = "domainMid", default, skip_serializing_if = "Option::is_none")]
        domain_mid: Option<NumberOrSignal>,
        #[serde(rename = "domainMin", default, skip_serializing_if = "Option::is_none")]
        domain_min: Option<NumberOrSignal>,
        #[serde(rename = "domainRaw", default, skip_serializing_if = "Option::is_none")]
        domain_raw: Option<ScaleVariant11DomainRaw>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interpolate: Option<ScaleInterpolate>,
        name: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        nice: Option<ScaleVariant11Nice>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        range: Option<ScaleVariant11Range>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        reverse: Option<BooleanOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        round: Option<BooleanOrSignal>,
        #[serde(rename = "type")]
        type_: ScaleVariant11Type,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zero: Option<BooleanOrSignal>,
    },
}
impl From<&Self> for Scale {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ScaleBins"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"start\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"stop\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleBins {
    Variant0(Vec<NumberOrSignal>),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        start: Option<NumberOrSignal>,
        step: NumberOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        stop: Option<NumberOrSignal>,
    },
    Variant2(SignalRef),
}
impl From<&Self> for ScaleBins {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<NumberOrSignal>> for ScaleBins {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleBins {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleData"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"data\","]
#[doc = "                  \"field\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"data\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"field\": {"]
#[doc = "                    \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleData {
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleDataVariant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleDataVariant2Sort>,
    },
}
impl From<&Self> for ScaleData {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ScaleDataVariant0Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleDataVariant0Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleDataVariant0Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleDataVariant1Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleDataVariant1Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleDataVariant1Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleDataVariant1SortVariant1Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&Self> for ScaleDataVariant1SortVariant1Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleDataVariant1SortVariant2Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&Self> for ScaleDataVariant1SortVariant2Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant1SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleDataVariant2FieldsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2FieldsItem {
    Variant0 { data: String, field: StringOrSignal },
    Variant1(Vec<ScaleDataVariant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleDataVariant2FieldsItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleDataVariant2FieldsItemVariant1Item>> for ScaleDataVariant2FieldsItem {
    fn from(value: Vec<ScaleDataVariant2FieldsItemVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleDataVariant2FieldsItem {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleDataVariant2FieldsItemVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleDataVariant2FieldsItemVariant1Item {
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
impl From<&Self> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ScaleDataVariant2FieldsItemVariant1Item {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for ScaleDataVariant2FieldsItemVariant1Item {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
            Self::Variant2(x) => x.to_string(),
        }
    }
}
impl From<f64> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<bool> for ScaleDataVariant2FieldsItemVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleDataVariant2Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleDataVariant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleDataVariant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleDataVariant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleDataVariant2Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleDataVariant2Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleDataVariant2SortVariant1Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&Self> for ScaleDataVariant2SortVariant1Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleDataVariant2SortVariant2Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleDataVariant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&Self> for ScaleDataVariant2SortVariant2Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleDataVariant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleDataVariant2SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleDataVariant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ScaleField(pub StringOrSignal);
impl std::ops::Deref for ScaleField {
    type Target = StringOrSignal;
    fn deref(&self) -> &StringOrSignal {
        &self.0
    }
}
impl From<ScaleField> for StringOrSignal {
    fn from(value: ScaleField) -> Self {
        value.0
    }
}
impl From<&Self> for ScaleField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringOrSignal> for ScaleField {
    fn from(value: StringOrSignal) -> Self {
        Self(value)
    }
}
#[doc = "ScaleInterpolate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"gamma\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleInterpolate {
    Variant0(String),
    Variant1(SignalRef),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        gamma: Option<NumberOrSignal>,
        #[serde(rename = "type")]
        type_: StringOrSignal,
    },
}
impl From<&Self> for ScaleInterpolate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleInterpolate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant0Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0Domain {
    Variant0(Vec<ScaleVariant0DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant0Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant0DomainVariant0Item>> for ScaleVariant0Domain {
    fn from(value: Vec<ScaleVariant0DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant0Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant0Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant0DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant0DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant0DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant0DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant0DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant0DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant0DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant0DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant0DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant0DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant0DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant0Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"identity\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant0Type {
    #[serde(rename = "identity")]
    Identity,
}
impl From<&Self> for ScaleVariant0Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant0Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Identity => "identity".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "identity" => Ok(Self::Identity),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant10Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10Domain {
    Variant0(Vec<ScaleVariant10DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant10Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant10DomainVariant0Item>> for ScaleVariant10Domain {
    fn from(value: Vec<ScaleVariant10DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant10Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant10Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant10DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant10DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant10DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant10DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant10DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant10DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant10DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant10DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant10DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant10DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant10Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant10Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant10Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for ScaleVariant10Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant10Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant10Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant10Range {
    Variant0(ScaleVariant10RangeVariant0),
    Variant1(Vec<ScaleVariant10RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant10RangeVariant2Extent>,
        scheme: ScaleVariant10RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant10Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant10RangeVariant0> for ScaleVariant10Range {
    fn from(value: ScaleVariant10RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant10RangeVariant1Item>> for ScaleVariant10Range {
    fn from(value: Vec<ScaleVariant10RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant10Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant10RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant10RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant10RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant10RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant10RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant10RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant10RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant10RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant10RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant10RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant10RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant10RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant10RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant10RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant10RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant10RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant10RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>>
    for ScaleVariant10RangeVariant2Scheme
{
    fn from(value: Vec<ScaleVariant10RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant10RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant10RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant10RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant10RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant10RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant10Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"pow\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant10Type {
    #[serde(rename = "pow")]
    Pow,
}
impl From<&Self> for ScaleVariant10Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant10Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Pow => "pow".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant10Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "pow" => Ok(Self::Pow),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant11Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11Domain {
    Variant0(Vec<ScaleVariant11DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant11Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant11DomainVariant0Item>> for ScaleVariant11Domain {
    fn from(value: Vec<ScaleVariant11DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant11Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant11Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant11DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant11DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant11DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant11DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant11DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant11DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant11DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant11DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant11DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant11DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant11Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant11Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant11Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for ScaleVariant11Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant11Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant11Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant11Range {
    Variant0(ScaleVariant11RangeVariant0),
    Variant1(Vec<ScaleVariant11RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant11RangeVariant2Extent>,
        scheme: ScaleVariant11RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant11Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant11RangeVariant0> for ScaleVariant11Range {
    fn from(value: ScaleVariant11RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant11RangeVariant1Item>> for ScaleVariant11Range {
    fn from(value: Vec<ScaleVariant11RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant11Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant11RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant11RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant11RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant11RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant11RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant11RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant11RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant11RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant11RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant11RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant11RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant11RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant11RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant11RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant11RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant11RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant11RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>>
    for ScaleVariant11RangeVariant2Scheme
{
    fn from(value: Vec<ScaleVariant11RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant11RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant11RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant11RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant11RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant11RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant11Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"symlog\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant11Type {
    #[serde(rename = "symlog")]
    Symlog,
}
impl From<&Self> for ScaleVariant11Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant11Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Symlog => "symlog".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant11Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "symlog" => Ok(Self::Symlog),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant11Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1Domain {
    Variant0(Vec<ScaleVariant1DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant1Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant1DomainVariant0Item>> for ScaleVariant1Domain {
    fn from(value: Vec<ScaleVariant1DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant1Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant1Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant1DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant1DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant1DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant1DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant1DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant1DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant1DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant1DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant1DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant1DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant1Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"field\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"field\": {"]
#[doc = "              \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data\","]
#[doc = "            \"fields\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\","]
#[doc = "                    \"op\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\","]
#[doc = "                        \"min\","]
#[doc = "                        \"max\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"fields\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"fields\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"data\","]
#[doc = "                      \"field\""]
#[doc = "                    ],"]
#[doc = "                    \"properties\": {"]
#[doc = "                      \"data\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      },"]
#[doc = "                      \"field\": {"]
#[doc = "                        \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                      }"]
#[doc = "                    },"]
#[doc = "                    \"additionalProperties\": false"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"array\","]
#[doc = "                    \"items\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            },"]
#[doc = "            \"sort\": {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"type\": \"boolean\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\","]
#[doc = "                    \"op\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                    },"]
#[doc = "                    \"op\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"count\","]
#[doc = "                        \"min\","]
#[doc = "                        \"max\""]
#[doc = "                      ]"]
#[doc = "                    },"]
#[doc = "                    \"order\": {"]
#[doc = "                      \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                    }"]
#[doc = "                  },"]
#[doc = "                  \"additionalProperties\": false"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": false"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1Range {
    Variant0(ScaleVariant1RangeVariant0),
    Variant1(Vec<ScaleVariant1RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant1RangeVariant2Extent>,
        scheme: ScaleVariant1RangeVariant2Scheme,
    },
    Variant3(ScaleVariant1RangeVariant3),
    Variant4(SignalRef),
}
impl From<&Self> for ScaleVariant1Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant1RangeVariant0> for ScaleVariant1Range {
    fn from(value: ScaleVariant1RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant1RangeVariant1Item>> for ScaleVariant1Range {
    fn from(value: Vec<ScaleVariant1RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<ScaleVariant1RangeVariant3> for ScaleVariant1Range {
    fn from(value: ScaleVariant1RangeVariant3) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant1Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
#[doc = "ScaleVariant1RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant1RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant1RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant1RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant1RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant1RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant1RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant1RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant1RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant1RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant1RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant1RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant1RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant1RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant1RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant1RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant1RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"fields\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"fields\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"object\","]
#[doc = "                \"required\": ["]
#[doc = "                  \"data\","]
#[doc = "                  \"field\""]
#[doc = "                ],"]
#[doc = "                \"properties\": {"]
#[doc = "                  \"data\": {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  \"field\": {"]
#[doc = "                    \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                \"additionalProperties\": false"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"array\","]
#[doc = "                \"items\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"minItems\": 1"]
#[doc = "        },"]
#[doc = "        \"sort\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\","]
#[doc = "                \"op\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "                },"]
#[doc = "                \"op\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"count\","]
#[doc = "                    \"min\","]
#[doc = "                    \"max\""]
#[doc = "                  ]"]
#[doc = "                },"]
#[doc = "                \"order\": {"]
#[doc = "                  \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3 {
    Variant0 {
        data: String,
        field: StringOrSignal,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant0Sort>,
    },
    Variant1 {
        data: String,
        fields: Vec<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant1Sort>,
    },
    Variant2 {
        fields: Vec<ScaleVariant1RangeVariant3Variant2FieldsItem>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        sort: Option<ScaleVariant1RangeVariant3Variant2Sort>,
    },
}
impl From<&Self> for ScaleVariant1RangeVariant3 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant0Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant0Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        field: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<StringOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant0Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant1RangeVariant3Variant0Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant1Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant1Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant1SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant1SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant1Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant1RangeVariant3Variant1Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant1SortVariant1Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant1SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant1SortVariant2Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant1SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant2FieldsItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"data\","]
#[doc = "        \"field\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"data\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItem {
    Variant0 { data: String, field: StringOrSignal },
    Variant1(Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant2FieldsItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>>
    for ScaleVariant1RangeVariant3Variant2FieldsItem
{
    fn from(value: Vec<ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant1RangeVariant3Variant2FieldsItem {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    Variant0(String),
    Variant1(f64),
    Variant2(bool),
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant2(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
            Self::Variant2(x) => x.to_string(),
        }
    }
}
impl From<f64> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<bool> for ScaleVariant1RangeVariant3Variant2FieldsItemVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant2Sort"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"field\","]
#[doc = "        \"op\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"field\": {"]
#[doc = "          \"$ref\": \"#/definitions/stringOrSignal\""]
#[doc = "        },"]
#[doc = "        \"op\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"count\","]
#[doc = "            \"min\","]
#[doc = "            \"max\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"order\": {"]
#[doc = "          \"$ref\": \"#/definitions/sortOrder\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant1RangeVariant3Variant2Sort {
    Variant0(bool),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        op: Option<ScaleVariant1RangeVariant3Variant2SortVariant1Op>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
    Variant2 {
        field: StringOrSignal,
        op: ScaleVariant1RangeVariant3Variant2SortVariant2Op,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        order: Option<SortOrder>,
    },
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant2Sort {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant1RangeVariant3Variant2Sort {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant2SortVariant1Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    #[serde(rename = "count")]
    Count,
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2SortVariant1Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1RangeVariant3Variant2SortVariant2Op"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"count\","]
#[doc = "    \"min\","]
#[doc = "    \"max\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
}
impl From<&Self> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    fn to_string(&self) -> String {
        match *self {
            Self::Count => "count".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "count" => Ok(Self::Count),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1RangeVariant3Variant2SortVariant2Op {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant1Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"ordinal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant1Type {
    #[serde(rename = "ordinal")]
    Ordinal,
}
impl From<&Self> for ScaleVariant1Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant1Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Ordinal => "ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "ordinal" => Ok(Self::Ordinal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant2Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2Domain {
    Variant0(Vec<ScaleVariant2DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant2Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant2DomainVariant0Item>> for ScaleVariant2Domain {
    fn from(value: Vec<ScaleVariant2DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant2Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant2Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant2DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant2DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant2DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant2DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant2DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant2DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant2DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant2DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant2DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant2DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant2Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant2Range {
    Variant0(ScaleVariant2RangeVariant0),
    Variant1(Vec<ScaleVariant2RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant2Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant2RangeVariant0> for ScaleVariant2Range {
    fn from(value: ScaleVariant2RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant2RangeVariant1Item>> for ScaleVariant2Range {
    fn from(value: Vec<ScaleVariant2RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant2Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant2RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant2RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant2RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant2RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant2RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant2RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant2RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant2RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant2RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant2RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant2RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant2RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant2Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"band\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant2Type {
    #[serde(rename = "band")]
    Band,
}
impl From<&Self> for ScaleVariant2Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant2Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Band => "band".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "band" => Ok(Self::Band),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant3Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3Domain {
    Variant0(Vec<ScaleVariant3DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant3Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant3DomainVariant0Item>> for ScaleVariant3Domain {
    fn from(value: Vec<ScaleVariant3DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant3Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant3Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant3DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant3DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant3DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant3DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant3DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant3DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant3DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant3DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant3DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant3DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"step\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant3Range {
    Variant0(ScaleVariant3RangeVariant0),
    Variant1(Vec<ScaleVariant3RangeVariant1Item>),
    Variant2 { step: NumberOrSignal },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant3RangeVariant0> for ScaleVariant3Range {
    fn from(value: ScaleVariant3RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant3RangeVariant1Item>> for ScaleVariant3Range {
    fn from(value: Vec<ScaleVariant3RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant3Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant3RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant3RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant3RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant3RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant3RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant3RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant3RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant3RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant3RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant3RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant3RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant3RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant3Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"point\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant3Type {
    #[serde(rename = "point")]
    Point,
}
impl From<&Self> for ScaleVariant3Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant3Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Point => "point".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "point" => Ok(Self::Point),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant4Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4Domain {
    Variant0(Vec<ScaleVariant4DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant4Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant4DomainVariant0Item>> for ScaleVariant4Domain {
    fn from(value: Vec<ScaleVariant4DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant4Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant4Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant4DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant4DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant4DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant4DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant4DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant4DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant4DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant4DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant4DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant4DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant4Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant4Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant4Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for ScaleVariant4Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant4Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant4Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant4Range {
    Variant0(ScaleVariant4RangeVariant0),
    Variant1(Vec<ScaleVariant4RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant4RangeVariant2Extent>,
        scheme: ScaleVariant4RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant4Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant4RangeVariant0> for ScaleVariant4Range {
    fn from(value: ScaleVariant4RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant4RangeVariant1Item>> for ScaleVariant4Range {
    fn from(value: Vec<ScaleVariant4RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant4Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant4RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant4RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant4RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant4RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant4RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant4RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant4RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant4RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant4RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant4RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant4RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant4RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant4RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant4RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant4RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant4RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant4RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant4RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant4RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant4RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant4RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant4RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant4Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantize\","]
#[doc = "    \"threshold\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant4Type {
    #[serde(rename = "quantize")]
    Quantize,
    #[serde(rename = "threshold")]
    Threshold,
}
impl From<&Self> for ScaleVariant4Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant4Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantize => "quantize".to_string(),
            Self::Threshold => "threshold".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant4Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "quantize" => Ok(Self::Quantize),
            "threshold" => Ok(Self::Threshold),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant5Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5Domain {
    Variant0(Vec<ScaleVariant5DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant5Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant5DomainVariant0Item>> for ScaleVariant5Domain {
    fn from(value: Vec<ScaleVariant5DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant5Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant5Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant5DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant5DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant5DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant5DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant5DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant5DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant5DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant5DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant5DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant5DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant5Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant5Range {
    Variant0(ScaleVariant5RangeVariant0),
    Variant1(Vec<ScaleVariant5RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant5RangeVariant2Extent>,
        scheme: ScaleVariant5RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant5Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant5RangeVariant0> for ScaleVariant5Range {
    fn from(value: ScaleVariant5RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant5RangeVariant1Item>> for ScaleVariant5Range {
    fn from(value: Vec<ScaleVariant5RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant5Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant5RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant5RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant5RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant5RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant5RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant5RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant5RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant5RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant5RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant5RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant5RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant5RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant5RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant5RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant5RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant5RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant5RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant5RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant5RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant5RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant5RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant5RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant5Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"quantile\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant5Type {
    #[serde(rename = "quantile")]
    Quantile,
}
impl From<&Self> for ScaleVariant5Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant5Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Quantile => "quantile".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant5Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "quantile" => Ok(Self::Quantile),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant6Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6Domain {
    Variant0(Vec<ScaleVariant6DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant6Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant6DomainVariant0Item>> for ScaleVariant6Domain {
    fn from(value: Vec<ScaleVariant6DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant6Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant6Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant6DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant6DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant6DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant6DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant6DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant6DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant6DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant6DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant6DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant6DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant6Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant6Range {
    Variant0(ScaleVariant6RangeVariant0),
    Variant1(Vec<ScaleVariant6RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant6RangeVariant2Extent>,
        scheme: ScaleVariant6RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant6Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant6RangeVariant0> for ScaleVariant6Range {
    fn from(value: ScaleVariant6RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant6RangeVariant1Item>> for ScaleVariant6Range {
    fn from(value: Vec<ScaleVariant6RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant6Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant6RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant6RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant6RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant6RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant6RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant6RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant6RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant6RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant6RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant6RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant6RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant6RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant6RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant6RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant6RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant6RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant6RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant6RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant6RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant6RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant6RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant6RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant6Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"bin-ordinal\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant6Type {
    #[serde(rename = "bin-ordinal")]
    BinOrdinal,
}
impl From<&Self> for ScaleVariant6Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant6Type {
    fn to_string(&self) -> String {
        match *self {
            Self::BinOrdinal => "bin-ordinal".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant6Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "bin-ordinal" => Ok(Self::BinOrdinal),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant7Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7Domain {
    Variant0(Vec<ScaleVariant7DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant7Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant7DomainVariant0Item>> for ScaleVariant7Domain {
    fn from(value: Vec<ScaleVariant7DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant7Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant7Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant7DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant7DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant7DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant7DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant7DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant7DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant7DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant7DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant7DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant7DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant7Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"interval\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"interval\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Nice {
    Variant0(bool),
    Variant1(ScaleVariant7NiceVariant1),
    Variant2 {
        interval: ScaleVariant7NiceVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
}
impl From<&Self> for ScaleVariant7Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant7Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleVariant7NiceVariant1> for ScaleVariant7Nice {
    fn from(value: ScaleVariant7NiceVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant7NiceVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7NiceVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&Self> for ScaleVariant7NiceVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7NiceVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7NiceVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant7NiceVariant2Interval"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7NiceVariant2Interval {
    Variant0(ScaleVariant7NiceVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant7NiceVariant2Interval {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant7NiceVariant2IntervalVariant0> for ScaleVariant7NiceVariant2Interval {
    fn from(value: ScaleVariant7NiceVariant2IntervalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant7NiceVariant2Interval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant7NiceVariant2IntervalVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7NiceVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&Self> for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7NiceVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7NiceVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant7Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant7Range {
    Variant0(ScaleVariant7RangeVariant0),
    Variant1(Vec<ScaleVariant7RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant7RangeVariant2Extent>,
        scheme: ScaleVariant7RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant7Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant7RangeVariant0> for ScaleVariant7Range {
    fn from(value: ScaleVariant7RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant7RangeVariant1Item>> for ScaleVariant7Range {
    fn from(value: Vec<ScaleVariant7RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant7Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant7RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant7RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant7RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant7RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant7RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant7RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant7RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant7RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant7RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant7RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant7RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant7RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant7RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant7RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant7RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant7RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant7RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant7RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant7RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant7Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"time\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant7Type {
    #[serde(rename = "time")]
    Time,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for ScaleVariant7Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant7Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Time => "time".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant7Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "time" => Ok(Self::Time),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant8Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8Domain {
    Variant0(Vec<ScaleVariant8DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant8Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant8DomainVariant0Item>> for ScaleVariant8Domain {
    fn from(value: Vec<ScaleVariant8DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant8Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant8Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant8DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant8DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant8DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant8DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant8DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant8DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant8DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant8DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant8DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant8DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant8Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant8Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant8Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for ScaleVariant8Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant8Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant8Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant8Range {
    Variant0(ScaleVariant8RangeVariant0),
    Variant1(Vec<ScaleVariant8RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant8RangeVariant2Extent>,
        scheme: ScaleVariant8RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant8Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant8RangeVariant0> for ScaleVariant8Range {
    fn from(value: ScaleVariant8RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant8RangeVariant1Item>> for ScaleVariant8Range {
    fn from(value: Vec<ScaleVariant8RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant8Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant8RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant8RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant8RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant8RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant8RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant8RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant8RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant8RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant8RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant8RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant8RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant8RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant8RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant8RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant8RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant8RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant8RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant8RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant8RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant8RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant8RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant8RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant8Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"linear\","]
#[doc = "    \"sqrt\","]
#[doc = "    \"sequential\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant8Type {
    #[serde(rename = "linear")]
    Linear,
    #[serde(rename = "sqrt")]
    Sqrt,
    #[serde(rename = "sequential")]
    Sequential,
}
impl From<&Self> for ScaleVariant8Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant8Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Linear => "linear".to_string(),
            Self::Sqrt => "sqrt".to_string(),
            Self::Sequential => "sequential".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant8Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "linear" => Ok(Self::Linear),
            "sqrt" => Ok(Self::Sqrt),
            "sequential" => Ok(Self::Sequential),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant9Domain"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleData\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9Domain {
    Variant0(Vec<ScaleVariant9DomainVariant0Item>),
    Variant1(ScaleData),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant9Domain {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant9DomainVariant0Item>> for ScaleVariant9Domain {
    fn from(value: Vec<ScaleVariant9DomainVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<ScaleData> for ScaleVariant9Domain {
    fn from(value: ScaleData) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant9Domain {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant9DomainRaw"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9DomainRaw {
    Variant0,
    Variant1(Vec<serde_json::Value>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant9DomainRaw {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<serde_json::Value>> for ScaleVariant9DomainRaw {
    fn from(value: Vec<serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant9DomainRaw {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant9DomainVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9DomainVariant0Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant9DomainVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant9DomainVariant0Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant9DomainVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant9DomainVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant9DomainVariant0Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant9Nice"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9Nice {
    Variant0(bool),
    Variant1(f64),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant9Nice {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant9Nice {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<f64> for ScaleVariant9Nice {
    fn from(value: f64) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant9Nice {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant9Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"width\","]
#[doc = "        \"height\","]
#[doc = "        \"symbol\","]
#[doc = "        \"category\","]
#[doc = "        \"ordinal\","]
#[doc = "        \"ramp\","]
#[doc = "        \"diverging\","]
#[doc = "        \"heatmap\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"boolean\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"scheme\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"extent\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "              },"]
#[doc = "              \"maxItems\": 2,"]
#[doc = "              \"minItems\": 2"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"scheme\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"oneOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"type\": \"string\""]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum ScaleVariant9Range {
    Variant0(ScaleVariant9RangeVariant0),
    Variant1(Vec<ScaleVariant9RangeVariant1Item>),
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        count: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        extent: Option<ScaleVariant9RangeVariant2Extent>,
        scheme: ScaleVariant9RangeVariant2Scheme,
    },
    Variant3(SignalRef),
}
impl From<&Self> for ScaleVariant9Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleVariant9RangeVariant0> for ScaleVariant9Range {
    fn from(value: ScaleVariant9RangeVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ScaleVariant9RangeVariant1Item>> for ScaleVariant9Range {
    fn from(value: Vec<ScaleVariant9RangeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant9Range {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "ScaleVariant9RangeVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"width\","]
#[doc = "    \"height\","]
#[doc = "    \"symbol\","]
#[doc = "    \"category\","]
#[doc = "    \"ordinal\","]
#[doc = "    \"ramp\","]
#[doc = "    \"diverging\","]
#[doc = "    \"heatmap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant9RangeVariant0 {
    #[serde(rename = "width")]
    Width,
    #[serde(rename = "height")]
    Height,
    #[serde(rename = "symbol")]
    Symbol,
    #[serde(rename = "category")]
    Category,
    #[serde(rename = "ordinal")]
    Ordinal,
    #[serde(rename = "ramp")]
    Ramp,
    #[serde(rename = "diverging")]
    Diverging,
    #[serde(rename = "heatmap")]
    Heatmap,
}
impl From<&Self> for ScaleVariant9RangeVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant9RangeVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Width => "width".to_string(),
            Self::Height => "height".to_string(),
            Self::Symbol => "symbol".to_string(),
            Self::Category => "category".to_string(),
            Self::Ordinal => "ordinal".to_string(),
            Self::Ramp => "ramp".to_string(),
            Self::Diverging => "diverging".to_string(),
            Self::Heatmap => "heatmap".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9RangeVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "width" => Ok(Self::Width),
            "height" => Ok(Self::Height),
            "symbol" => Ok(Self::Symbol),
            "category" => Ok(Self::Category),
            "ordinal" => Ok(Self::Ordinal),
            "ramp" => Ok(Self::Ramp),
            "diverging" => Ok(Self::Diverging),
            "heatmap" => Ok(Self::Heatmap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant9RangeVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "ScaleVariant9RangeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant1Item {
    Variant0,
    Variant1(bool),
    Variant2(String),
    Variant3(f64),
    Variant4(SignalRef),
    Variant5(Vec<NumberOrSignal>),
}
impl From<&Self> for ScaleVariant9RangeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for ScaleVariant9RangeVariant1Item {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
impl From<f64> for ScaleVariant9RangeVariant1Item {
    fn from(value: f64) -> Self {
        Self::Variant3(value)
    }
}
impl From<SignalRef> for ScaleVariant9RangeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant4(value)
    }
}
impl From<Vec<NumberOrSignal>> for ScaleVariant9RangeVariant1Item {
    fn from(value: Vec<NumberOrSignal>) -> Self {
        Self::Variant5(value)
    }
}
#[doc = "ScaleVariant9RangeVariant2Extent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Extent {
    Variant0([NumberOrSignal; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant9RangeVariant2Extent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[NumberOrSignal; 2usize]> for ScaleVariant9RangeVariant2Extent {
    fn from(value: [NumberOrSignal; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for ScaleVariant9RangeVariant2Extent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant9RangeVariant2Scheme"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2Scheme {
    Variant0(String),
    Variant1(Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>),
    Variant2(SignalRef),
}
impl From<&Self> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: Vec<ScaleVariant9RangeVariant2SchemeVariant1Item>) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for ScaleVariant9RangeVariant2Scheme {
    fn from(value: SignalRef) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "ScaleVariant9RangeVariant2SchemeVariant1Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScaleVariant9RangeVariant2SchemeVariant1Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for ScaleVariant9RangeVariant2SchemeVariant1Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for ScaleVariant9RangeVariant2SchemeVariant1Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ScaleVariant9Type"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"log\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum ScaleVariant9Type {
    #[serde(rename = "log")]
    Log,
}
impl From<&Self> for ScaleVariant9Type {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for ScaleVariant9Type {
    fn to_string(&self) -> String {
        match *self {
            Self::Log => "log".to_string(),
        }
    }
}
impl std::str::FromStr for ScaleVariant9Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "log" => Ok(Self::Log),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for ScaleVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Scope"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"axes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/axis\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/data\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"encode\": {"]
#[doc = "      \"$ref\": \"#/definitions/encode\""]
#[doc = "    },"]
#[doc = "    \"layout\": {"]
#[doc = "      \"$ref\": \"#/definitions/layout\""]
#[doc = "    },"]
#[doc = "    \"legends\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/legend\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"marks\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/markGroup\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/markVisual\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"projections\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/projection\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scales\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/scale\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"signals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/signal\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/title\""]
#[doc = "    },"]
#[doc = "    \"usermeta\": {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Scope {
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub axes: Vec<Axis>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub data: Vec<Data>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub encode: Option<Encode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub layout: Option<Layout>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub legends: Vec<Legend>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub marks: Vec<ScopeMarksItem>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub projections: Vec<Projection>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub scales: Vec<Scale>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub signals: Vec<Signal>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<Title>,
    #[serde(default, skip_serializing_if = "serde_json::Map::is_empty")]
    pub usermeta: serde_json::Map<String, serde_json::Value>,
}
impl From<&Self> for Scope {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "ScopeMarksItem"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markGroup\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/markVisual\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum ScopeMarksItem {
    Group(MarkGroup),
    Visual(MarkVisual),
}
impl From<&Self> for ScopeMarksItem {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MarkGroup> for ScopeMarksItem {
    fn from(value: MarkGroup) -> Self {
        Self::Group(value)
    }
}
impl From<MarkVisual> for ScopeMarksItem {
    fn from(value: MarkVisual) -> Self {
        Self::Visual(value)
    }
}
#[doc = "Selector"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct Selector(pub String);
impl std::ops::Deref for Selector {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<Selector> for String {
    fn from(value: Selector) -> Self {
        value.0
    }
}
impl From<&Self> for Selector {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<String> for Selector {
    fn from(value: String) -> Self {
        Self(value)
    }
}
impl std::str::FromStr for Selector {
    type Err = std::convert::Infallible;
    fn from_str(value: &str) -> Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ToString for Selector {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}
#[doc = "SequenceTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"start\","]
#[doc = "    \"stop\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"data\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stop\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"sequence\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct SequenceTransform {
    #[serde(rename = "as", default = "defaults::sequence_transform_as")]
    pub as_: SequenceTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    pub start: SequenceTransformStart,
    #[serde(default = "defaults::sequence_transform_step")]
    pub step: SequenceTransformStep,
    pub stop: SequenceTransformStop,
    #[serde(rename = "type")]
    pub type_: SequenceTransformType,
}
impl From<&Self> for SequenceTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "SequenceTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"data\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for SequenceTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for SequenceTransformAs {
    fn default() -> Self {
        Self::Variant0("data".to_string())
    }
}
impl From<SignalRef> for SequenceTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SequenceTransformStart"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStart {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for SequenceTransformStart {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for SequenceTransformStart {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for SequenceTransformStart {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SequenceTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for SequenceTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for SequenceTransformStep {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for SequenceTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for SequenceTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SequenceTransformStop"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SequenceTransformStop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for SequenceTransformStop {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for SequenceTransformStop {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for SequenceTransformStop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SequenceTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"sequence\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SequenceTransformType {
    #[serde(rename = "sequence")]
    Sequence,
}
impl From<&Self> for SequenceTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for SequenceTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Sequence => "sequence".to_string(),
        }
    }
}
impl std::str::FromStr for SequenceTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "sequence" => Ok(Self::Sequence),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SequenceTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Signal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\","]
#[doc = "        \"push\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"push\": {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"outer\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bind\": {"]
#[doc = "          \"$ref\": \"#/definitions/bind\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"react\": {"]
#[doc = "          \"default\": true,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"update\": {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        },"]
#[doc = "        \"value\": {}"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"init\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bind\": {"]
#[doc = "          \"$ref\": \"#/definitions/bind\""]
#[doc = "        },"]
#[doc = "        \"description\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"init\": {"]
#[doc = "          \"$ref\": \"#/definitions/exprString\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"$ref\": \"#/definitions/signalName\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"$ref\": \"#/definitions/onEvents\""]
#[doc = "        },"]
#[doc = "        \"value\": {}"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Signal {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        push: SignalVariant0Push,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default = "defaults::default_bool::<true>")]
        react: bool,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        update: Option<ExprString>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        bind: Option<Bind>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        description: Option<String>,
        init: ExprString,
        name: SignalName,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        on: Option<OnEvents>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        value: Option<serde_json::Value>,
    },
}
impl From<&Self> for Signal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "SignalName"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"not\": {"]
#[doc = "    \"enum\": ["]
#[doc = "      \"parent\","]
#[doc = "      \"datum\","]
#[doc = "      \"event\","]
#[doc = "      \"item\""]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct SignalName(String);
impl std::ops::Deref for SignalName {
    type Target = String;
    fn deref(&self) -> &String {
        &self.0
    }
}
impl From<SignalName> for String {
    fn from(value: SignalName) -> Self {
        value.0
    }
}
impl From<&Self> for SignalName {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::convert::TryFrom<String> for SignalName {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        if [
            "parent".to_string(),
            "datum".to_string(),
            "event".to_string(),
            "item".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> serde::Deserialize<'de> for SignalName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Self::try_from(<String>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "SignalRef"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"signal\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct SignalRef {
    pub signal: String,
}
impl From<&Self> for SignalRef {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "SignalVariant0Push"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"outer\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SignalVariant0Push {
    #[serde(rename = "outer")]
    Outer,
}
impl From<&Self> for SignalVariant0Push {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for SignalVariant0Push {
    fn to_string(&self) -> String {
        match *self {
            Self::Outer => "outer".to_string(),
        }
    }
}
impl std::str::FromStr for SignalVariant0Push {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "outer" => Ok(Self::Outer),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SignalVariant0Push {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "SortOrder"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"ascending\","]
#[doc = "        \"descending\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum SortOrder {
    Variant0(SortOrderVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for SortOrder {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SortOrderVariant0> for SortOrder {
    fn from(value: SortOrderVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for SortOrder {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "SortOrderVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"ascending\","]
#[doc = "    \"descending\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum SortOrderVariant0 {
    #[serde(rename = "ascending")]
    Ascending,
    #[serde(rename = "descending")]
    Descending,
}
impl From<&Self> for SortOrderVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for SortOrderVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Ascending => "ascending".to_string(),
            Self::Descending => "descending".to_string(),
        }
    }
}
impl std::str::FromStr for SortOrderVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "ascending" => Ok(Self::Ascending),
            "descending" => Ok(Self::Descending),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for SortOrderVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StackTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"y0\","]
#[doc = "        \"y1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"offset\": {"]
#[doc = "      \"default\": \"zero\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"zero\","]
#[doc = "            \"center\","]
#[doc = "            \"normalize\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"stack\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StackTransform {
    #[serde(rename = "as", default = "defaults::stack_transform_as")]
    pub as_: StackTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<StackTransformField>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<StackTransformGroupby>,
    #[serde(default = "defaults::stack_transform_offset")]
    pub offset: StackTransformOffset,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: StackTransformType,
}
impl From<&Self> for StackTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StackTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"y0\","]
#[doc = "    \"y1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformAs {
    Variant0([StackTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for StackTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for StackTransformAs {
    fn default() -> Self {
        Self::Variant0([
            StackTransformAsVariant0Item::Variant0("y0".to_string()),
            StackTransformAsVariant0Item::Variant0("y1".to_string()),
        ])
    }
}
impl From<[StackTransformAsVariant0Item; 2usize]> for StackTransformAs {
    fn from(value: [StackTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for StackTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StackTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for StackTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for StackTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StackTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for StackTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for StackTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for StackTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for StackTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "StackTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformGroupby {
    Variant0(Vec<StackTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for StackTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<StackTransformGroupbyVariant0Item>> for StackTransformGroupby {
    fn from(value: Vec<StackTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for StackTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StackTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for StackTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for StackTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for StackTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for StackTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "StackTransformOffset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"zero\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"zero\","]
#[doc = "        \"center\","]
#[doc = "        \"normalize\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StackTransformOffset {
    Variant0(StackTransformOffsetVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for StackTransformOffset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for StackTransformOffset {
    fn default() -> Self {
        Self::Variant0(StackTransformOffsetVariant0::Zero)
    }
}
impl From<StackTransformOffsetVariant0> for StackTransformOffset {
    fn from(value: StackTransformOffsetVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for StackTransformOffset {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StackTransformOffsetVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"zero\","]
#[doc = "    \"center\","]
#[doc = "    \"normalize\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StackTransformOffsetVariant0 {
    #[serde(rename = "zero")]
    Zero,
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "normalize")]
    Normalize,
}
impl From<&Self> for StackTransformOffsetVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StackTransformOffsetVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Zero => "zero".to_string(),
            Self::Center => "center".to_string(),
            Self::Normalize => "normalize".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformOffsetVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "zero" => Ok(Self::Zero),
            "center" => Ok(Self::Center),
            "normalize" => Ok(Self::Normalize),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StackTransformOffsetVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StackTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"stack\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StackTransformType {
    #[serde(rename = "stack")]
    Stack,
}
impl From<&Self> for StackTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StackTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stack => "stack".to_string(),
        }
    }
}
impl std::str::FromStr for StackTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "stack" => Ok(Self::Stack),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StackTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StratifyTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"key\","]
#[doc = "    \"parentKey\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"key\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"parentKey\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"stratify\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct StratifyTransform {
    pub key: StratifyTransformKey,
    #[serde(rename = "parentKey")]
    pub parent_key: StratifyTransformParentKey,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: StratifyTransformType,
}
impl From<&Self> for StratifyTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StratifyTransformKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StratifyTransformKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for StratifyTransformKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for StratifyTransformKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for StratifyTransformKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for StratifyTransformKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "StratifyTransformParentKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StratifyTransformParentKey {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for StratifyTransformParentKey {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for StratifyTransformParentKey {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for StratifyTransformParentKey {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for StratifyTransformParentKey {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "StratifyTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"stratify\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StratifyTransformType {
    #[serde(rename = "stratify")]
    Stratify,
}
impl From<&Self> for StratifyTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StratifyTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Stratify => "stratify".to_string(),
        }
    }
}
impl std::str::FromStr for StratifyTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "stratify" => Ok(Self::Stratify),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StratifyTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Stream"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"between\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/definitions/stream\""]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        \"consume\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"debounce\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        \"filter\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/exprString\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/exprString\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"markname\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"marktype\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"throttle\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"source\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"type\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stream\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"stream\": {"]
#[doc = "              \"$ref\": \"#/definitions/stream\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"merge\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"merge\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/definitions/stream\""]
#[doc = "              },"]
#[doc = "              \"minItems\": 1"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Stream {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        between: Option<[Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        consume: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<StreamVariant0Filter>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        markname: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        marktype: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        source: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        throttle: Option<f64>,
        #[serde(rename = "type")]
        type_: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        between: Option<[Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        consume: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<StreamVariant1Filter>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        markname: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        marktype: Option<String>,
        stream: Box<Stream>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        throttle: Option<f64>,
    },
    Variant2 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        between: Option<[Box<Stream>; 2usize]>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        consume: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        debounce: Option<f64>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        filter: Option<StreamVariant2Filter>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        markname: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        marktype: Option<String>,
        merge: Vec<Stream>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        throttle: Option<f64>,
    },
}
impl From<&Self> for Stream {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StreamVariant0Filter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StreamVariant0Filter {
    Variant0(ExprString),
    Variant1(Vec<ExprString>),
}
impl From<&Self> for StreamVariant0Filter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ExprString> for StreamVariant0Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ExprString>> for StreamVariant0Filter {
    fn from(value: Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StreamVariant1Filter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StreamVariant1Filter {
    Variant0(ExprString),
    Variant1(Vec<ExprString>),
}
impl From<&Self> for StreamVariant1Filter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ExprString> for StreamVariant1Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ExprString>> for StreamVariant1Filter {
    fn from(value: Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StreamVariant2Filter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/exprString\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/definitions/exprString\""]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StreamVariant2Filter {
    Variant0(ExprString),
    Variant1(Vec<ExprString>),
}
impl From<&Self> for StreamVariant2Filter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ExprString> for StreamVariant2Filter {
    fn from(value: ExprString) -> Self {
        Self::Variant0(value)
    }
}
impl From<Vec<ExprString>> for StreamVariant2Filter {
    fn from(value: Vec<ExprString>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StringModifiers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"scale\": {"]
#[doc = "      \"$ref\": \"#/definitions/field\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct StringModifiers {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub scale: Option<Field>,
}
impl From<&Self> for StringModifiers {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StringOrSignal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringOrSignal {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for StringOrSignal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for StringOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StringValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValue {
    Variant0(Vec<StringValueVariant0Item>),
    Variant1(StringValueVariant1),
}
impl From<&Self> for StringValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<StringValueVariant0Item>> for StringValue {
    fn from(value: Vec<StringValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<StringValueVariant1> for StringValue {
    fn from(value: StringValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StringValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: String,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: StringValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for StringValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StringValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StringValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StringValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StringValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StringValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StringValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StringValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StringValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StringValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StringValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: String,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: StringValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for StringValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StringValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StringValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StringValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StringValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StringValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StringValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StringValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StringValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StringValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StringValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeCapValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"butt\","]
#[doc = "                              \"round\","]
#[doc = "                              \"square\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"butt\","]
#[doc = "                        \"round\","]
#[doc = "                        \"square\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValue {
    Variant0(Vec<StrokeCapValueVariant0Item>),
    Variant1(StrokeCapValueVariant1),
}
impl From<&Self> for StrokeCapValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<StrokeCapValueVariant0Item>> for StrokeCapValue {
    fn from(value: Vec<StrokeCapValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<StrokeCapValueVariant1> for StrokeCapValue {
    fn from(value: StrokeCapValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeCapValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"butt\","]
#[doc = "                        \"round\","]
#[doc = "                        \"square\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: StrokeCapValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: StrokeCapValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for StrokeCapValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StrokeCapValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"butt\","]
#[doc = "    \"round\","]
#[doc = "    \"square\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeCapValueVariant0ItemVariant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl From<&Self> for StrokeCapValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StrokeCapValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StrokeCapValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StrokeCapValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeCapValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StrokeCapValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StrokeCapValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StrokeCapValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeCapValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"butt\","]
#[doc = "                    \"round\","]
#[doc = "                    \"square\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: StrokeCapValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: StrokeCapValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for StrokeCapValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StrokeCapValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"butt\","]
#[doc = "    \"round\","]
#[doc = "    \"square\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeCapValueVariant1Variant1Value {
    #[serde(rename = "butt")]
    Butt,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "square")]
    Square,
}
impl From<&Self> for StrokeCapValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StrokeCapValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Butt => "butt".to_string(),
            Self::Round => "round".to_string(),
            Self::Square => "square".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeCapValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "butt" => Ok(Self::Butt),
            "round" => Ok(Self::Round),
            "square" => Ok(Self::Square),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StrokeCapValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeCapValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StrokeCapValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeCapValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeCapValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeCapValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeCapValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StrokeCapValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StrokeCapValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StrokeCapValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeJoinValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"enum\": ["]
#[doc = "                              \"miter\","]
#[doc = "                              \"round\","]
#[doc = "                              \"bevel\""]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"miter\","]
#[doc = "                        \"round\","]
#[doc = "                        \"bevel\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValue {
    Variant0(Vec<StrokeJoinValueVariant0Item>),
    Variant1(StrokeJoinValueVariant1),
}
impl From<&Self> for StrokeJoinValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<StrokeJoinValueVariant0Item>> for StrokeJoinValue {
    fn from(value: Vec<StrokeJoinValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<StrokeJoinValueVariant1> for StrokeJoinValue {
    fn from(value: StrokeJoinValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeJoinValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"enum\": ["]
#[doc = "                        \"miter\","]
#[doc = "                        \"round\","]
#[doc = "                        \"bevel\""]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: StrokeJoinValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: StrokeJoinValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for StrokeJoinValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StrokeJoinValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"miter\","]
#[doc = "    \"round\","]
#[doc = "    \"bevel\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeJoinValueVariant0ItemVariant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl From<&Self> for StrokeJoinValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StrokeJoinValueVariant0ItemVariant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant0ItemVariant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant0ItemVariant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StrokeJoinValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StrokeJoinValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeJoinValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StrokeJoinValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StrokeJoinValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StrokeJoinValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "StrokeJoinValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"enum\": ["]
#[doc = "                    \"miter\","]
#[doc = "                    \"round\","]
#[doc = "                    \"bevel\""]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: StrokeJoinValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: StrokeJoinValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for StrokeJoinValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "StrokeJoinValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"miter\","]
#[doc = "    \"round\","]
#[doc = "    \"bevel\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum StrokeJoinValueVariant1Variant1Value {
    #[serde(rename = "miter")]
    Miter,
    #[serde(rename = "round")]
    Round,
    #[serde(rename = "bevel")]
    Bevel,
}
impl From<&Self> for StrokeJoinValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for StrokeJoinValueVariant1Variant1Value {
    fn to_string(&self) -> String {
        match *self {
            Self::Miter => "miter".to_string(),
            Self::Round => "round".to_string(),
            Self::Bevel => "bevel".to_string(),
        }
    }
}
impl std::str::FromStr for StrokeJoinValueVariant1Variant1Value {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "miter" => Ok(Self::Miter),
            "round" => Ok(Self::Round),
            "bevel" => Ok(Self::Bevel),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant1Variant1Value {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "StrokeJoinValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum StrokeJoinValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for StrokeJoinValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for StrokeJoinValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for StrokeJoinValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for StrokeJoinValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for StrokeJoinValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for StrokeJoinValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for StrokeJoinValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for StrokeJoinValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Style"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Style {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for Style {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for Style {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextOrSignal"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextOrSignal {
    Variant0(TextOrSignalVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TextOrSignal {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TextOrSignalVariant0> for TextOrSignal {
    fn from(value: TextOrSignalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TextOrSignal {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextOrSignalVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextOrSignalVariant0 {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for TextOrSignalVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for TextOrSignalVariant0 {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"allOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/rule\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"allOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"anyOf\": ["]
#[doc = "                  {"]
#[doc = "                    \"oneOf\": ["]
#[doc = "                      {"]
#[doc = "                        \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"value\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"value\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"string\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"array\","]
#[doc = "                                \"items\": {"]
#[doc = "                                  \"type\": \"string\""]
#[doc = "                                }"]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"field\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"field\": {"]
#[doc = "                            \"$ref\": \"#/definitions/field\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      },"]
#[doc = "                      {"]
#[doc = "                        \"type\": \"object\","]
#[doc = "                        \"required\": ["]
#[doc = "                          \"range\""]
#[doc = "                        ],"]
#[doc = "                        \"properties\": {"]
#[doc = "                          \"range\": {"]
#[doc = "                            \"oneOf\": ["]
#[doc = "                              {"]
#[doc = "                                \"type\": \"number\""]
#[doc = "                              },"]
#[doc = "                              {"]
#[doc = "                                \"type\": \"boolean\""]
#[doc = "                              }"]
#[doc = "                            ]"]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"scale\","]
#[doc = "                      \"value\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"band\","]
#[doc = "                      \"scale\""]
#[doc = "                    ]"]
#[doc = "                  },"]
#[doc = "                  {"]
#[doc = "                    \"type\": \"object\","]
#[doc = "                    \"required\": ["]
#[doc = "                      \"offset\""]
#[doc = "                    ]"]
#[doc = "                  }"]
#[doc = "                ]"]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"array\","]
#[doc = "                          \"items\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValue {
    Variant0(Vec<TextValueVariant0Item>),
    Variant1(TextValueVariant1),
}
impl From<&Self> for TextValue {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<TextValueVariant0Item>> for TextValue {
    fn from(value: Vec<TextValueVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<TextValueVariant1> for TextValue {
    fn from(value: TextValueVariant1) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextValueVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/rule\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/definitions/signalRef\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"value\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"value\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"string\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"array\","]
#[doc = "                          \"items\": {"]
#[doc = "                            \"type\": \"string\""]
#[doc = "                          }"]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"field\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"field\": {"]
#[doc = "                      \"$ref\": \"#/definitions/field\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"range\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"range\": {"]
#[doc = "                      \"oneOf\": ["]
#[doc = "                        {"]
#[doc = "                          \"type\": \"number\""]
#[doc = "                        },"]
#[doc = "                        {"]
#[doc = "                          \"type\": \"boolean\""]
#[doc = "                        }"]
#[doc = "                      ]"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"scale\","]
#[doc = "                \"value\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"band\","]
#[doc = "                \"scale\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"offset\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0Item {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
        value: TextValueVariant0ItemVariant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
    Variant3 {
        range: TextValueVariant0ItemVariant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        test: Option<String>,
    },
}
impl From<&Self> for TextValueVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TextValueVariant0ItemVariant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0ItemVariant1Value {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for TextValueVariant0ItemVariant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for TextValueVariant0ItemVariant1Value {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextValueVariant0ItemVariant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant0ItemVariant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for TextValueVariant0ItemVariant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for TextValueVariant0ItemVariant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for TextValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TextValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TextValueVariant0ItemVariant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for TextValueVariant0ItemVariant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for TextValueVariant0ItemVariant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for TextValueVariant0ItemVariant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextValueVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringModifiers\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"value\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"value\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"array\","]
#[doc = "                      \"items\": {"]
#[doc = "                        \"type\": \"string\""]
#[doc = "                      }"]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"field\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"field\": {"]
#[doc = "                  \"$ref\": \"#/definitions/field\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"range\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"range\": {"]
#[doc = "                  \"oneOf\": ["]
#[doc = "                    {"]
#[doc = "                      \"type\": \"number\""]
#[doc = "                    },"]
#[doc = "                    {"]
#[doc = "                      \"type\": \"boolean\""]
#[doc = "                    }"]
#[doc = "                  ]"]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"scale\","]
#[doc = "            \"value\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"band\","]
#[doc = "            \"scale\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"offset\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1 {
    Variant0 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        signal: String,
    },
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
        value: TextValueVariant1Variant1Value,
    },
    Variant2 {
        field: Field,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
    Variant3 {
        range: TextValueVariant1Variant3Range,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        scale: Option<Field>,
    },
}
impl From<&Self> for TextValueVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TextValueVariant1Variant1Value"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1Variant1Value {
    Variant0(String),
    Variant1(Vec<String>),
}
impl From<&Self> for TextValueVariant1Variant1Value {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<String>> for TextValueVariant1Variant1Value {
    fn from(value: Vec<String>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TextValueVariant1Variant3Range"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TextValueVariant1Variant3Range {
    Variant0(f64),
    Variant1(bool),
}
impl From<&Self> for TextValueVariant1Variant3Range {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl std::str::FromStr for TextValueVariant1Variant3Range {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::Variant0(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::Variant1(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl std::convert::TryFrom<&str> for TextValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TextValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TextValueVariant1Variant3Range {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ToString for TextValueVariant1Variant3Range {
    fn to_string(&self) -> String {
        match self {
            Self::Variant0(x) => x.to_string(),
            Self::Variant1(x) => x.to_string(),
        }
    }
}
impl From<f64> for TextValueVariant1Variant3Range {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<bool> for TextValueVariant1Variant3Range {
    fn from(value: bool) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TickBand"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"center\","]
#[doc = "        \"extent\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TickBand {
    Variant0(TickBandVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TickBand {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TickBandVariant0> for TickBand {
    fn from(value: TickBandVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TickBand {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TickBandVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"center\","]
#[doc = "    \"extent\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickBandVariant0 {
    #[serde(rename = "center")]
    Center,
    #[serde(rename = "extent")]
    Extent,
}
impl From<&Self> for TickBandVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TickBandVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Center => "center".to_string(),
            Self::Extent => "extent".to_string(),
        }
    }
}
impl std::str::FromStr for TickBandVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "center" => Ok(Self::Center),
            "extent" => Ok(Self::Extent),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickBandVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TickCount"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"interval\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"interval\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"millisecond\","]
#[doc = "                \"second\","]
#[doc = "                \"minute\","]
#[doc = "                \"hour\","]
#[doc = "                \"day\","]
#[doc = "                \"week\","]
#[doc = "                \"month\","]
#[doc = "                \"year\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"step\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum TickCount {
    Variant0(f64),
    Variant1(TickCountVariant1),
    Variant2 {
        interval: TickCountVariant2Interval,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        step: Option<NumberOrSignal>,
    },
    Variant3(SignalRef),
}
impl From<&Self> for TickCount {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TickCount {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<TickCountVariant1> for TickCount {
    fn from(value: TickCountVariant1) -> Self {
        Self::Variant1(value)
    }
}
impl From<SignalRef> for TickCount {
    fn from(value: SignalRef) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "TickCountVariant1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickCountVariant1 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&Self> for TickCountVariant1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TickCountVariant1 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant1 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickCountVariant1 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TickCountVariant2Interval"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"millisecond\","]
#[doc = "        \"second\","]
#[doc = "        \"minute\","]
#[doc = "        \"hour\","]
#[doc = "        \"day\","]
#[doc = "        \"week\","]
#[doc = "        \"month\","]
#[doc = "        \"year\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TickCountVariant2Interval {
    Variant0(TickCountVariant2IntervalVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TickCountVariant2Interval {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TickCountVariant2IntervalVariant0> for TickCountVariant2Interval {
    fn from(value: TickCountVariant2IntervalVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TickCountVariant2Interval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TickCountVariant2IntervalVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"millisecond\","]
#[doc = "    \"second\","]
#[doc = "    \"minute\","]
#[doc = "    \"hour\","]
#[doc = "    \"day\","]
#[doc = "    \"week\","]
#[doc = "    \"month\","]
#[doc = "    \"year\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TickCountVariant2IntervalVariant0 {
    #[serde(rename = "millisecond")]
    Millisecond,
    #[serde(rename = "second")]
    Second,
    #[serde(rename = "minute")]
    Minute,
    #[serde(rename = "hour")]
    Hour,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "year")]
    Year,
}
impl From<&Self> for TickCountVariant2IntervalVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TickCountVariant2IntervalVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Millisecond => "millisecond".to_string(),
            Self::Second => "second".to_string(),
            Self::Minute => "minute".to_string(),
            Self::Hour => "hour".to_string(),
            Self::Day => "day".to_string(),
            Self::Week => "week".to_string(),
            Self::Month => "month".to_string(),
            Self::Year => "year".to_string(),
        }
    }
}
impl std::str::FromStr for TickCountVariant2IntervalVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "millisecond" => Ok(Self::Millisecond),
            "second" => Ok(Self::Second),
            "minute" => Ok(Self::Minute),
            "hour" => Ok(Self::Hour),
            "day" => Ok(Self::Day),
            "week" => Ok(Self::Week),
            "month" => Ok(Self::Month),
            "year" => Ok(Self::Year),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TickCountVariant2IntervalVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TimeunitTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"field\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"unit0\","]
#[doc = "        \"unit1\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"interval\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"maxbins\": {"]
#[doc = "      \"default\": 40,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"step\": {"]
#[doc = "      \"default\": 1,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"timezone\": {"]
#[doc = "      \"default\": \"local\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"local\","]
#[doc = "            \"utc\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"timeunit\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"units\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"year\","]
#[doc = "                  \"quarter\","]
#[doc = "                  \"month\","]
#[doc = "                  \"week\","]
#[doc = "                  \"date\","]
#[doc = "                  \"day\","]
#[doc = "                  \"dayofyear\","]
#[doc = "                  \"hours\","]
#[doc = "                  \"minutes\","]
#[doc = "                  \"seconds\","]
#[doc = "                  \"milliseconds\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TimeunitTransform {
    #[serde(rename = "as", default = "defaults::timeunit_transform_as")]
    pub as_: TimeunitTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub extent: Option<TimeunitTransformExtent>,
    pub field: TimeunitTransformField,
    #[serde(default = "defaults::timeunit_transform_interval")]
    pub interval: TimeunitTransformInterval,
    #[serde(default = "defaults::timeunit_transform_maxbins")]
    pub maxbins: TimeunitTransformMaxbins,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default = "defaults::timeunit_transform_step")]
    pub step: TimeunitTransformStep,
    #[serde(default = "defaults::timeunit_transform_timezone")]
    pub timezone: TimeunitTransformTimezone,
    #[serde(rename = "type")]
    pub type_: TimeunitTransformType,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub units: Option<TimeunitTransformUnits>,
}
impl From<&Self> for TimeunitTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TimeunitTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"unit0\","]
#[doc = "    \"unit1\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformAs {
    Variant0([TimeunitTransformAsVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformAs {
    fn default() -> Self {
        Self::Variant0([
            TimeunitTransformAsVariant0Item::Variant0("unit0".to_string()),
            TimeunitTransformAsVariant0Item::Variant0("unit1".to_string()),
        ])
    }
}
impl From<[TimeunitTransformAsVariant0Item; 2usize]> for TimeunitTransformAs {
    fn from(value: [TimeunitTransformAsVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for TimeunitTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformExtent {
    Variant0(Vec<TimeunitTransformExtentVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<TimeunitTransformExtentVariant0Item>> for TimeunitTransformExtent {
    fn from(value: Vec<TimeunitTransformExtentVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformExtentVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformExtentVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformExtentVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TimeunitTransformExtentVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformExtentVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for TimeunitTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for TimeunitTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for TimeunitTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for TimeunitTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "TimeunitTransformInterval"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformInterval {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformInterval {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformInterval {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for TimeunitTransformInterval {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformInterval {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformMaxbins"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 40,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformMaxbins {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformMaxbins {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformMaxbins {
    fn default() -> Self {
        Self::Variant0(40_f64)
    }
}
impl From<f64> for TimeunitTransformMaxbins {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformMaxbins {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformStep"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformStep {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformStep {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformStep {
    fn default() -> Self {
        Self::Variant0(1_f64)
    }
}
impl From<f64> for TimeunitTransformStep {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformStep {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformTimezone"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"local\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"local\","]
#[doc = "        \"utc\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformTimezone {
    Variant0(TimeunitTransformTimezoneVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformTimezone {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TimeunitTransformTimezone {
    fn default() -> Self {
        Self::Variant0(TimeunitTransformTimezoneVariant0::Local)
    }
}
impl From<TimeunitTransformTimezoneVariant0> for TimeunitTransformTimezone {
    fn from(value: TimeunitTransformTimezoneVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformTimezone {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformTimezoneVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"local\","]
#[doc = "    \"utc\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformTimezoneVariant0 {
    #[serde(rename = "local")]
    Local,
    #[serde(rename = "utc")]
    Utc,
}
impl From<&Self> for TimeunitTransformTimezoneVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformTimezoneVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Local => "local".to_string(),
            Self::Utc => "utc".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformTimezoneVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "local" => Ok(Self::Local),
            "utc" => Ok(Self::Utc),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformTimezoneVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TimeunitTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"timeunit\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformType {
    #[serde(rename = "timeunit")]
    Timeunit,
}
impl From<&Self> for TimeunitTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Timeunit => "timeunit".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "timeunit" => Ok(Self::Timeunit),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TimeunitTransformUnits"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"year\","]
#[doc = "              \"quarter\","]
#[doc = "              \"month\","]
#[doc = "              \"week\","]
#[doc = "              \"date\","]
#[doc = "              \"day\","]
#[doc = "              \"dayofyear\","]
#[doc = "              \"hours\","]
#[doc = "              \"minutes\","]
#[doc = "              \"seconds\","]
#[doc = "              \"milliseconds\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformUnits {
    Variant0(Vec<TimeunitTransformUnitsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformUnits {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<TimeunitTransformUnitsVariant0Item>> for TimeunitTransformUnits {
    fn from(value: Vec<TimeunitTransformUnitsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformUnits {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformUnitsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"year\","]
#[doc = "        \"quarter\","]
#[doc = "        \"month\","]
#[doc = "        \"week\","]
#[doc = "        \"date\","]
#[doc = "        \"day\","]
#[doc = "        \"dayofyear\","]
#[doc = "        \"hours\","]
#[doc = "        \"minutes\","]
#[doc = "        \"seconds\","]
#[doc = "        \"milliseconds\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TimeunitTransformUnitsVariant0Item {
    Variant0(TimeunitTransformUnitsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TimeunitTransformUnitsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TimeunitTransformUnitsVariant0ItemVariant0> for TimeunitTransformUnitsVariant0Item {
    fn from(value: TimeunitTransformUnitsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TimeunitTransformUnitsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TimeunitTransformUnitsVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"year\","]
#[doc = "    \"quarter\","]
#[doc = "    \"month\","]
#[doc = "    \"week\","]
#[doc = "    \"date\","]
#[doc = "    \"day\","]
#[doc = "    \"dayofyear\","]
#[doc = "    \"hours\","]
#[doc = "    \"minutes\","]
#[doc = "    \"seconds\","]
#[doc = "    \"milliseconds\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TimeunitTransformUnitsVariant0ItemVariant0 {
    #[serde(rename = "year")]
    Year,
    #[serde(rename = "quarter")]
    Quarter,
    #[serde(rename = "month")]
    Month,
    #[serde(rename = "week")]
    Week,
    #[serde(rename = "date")]
    Date,
    #[serde(rename = "day")]
    Day,
    #[serde(rename = "dayofyear")]
    Dayofyear,
    #[serde(rename = "hours")]
    Hours,
    #[serde(rename = "minutes")]
    Minutes,
    #[serde(rename = "seconds")]
    Seconds,
    #[serde(rename = "milliseconds")]
    Milliseconds,
}
impl From<&Self> for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TimeunitTransformUnitsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Year => "year".to_string(),
            Self::Quarter => "quarter".to_string(),
            Self::Month => "month".to_string(),
            Self::Week => "week".to_string(),
            Self::Date => "date".to_string(),
            Self::Day => "day".to_string(),
            Self::Dayofyear => "dayofyear".to_string(),
            Self::Hours => "hours".to_string(),
            Self::Minutes => "minutes".to_string(),
            Self::Seconds => "seconds".to_string(),
            Self::Milliseconds => "milliseconds".to_string(),
        }
    }
}
impl std::str::FromStr for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "year" => Ok(Self::Year),
            "quarter" => Ok(Self::Quarter),
            "month" => Ok(Self::Month),
            "week" => Ok(Self::Week),
            "date" => Ok(Self::Date),
            "day" => Ok(Self::Day),
            "dayofyear" => Ok(Self::Dayofyear),
            "hours" => Ok(Self::Hours),
            "minutes" => Ok(Self::Minutes),
            "seconds" => Ok(Self::Seconds),
            "milliseconds" => Ok(Self::Milliseconds),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TimeunitTransformUnitsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Title"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"align\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"center\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/alignValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"anchor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"start\","]
#[doc = "                \"middle\","]
#[doc = "                \"end\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"angle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"aria\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"baseline\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"top\","]
#[doc = "                \"middle\","]
#[doc = "                \"bottom\","]
#[doc = "                \"alphabetic\","]
#[doc = "                \"line-top\","]
#[doc = "                \"line-bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"color\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dx\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"dy\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"encode\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"patternProperties\": {"]
#[doc = "                \"^(?!interactive|name|style).+$\": {"]
#[doc = "                  \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"group\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                },"]
#[doc = "                \"subtitle\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                },"]
#[doc = "                \"title\": {"]
#[doc = "                  \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"additionalProperties\": false"]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"font\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"fontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"frame\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                \"group\","]
#[doc = "                \"bounds\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"interactive\": {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        \"limit\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"lineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"offset\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"orient\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"default\": \"top\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"none\","]
#[doc = "                \"left\","]
#[doc = "                \"right\","]
#[doc = "                \"top\","]
#[doc = "                \"bottom\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/signalRef\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"style\": {"]
#[doc = "          \"$ref\": \"#/definitions/style\""]
#[doc = "        },"]
#[doc = "        \"subtitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"subtitleColor\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/colorValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFont\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontSize\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontStyle\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/stringValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleFontWeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"enum\": ["]
#[doc = "                null,"]
#[doc = "                \"normal\","]
#[doc = "                \"bold\","]
#[doc = "                \"lighter\","]
#[doc = "                \"bolder\","]
#[doc = "                \"100\","]
#[doc = "                \"200\","]
#[doc = "                \"300\","]
#[doc = "                \"400\","]
#[doc = "                \"500\","]
#[doc = "                \"600\","]
#[doc = "                \"700\","]
#[doc = "                \"800\","]
#[doc = "                \"900\","]
#[doc = "                100,"]
#[doc = "                200,"]
#[doc = "                300,"]
#[doc = "                400,"]
#[doc = "                500,"]
#[doc = "                600,"]
#[doc = "                700,"]
#[doc = "                800,"]
#[doc = "                900"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitleLineHeight\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"type\": \"number\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/definitions/numberValue\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"subtitlePadding\": {"]
#[doc = "          \"$ref\": \"#/definitions/numberOrSignal\""]
#[doc = "        },"]
#[doc = "        \"text\": {"]
#[doc = "          \"$ref\": \"#/definitions/textOrSignal\""]
#[doc = "        },"]
#[doc = "        \"zindex\": {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged, deny_unknown_fields)]
pub enum Title {
    Variant0(String),
    Variant1 {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        align: Option<TitleVariant1Align>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        anchor: Option<TitleVariant1Anchor>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        angle: Option<TitleVariant1Angle>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        aria: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        baseline: Option<TitleVariant1Baseline>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        color: Option<TitleVariant1Color>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dx: Option<TitleVariant1Dx>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        dy: Option<TitleVariant1Dy>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        encode: Option<TitleVariant1Encode>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        font: Option<TitleVariant1Font>,
        #[serde(rename = "fontSize", default, skip_serializing_if = "Option::is_none")]
        font_size: Option<TitleVariant1FontSize>,
        #[serde(rename = "fontStyle", default, skip_serializing_if = "Option::is_none")]
        font_style: Option<TitleVariant1FontStyle>,
        #[serde(
            rename = "fontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        font_weight: Option<TitleVariant1FontWeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        frame: Option<TitleVariant1Frame>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        interactive: Option<bool>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        limit: Option<TitleVariant1Limit>,
        #[serde(
            rename = "lineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        line_height: Option<TitleVariant1LineHeight>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        offset: Option<TitleVariant1Offset>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        orient: Option<TitleVariant1Orient>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        style: Option<Style>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        subtitle: Option<TextOrSignal>,
        #[serde(
            rename = "subtitleColor",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_color: Option<TitleVariant1SubtitleColor>,
        #[serde(
            rename = "subtitleFont",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font: Option<TitleVariant1SubtitleFont>,
        #[serde(
            rename = "subtitleFontSize",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_size: Option<TitleVariant1SubtitleFontSize>,
        #[serde(
            rename = "subtitleFontStyle",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_style: Option<TitleVariant1SubtitleFontStyle>,
        #[serde(
            rename = "subtitleFontWeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_font_weight: Option<TitleVariant1SubtitleFontWeight>,
        #[serde(
            rename = "subtitleLineHeight",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_line_height: Option<TitleVariant1SubtitleLineHeight>,
        #[serde(
            rename = "subtitlePadding",
            default,
            skip_serializing_if = "Option::is_none"
        )]
        subtitle_padding: Option<NumberOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        text: Option<TextOrSignal>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        zindex: Option<f64>,
    },
}
impl From<&Self> for Title {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TitleVariant1Align"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"center\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/alignValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Align {
    Variant0(TitleVariant1AlignVariant0),
    Variant1(AlignValue),
}
impl From<&Self> for TitleVariant1Align {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TitleVariant1AlignVariant0> for TitleVariant1Align {
    fn from(value: TitleVariant1AlignVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<AlignValue> for TitleVariant1Align {
    fn from(value: AlignValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1AlignVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"center\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1AlignVariant0 {
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "center")]
    Center,
}
impl From<&Self> for TitleVariant1AlignVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1AlignVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Center => "center".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AlignVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "center" => Ok(Self::Center),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1AlignVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TitleVariant1Anchor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"start\","]
#[doc = "        \"middle\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/anchorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Anchor {
    Variant0(Option<TitleVariant1AnchorVariant0>),
    Variant1(AnchorValue),
}
impl From<&Self> for TitleVariant1Anchor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Option<TitleVariant1AnchorVariant0>> for TitleVariant1Anchor {
    fn from(value: Option<TitleVariant1AnchorVariant0>) -> Self {
        Self::Variant0(value)
    }
}
impl From<AnchorValue> for TitleVariant1Anchor {
    fn from(value: AnchorValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1AnchorVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    null,"]
#[doc = "    \"start\","]
#[doc = "    \"middle\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1AnchorVariant0 {
    #[serde(rename = "start")]
    Start,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "end")]
    End,
}
impl From<&Self> for TitleVariant1AnchorVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1AnchorVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Start => "start".to_string(),
            Self::Middle => "middle".to_string(),
            Self::End => "end".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1AnchorVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "start" => Ok(Self::Start),
            "middle" => Ok(Self::Middle),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1AnchorVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TitleVariant1Angle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Angle {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1Angle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1Angle {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1Angle {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Baseline"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"top\","]
#[doc = "        \"middle\","]
#[doc = "        \"bottom\","]
#[doc = "        \"alphabetic\","]
#[doc = "        \"line-top\","]
#[doc = "        \"line-bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/baselineValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Baseline {
    Variant0(TitleVariant1BaselineVariant0),
    Variant1(BaselineValue),
}
impl From<&Self> for TitleVariant1Baseline {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TitleVariant1BaselineVariant0> for TitleVariant1Baseline {
    fn from(value: TitleVariant1BaselineVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<BaselineValue> for TitleVariant1Baseline {
    fn from(value: BaselineValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1BaselineVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"top\","]
#[doc = "    \"middle\","]
#[doc = "    \"bottom\","]
#[doc = "    \"alphabetic\","]
#[doc = "    \"line-top\","]
#[doc = "    \"line-bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1BaselineVariant0 {
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "middle")]
    Middle,
    #[serde(rename = "bottom")]
    Bottom,
    #[serde(rename = "alphabetic")]
    Alphabetic,
    #[serde(rename = "line-top")]
    LineTop,
    #[serde(rename = "line-bottom")]
    LineBottom,
}
impl From<&Self> for TitleVariant1BaselineVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1BaselineVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Top => "top".to_string(),
            Self::Middle => "middle".to_string(),
            Self::Bottom => "bottom".to_string(),
            Self::Alphabetic => "alphabetic".to_string(),
            Self::LineTop => "line-top".to_string(),
            Self::LineBottom => "line-bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1BaselineVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "top" => Ok(Self::Top),
            "middle" => Ok(Self::Middle),
            "bottom" => Ok(Self::Bottom),
            "alphabetic" => Ok(Self::Alphabetic),
            "line-top" => Ok(Self::LineTop),
            "line-bottom" => Ok(Self::LineBottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1BaselineVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TitleVariant1Color"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Color {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for TitleVariant1Color {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for TitleVariant1Color {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "TitleVariant1Dx"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Dx {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1Dx {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1Dx {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1Dx {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Dy"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Dy {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1Dy {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1Dy {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1Dy {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Encode"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"patternProperties\": {"]
#[doc = "        \"^(?!interactive|name|style).+$\": {"]
#[doc = "          \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"group\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"subtitle\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TitleVariant1Encode {
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_0: Option<TitleVariant1EncodeSubtype0>,
    #[serde(flatten, default, skip_serializing_if = "Option::is_none")]
    pub subtype_1: Option<TitleVariant1EncodeSubtype1>,
}
impl From<&Self> for TitleVariant1Encode {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TitleVariant1EncodeSubtype0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"patternProperties\": {"]
#[doc = "    \"^(?!interactive|name|style).+$\": {"]
#[doc = "      \"$ref\": \"#/definitions/encodeEntry\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype0 {}
impl From<&Self> for TitleVariant1EncodeSubtype0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TitleVariant1EncodeSubtype1"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"group\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"subtitle\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"$ref\": \"#/definitions/guideEncode\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TitleVariant1EncodeSubtype1 {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub group: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub subtitle: Option<GuideEncode>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub title: Option<GuideEncode>,
}
impl From<&Self> for TitleVariant1EncodeSubtype1 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TitleVariant1Font"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Font {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for TitleVariant1Font {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for TitleVariant1Font {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1FontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1FontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1FontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1FontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1FontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for TitleVariant1FontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for TitleVariant1FontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1FontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1FontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for TitleVariant1FontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for TitleVariant1FontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for TitleVariant1FontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Frame"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"group\","]
#[doc = "        \"bounds\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Frame {
    Variant0(TitleVariant1FrameVariant0),
    Variant1(StringValue),
}
impl From<&Self> for TitleVariant1Frame {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TitleVariant1FrameVariant0> for TitleVariant1Frame {
    fn from(value: TitleVariant1FrameVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<StringValue> for TitleVariant1Frame {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1FrameVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"group\","]
#[doc = "    \"bounds\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1FrameVariant0 {
    #[serde(rename = "group")]
    Group,
    #[serde(rename = "bounds")]
    Bounds,
}
impl From<&Self> for TitleVariant1FrameVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1FrameVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Group => "group".to_string(),
            Self::Bounds => "bounds".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1FrameVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "group" => Ok(Self::Group),
            "bounds" => Ok(Self::Bounds),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1FrameVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TitleVariant1Limit"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Limit {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1Limit {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1Limit {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1Limit {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1LineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1LineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1LineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1LineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1LineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Offset"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Offset {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1Offset {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1Offset {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1Offset {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1Orient"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"top\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"none\","]
#[doc = "        \"left\","]
#[doc = "        \"right\","]
#[doc = "        \"top\","]
#[doc = "        \"bottom\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1Orient {
    Variant0(TitleVariant1OrientVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TitleVariant1Orient {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<TitleVariant1OrientVariant0> for TitleVariant1Orient {
    fn from(value: TitleVariant1OrientVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TitleVariant1Orient {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1OrientVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"top\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"none\","]
#[doc = "    \"left\","]
#[doc = "    \"right\","]
#[doc = "    \"top\","]
#[doc = "    \"bottom\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TitleVariant1OrientVariant0 {
    #[serde(rename = "none")]
    None,
    #[serde(rename = "left")]
    Left,
    #[serde(rename = "right")]
    Right,
    #[serde(rename = "top")]
    Top,
    #[serde(rename = "bottom")]
    Bottom,
}
impl From<&Self> for TitleVariant1OrientVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TitleVariant1OrientVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::None => "none".to_string(),
            Self::Left => "left".to_string(),
            Self::Right => "right".to_string(),
            Self::Top => "top".to_string(),
            Self::Bottom => "bottom".to_string(),
        }
    }
}
impl std::str::FromStr for TitleVariant1OrientVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "none" => Ok(Self::None),
            "left" => Ok(Self::Left),
            "right" => Ok(Self::Right),
            "top" => Ok(Self::Top),
            "bottom" => Ok(Self::Bottom),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TitleVariant1OrientVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TitleVariant1SubtitleColor"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/colorValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleColor {
    Variant0,
    Variant1(String),
    Variant2(ColorValue),
}
impl From<&Self> for TitleVariant1SubtitleColor {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ColorValue> for TitleVariant1SubtitleColor {
    fn from(value: ColorValue) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "TitleVariant1SubtitleFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFont {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for TitleVariant1SubtitleFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for TitleVariant1SubtitleFont {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1SubtitleFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontSize {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1SubtitleFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1SubtitleFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1SubtitleFontSize {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1SubtitleFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stringValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontStyle {
    Variant0(String),
    Variant1(StringValue),
}
impl From<&Self> for TitleVariant1SubtitleFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<StringValue> for TitleVariant1SubtitleFontStyle {
    fn from(value: StringValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1SubtitleFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        null,"]
#[doc = "        \"normal\","]
#[doc = "        \"bold\","]
#[doc = "        \"lighter\","]
#[doc = "        \"bolder\","]
#[doc = "        \"100\","]
#[doc = "        \"200\","]
#[doc = "        \"300\","]
#[doc = "        \"400\","]
#[doc = "        \"500\","]
#[doc = "        \"600\","]
#[doc = "        \"700\","]
#[doc = "        \"800\","]
#[doc = "        \"900\","]
#[doc = "        100,"]
#[doc = "        200,"]
#[doc = "        300,"]
#[doc = "        400,"]
#[doc = "        500,"]
#[doc = "        600,"]
#[doc = "        700,"]
#[doc = "        800,"]
#[doc = "        900"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/fontWeightValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleFontWeight {
    Variant0(MyEnum),
    Variant1(FontWeightValue),
}
impl From<&Self> for TitleVariant1SubtitleFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<MyEnum> for TitleVariant1SubtitleFontWeight {
    fn from(value: MyEnum) -> Self {
        Self::Variant0(value)
    }
}
impl From<FontWeightValue> for TitleVariant1SubtitleFontWeight {
    fn from(value: FontWeightValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TitleVariant1SubtitleLineHeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/numberValue\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TitleVariant1SubtitleLineHeight {
    Variant0(f64),
    Variant1(NumberValue),
}
impl From<&Self> for TitleVariant1SubtitleLineHeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TitleVariant1SubtitleLineHeight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<NumberValue> for TitleVariant1SubtitleLineHeight {
    fn from(value: NumberValue) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "Transform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossfilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/resolvefilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/linkpathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pieTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stackTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/forceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/contourTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geojsonTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopointTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geoshapeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/graticuleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/heatmapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/isocontourTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/kde2dTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/nestTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/packTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/partitionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stratifyTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treelinksTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treemapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/labelTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/loessTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/regressionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/aggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/binTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/collectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/countpatternTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/densityTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/dotbinTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/extentTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/filterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/flattenTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/foldTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/formulaTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/imputeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/joinaggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/kdeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/lookupTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pivotTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/projectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/quantileTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sampleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sequenceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/timeunitTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/windowTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/identifierTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/voronoiTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/wordcloudTransform\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum Transform {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    ContourTransform(ContourTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    GraticuleTransform(GraticuleTransform),
    HeatmapTransform(HeatmapTransform),
    IsocontourTransform(IsocontourTransform),
    Kde2dTransform(Kde2dTransform),
    NestTransform(NestTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreelinksTransform(TreelinksTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    LoessTransform(LoessTransform),
    RegressionTransform(RegressionTransform),
    AggregateTransform(AggregateTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    CountpatternTransform(CountpatternTransform),
    CrossTransform(CrossTransform),
    DensityTransform(DensityTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FilterTransform(FilterTransform),
    FlattenTransform(FlattenTransform),
    FoldTransform(FoldTransform),
    FormulaTransform(FormulaTransform),
    ImputeTransform(ImputeTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    KdeTransform(KdeTransform),
    LookupTransform(LookupTransform),
    PivotTransform(PivotTransform),
    ProjectTransform(ProjectTransform),
    QuantileTransform(QuantileTransform),
    SampleTransform(SampleTransform),
    SequenceTransform(SequenceTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl From<&Self> for Transform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<CrossfilterTransform> for Transform {
    fn from(value: CrossfilterTransform) -> Self {
        Self::CrossfilterTransform(value)
    }
}
impl From<ResolvefilterTransform> for Transform {
    fn from(value: ResolvefilterTransform) -> Self {
        Self::ResolvefilterTransform(value)
    }
}
impl From<LinkpathTransform> for Transform {
    fn from(value: LinkpathTransform) -> Self {
        Self::LinkpathTransform(value)
    }
}
impl From<PieTransform> for Transform {
    fn from(value: PieTransform) -> Self {
        Self::PieTransform(value)
    }
}
impl From<StackTransform> for Transform {
    fn from(value: StackTransform) -> Self {
        Self::StackTransform(value)
    }
}
impl From<ForceTransform> for Transform {
    fn from(value: ForceTransform) -> Self {
        Self::ForceTransform(value)
    }
}
impl From<ContourTransform> for Transform {
    fn from(value: ContourTransform) -> Self {
        Self::ContourTransform(value)
    }
}
impl From<GeojsonTransform> for Transform {
    fn from(value: GeojsonTransform) -> Self {
        Self::GeojsonTransform(value)
    }
}
impl From<GeopathTransform> for Transform {
    fn from(value: GeopathTransform) -> Self {
        Self::GeopathTransform(value)
    }
}
impl From<GeopointTransform> for Transform {
    fn from(value: GeopointTransform) -> Self {
        Self::GeopointTransform(value)
    }
}
impl From<GeoshapeTransform> for Transform {
    fn from(value: GeoshapeTransform) -> Self {
        Self::GeoshapeTransform(value)
    }
}
impl From<GraticuleTransform> for Transform {
    fn from(value: GraticuleTransform) -> Self {
        Self::GraticuleTransform(value)
    }
}
impl From<HeatmapTransform> for Transform {
    fn from(value: HeatmapTransform) -> Self {
        Self::HeatmapTransform(value)
    }
}
impl From<IsocontourTransform> for Transform {
    fn from(value: IsocontourTransform) -> Self {
        Self::IsocontourTransform(value)
    }
}
impl From<Kde2dTransform> for Transform {
    fn from(value: Kde2dTransform) -> Self {
        Self::Kde2dTransform(value)
    }
}
impl From<NestTransform> for Transform {
    fn from(value: NestTransform) -> Self {
        Self::NestTransform(value)
    }
}
impl From<PackTransform> for Transform {
    fn from(value: PackTransform) -> Self {
        Self::PackTransform(value)
    }
}
impl From<PartitionTransform> for Transform {
    fn from(value: PartitionTransform) -> Self {
        Self::PartitionTransform(value)
    }
}
impl From<StratifyTransform> for Transform {
    fn from(value: StratifyTransform) -> Self {
        Self::StratifyTransform(value)
    }
}
impl From<TreeTransform> for Transform {
    fn from(value: TreeTransform) -> Self {
        Self::TreeTransform(value)
    }
}
impl From<TreelinksTransform> for Transform {
    fn from(value: TreelinksTransform) -> Self {
        Self::TreelinksTransform(value)
    }
}
impl From<TreemapTransform> for Transform {
    fn from(value: TreemapTransform) -> Self {
        Self::TreemapTransform(value)
    }
}
impl From<LabelTransform> for Transform {
    fn from(value: LabelTransform) -> Self {
        Self::LabelTransform(value)
    }
}
impl From<LoessTransform> for Transform {
    fn from(value: LoessTransform) -> Self {
        Self::LoessTransform(value)
    }
}
impl From<RegressionTransform> for Transform {
    fn from(value: RegressionTransform) -> Self {
        Self::RegressionTransform(value)
    }
}
impl From<AggregateTransform> for Transform {
    fn from(value: AggregateTransform) -> Self {
        Self::AggregateTransform(value)
    }
}
impl From<BinTransform> for Transform {
    fn from(value: BinTransform) -> Self {
        Self::BinTransform(value)
    }
}
impl From<CollectTransform> for Transform {
    fn from(value: CollectTransform) -> Self {
        Self::CollectTransform(value)
    }
}
impl From<CountpatternTransform> for Transform {
    fn from(value: CountpatternTransform) -> Self {
        Self::CountpatternTransform(value)
    }
}
impl From<CrossTransform> for Transform {
    fn from(value: CrossTransform) -> Self {
        Self::CrossTransform(value)
    }
}
impl From<DensityTransform> for Transform {
    fn from(value: DensityTransform) -> Self {
        Self::DensityTransform(value)
    }
}
impl From<DotbinTransform> for Transform {
    fn from(value: DotbinTransform) -> Self {
        Self::DotbinTransform(value)
    }
}
impl From<ExtentTransform> for Transform {
    fn from(value: ExtentTransform) -> Self {
        Self::ExtentTransform(value)
    }
}
impl From<FilterTransform> for Transform {
    fn from(value: FilterTransform) -> Self {
        Self::FilterTransform(value)
    }
}
impl From<FlattenTransform> for Transform {
    fn from(value: FlattenTransform) -> Self {
        Self::FlattenTransform(value)
    }
}
impl From<FoldTransform> for Transform {
    fn from(value: FoldTransform) -> Self {
        Self::FoldTransform(value)
    }
}
impl From<FormulaTransform> for Transform {
    fn from(value: FormulaTransform) -> Self {
        Self::FormulaTransform(value)
    }
}
impl From<ImputeTransform> for Transform {
    fn from(value: ImputeTransform) -> Self {
        Self::ImputeTransform(value)
    }
}
impl From<JoinaggregateTransform> for Transform {
    fn from(value: JoinaggregateTransform) -> Self {
        Self::JoinaggregateTransform(value)
    }
}
impl From<KdeTransform> for Transform {
    fn from(value: KdeTransform) -> Self {
        Self::KdeTransform(value)
    }
}
impl From<LookupTransform> for Transform {
    fn from(value: LookupTransform) -> Self {
        Self::LookupTransform(value)
    }
}
impl From<PivotTransform> for Transform {
    fn from(value: PivotTransform) -> Self {
        Self::PivotTransform(value)
    }
}
impl From<ProjectTransform> for Transform {
    fn from(value: ProjectTransform) -> Self {
        Self::ProjectTransform(value)
    }
}
impl From<QuantileTransform> for Transform {
    fn from(value: QuantileTransform) -> Self {
        Self::QuantileTransform(value)
    }
}
impl From<SampleTransform> for Transform {
    fn from(value: SampleTransform) -> Self {
        Self::SampleTransform(value)
    }
}
impl From<SequenceTransform> for Transform {
    fn from(value: SequenceTransform) -> Self {
        Self::SequenceTransform(value)
    }
}
impl From<TimeunitTransform> for Transform {
    fn from(value: TimeunitTransform) -> Self {
        Self::TimeunitTransform(value)
    }
}
impl From<WindowTransform> for Transform {
    fn from(value: WindowTransform) -> Self {
        Self::WindowTransform(value)
    }
}
impl From<IdentifierTransform> for Transform {
    fn from(value: IdentifierTransform) -> Self {
        Self::IdentifierTransform(value)
    }
}
impl From<VoronoiTransform> for Transform {
    fn from(value: VoronoiTransform) -> Self {
        Self::VoronoiTransform(value)
    }
}
impl From<WordcloudTransform> for Transform {
    fn from(value: WordcloudTransform) -> Self {
        Self::WordcloudTransform(value)
    }
}
#[doc = "TransformMark"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/crossfilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/resolvefilterTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/linkpathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/pieTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stackTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/forceTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geojsonTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopathTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geopointTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/geoshapeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/heatmapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/packTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/partitionTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/stratifyTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treeTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/treemapTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/labelTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/binTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/collectTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/dotbinTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/extentTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/formulaTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/joinaggregateTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/lookupTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/sampleTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/timeunitTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/windowTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/identifierTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/voronoiTransform\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/wordcloudTransform\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TransformMark {
    CrossfilterTransform(CrossfilterTransform),
    ResolvefilterTransform(ResolvefilterTransform),
    LinkpathTransform(LinkpathTransform),
    PieTransform(PieTransform),
    StackTransform(StackTransform),
    ForceTransform(ForceTransform),
    GeojsonTransform(GeojsonTransform),
    GeopathTransform(GeopathTransform),
    GeopointTransform(GeopointTransform),
    GeoshapeTransform(GeoshapeTransform),
    HeatmapTransform(HeatmapTransform),
    PackTransform(PackTransform),
    PartitionTransform(PartitionTransform),
    StratifyTransform(StratifyTransform),
    TreeTransform(TreeTransform),
    TreemapTransform(TreemapTransform),
    LabelTransform(LabelTransform),
    BinTransform(BinTransform),
    CollectTransform(CollectTransform),
    DotbinTransform(DotbinTransform),
    ExtentTransform(ExtentTransform),
    FormulaTransform(FormulaTransform),
    JoinaggregateTransform(JoinaggregateTransform),
    LookupTransform(LookupTransform),
    SampleTransform(SampleTransform),
    TimeunitTransform(TimeunitTransform),
    WindowTransform(WindowTransform),
    IdentifierTransform(IdentifierTransform),
    VoronoiTransform(VoronoiTransform),
    WordcloudTransform(WordcloudTransform),
}
impl From<&Self> for TransformMark {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<CrossfilterTransform> for TransformMark {
    fn from(value: CrossfilterTransform) -> Self {
        Self::CrossfilterTransform(value)
    }
}
impl From<ResolvefilterTransform> for TransformMark {
    fn from(value: ResolvefilterTransform) -> Self {
        Self::ResolvefilterTransform(value)
    }
}
impl From<LinkpathTransform> for TransformMark {
    fn from(value: LinkpathTransform) -> Self {
        Self::LinkpathTransform(value)
    }
}
impl From<PieTransform> for TransformMark {
    fn from(value: PieTransform) -> Self {
        Self::PieTransform(value)
    }
}
impl From<StackTransform> for TransformMark {
    fn from(value: StackTransform) -> Self {
        Self::StackTransform(value)
    }
}
impl From<ForceTransform> for TransformMark {
    fn from(value: ForceTransform) -> Self {
        Self::ForceTransform(value)
    }
}
impl From<GeojsonTransform> for TransformMark {
    fn from(value: GeojsonTransform) -> Self {
        Self::GeojsonTransform(value)
    }
}
impl From<GeopathTransform> for TransformMark {
    fn from(value: GeopathTransform) -> Self {
        Self::GeopathTransform(value)
    }
}
impl From<GeopointTransform> for TransformMark {
    fn from(value: GeopointTransform) -> Self {
        Self::GeopointTransform(value)
    }
}
impl From<GeoshapeTransform> for TransformMark {
    fn from(value: GeoshapeTransform) -> Self {
        Self::GeoshapeTransform(value)
    }
}
impl From<HeatmapTransform> for TransformMark {
    fn from(value: HeatmapTransform) -> Self {
        Self::HeatmapTransform(value)
    }
}
impl From<PackTransform> for TransformMark {
    fn from(value: PackTransform) -> Self {
        Self::PackTransform(value)
    }
}
impl From<PartitionTransform> for TransformMark {
    fn from(value: PartitionTransform) -> Self {
        Self::PartitionTransform(value)
    }
}
impl From<StratifyTransform> for TransformMark {
    fn from(value: StratifyTransform) -> Self {
        Self::StratifyTransform(value)
    }
}
impl From<TreeTransform> for TransformMark {
    fn from(value: TreeTransform) -> Self {
        Self::TreeTransform(value)
    }
}
impl From<TreemapTransform> for TransformMark {
    fn from(value: TreemapTransform) -> Self {
        Self::TreemapTransform(value)
    }
}
impl From<LabelTransform> for TransformMark {
    fn from(value: LabelTransform) -> Self {
        Self::LabelTransform(value)
    }
}
impl From<BinTransform> for TransformMark {
    fn from(value: BinTransform) -> Self {
        Self::BinTransform(value)
    }
}
impl From<CollectTransform> for TransformMark {
    fn from(value: CollectTransform) -> Self {
        Self::CollectTransform(value)
    }
}
impl From<DotbinTransform> for TransformMark {
    fn from(value: DotbinTransform) -> Self {
        Self::DotbinTransform(value)
    }
}
impl From<ExtentTransform> for TransformMark {
    fn from(value: ExtentTransform) -> Self {
        Self::ExtentTransform(value)
    }
}
impl From<FormulaTransform> for TransformMark {
    fn from(value: FormulaTransform) -> Self {
        Self::FormulaTransform(value)
    }
}
impl From<JoinaggregateTransform> for TransformMark {
    fn from(value: JoinaggregateTransform) -> Self {
        Self::JoinaggregateTransform(value)
    }
}
impl From<LookupTransform> for TransformMark {
    fn from(value: LookupTransform) -> Self {
        Self::LookupTransform(value)
    }
}
impl From<SampleTransform> for TransformMark {
    fn from(value: SampleTransform) -> Self {
        Self::SampleTransform(value)
    }
}
impl From<TimeunitTransform> for TransformMark {
    fn from(value: TimeunitTransform) -> Self {
        Self::TimeunitTransform(value)
    }
}
impl From<WindowTransform> for TransformMark {
    fn from(value: WindowTransform) -> Self {
        Self::WindowTransform(value)
    }
}
impl From<IdentifierTransform> for TransformMark {
    fn from(value: IdentifierTransform) -> Self {
        Self::IdentifierTransform(value)
    }
}
impl From<VoronoiTransform> for TransformMark {
    fn from(value: VoronoiTransform) -> Self {
        Self::VoronoiTransform(value)
    }
}
impl From<WordcloudTransform> for TransformMark {
    fn from(value: WordcloudTransform) -> Self {
        Self::WordcloudTransform(value)
    }
}
#[doc = "TreeTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 4,"]
#[doc = "          \"minItems\": 4"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"tidy\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"tidy\","]
#[doc = "            \"cluster\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"nodeSize\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"separation\": {"]
#[doc = "      \"default\": true,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"tree\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreeTransform {
    #[serde(rename = "as", default = "defaults::tree_transform_as")]
    pub as_: TreeTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreeTransformField>,
    #[serde(default = "defaults::tree_transform_method")]
    pub method: TreeTransformMethod,
    #[serde(rename = "nodeSize", default, skip_serializing_if = "Option::is_none")]
    pub node_size: Option<TreeTransformNodeSize>,
    #[serde(default = "defaults::tree_transform_separation")]
    pub separation: TreeTransformSeparation,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreeTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreeTransformType,
}
impl From<&Self> for TreeTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TreeTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 4,"]
#[doc = "      \"minItems\": 4"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformAs {
    Variant0([TreeTransformAsVariant0Item; 4usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformAs {
    fn default() -> Self {
        Self::Variant0([
            TreeTransformAsVariant0Item::Variant0("x".to_string()),
            TreeTransformAsVariant0Item::Variant0("y".to_string()),
            TreeTransformAsVariant0Item::Variant0("depth".to_string()),
            TreeTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl From<[TreeTransformAsVariant0Item; 4usize]> for TreeTransformAs {
    fn from(value: [TreeTransformAsVariant0Item; 4usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for TreeTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for TreeTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for TreeTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for TreeTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for TreeTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "TreeTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"tidy\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"tidy\","]
#[doc = "        \"cluster\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformMethod {
    Variant0(TreeTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformMethod {
    fn default() -> Self {
        Self::Variant0(TreeTransformMethodVariant0::Tidy)
    }
}
impl From<TreeTransformMethodVariant0> for TreeTransformMethod {
    fn from(value: TreeTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformMethodVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"tidy\","]
#[doc = "    \"cluster\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreeTransformMethodVariant0 {
    #[serde(rename = "tidy")]
    Tidy,
    #[serde(rename = "cluster")]
    Cluster,
}
impl From<&Self> for TreeTransformMethodVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TreeTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Tidy => "tidy".to_string(),
            Self::Cluster => "cluster".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "tidy" => Ok(Self::Tidy),
            "cluster" => Ok(Self::Cluster),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreeTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TreeTransformNodeSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformNodeSize {
    Variant0([TreeTransformNodeSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformNodeSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[TreeTransformNodeSizeVariant0Item; 2usize]> for TreeTransformNodeSize {
    fn from(value: [TreeTransformNodeSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformNodeSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformNodeSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformNodeSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformNodeSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreeTransformNodeSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformNodeSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformSeparation"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": true,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSeparation {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformSeparation {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreeTransformSeparation {
    fn default() -> Self {
        Self::Variant0(true)
    }
}
impl From<bool> for TreeTransformSeparation {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformSeparation {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSize {
    Variant0([TreeTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[TreeTransformSizeVariant0Item; 2usize]> for TreeTransformSize {
    fn from(value: [TreeTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreeTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreeTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreeTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreeTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreeTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"tree\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreeTransformType {
    #[serde(rename = "tree")]
    Tree,
}
impl From<&Self> for TreeTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TreeTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Tree => "tree".to_string(),
        }
    }
}
impl std::str::FromStr for TreeTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "tree" => Ok(Self::Tree),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreeTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TreelinksTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"treelinks\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreelinksTransform {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(rename = "type")]
    pub type_: TreelinksTransformType,
}
impl From<&Self> for TreelinksTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TreelinksTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"treelinks\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreelinksTransformType {
    #[serde(rename = "treelinks")]
    Treelinks,
}
impl From<&Self> for TreelinksTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TreelinksTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treelinks => "treelinks".to_string(),
        }
    }
}
impl std::str::FromStr for TreelinksTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "treelinks" => Ok(Self::Treelinks),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreelinksTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TreemapTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x0\","]
#[doc = "        \"y0\","]
#[doc = "        \"x1\","]
#[doc = "        \"y1\","]
#[doc = "        \"depth\","]
#[doc = "        \"children\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 6,"]
#[doc = "          \"minItems\": 6"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"field\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"default\": \"squarify\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"enum\": ["]
#[doc = "            \"squarify\","]
#[doc = "            \"resquarify\","]
#[doc = "            \"binary\","]
#[doc = "            \"dice\","]
#[doc = "            \"slice\","]
#[doc = "            \"slicedice\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingBottom\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingInner\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingLeft\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingOuter\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingRight\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"paddingTop\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ratio\": {"]
#[doc = "      \"default\": 1.618033988749895,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"round\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"treemap\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct TreemapTransform {
    #[serde(rename = "as", default = "defaults::treemap_transform_as")]
    pub as_: TreemapTransformAs,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub field: Option<TreemapTransformField>,
    #[serde(default = "defaults::treemap_transform_method")]
    pub method: TreemapTransformMethod,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<TreemapTransformPadding>,
    #[serde(
        rename = "paddingBottom",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_bottom: Option<TreemapTransformPaddingBottom>,
    #[serde(
        rename = "paddingInner",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_inner: Option<TreemapTransformPaddingInner>,
    #[serde(
        rename = "paddingLeft",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_left: Option<TreemapTransformPaddingLeft>,
    #[serde(
        rename = "paddingOuter",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_outer: Option<TreemapTransformPaddingOuter>,
    #[serde(
        rename = "paddingRight",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_right: Option<TreemapTransformPaddingRight>,
    #[serde(
        rename = "paddingTop",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub padding_top: Option<TreemapTransformPaddingTop>,
    #[serde(default = "defaults::treemap_transform_ratio")]
    pub ratio: TreemapTransformRatio,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub round: Option<TreemapTransformRound>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<TreemapTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: TreemapTransformType,
}
impl From<&Self> for TreemapTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "TreemapTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x0\","]
#[doc = "    \"y0\","]
#[doc = "    \"x1\","]
#[doc = "    \"y1\","]
#[doc = "    \"depth\","]
#[doc = "    \"children\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 6,"]
#[doc = "      \"minItems\": 6"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformAs {
    Variant0([TreemapTransformAsVariant0Item; 6usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformAs {
    fn default() -> Self {
        Self::Variant0([
            TreemapTransformAsVariant0Item::Variant0("x0".to_string()),
            TreemapTransformAsVariant0Item::Variant0("y0".to_string()),
            TreemapTransformAsVariant0Item::Variant0("x1".to_string()),
            TreemapTransformAsVariant0Item::Variant0("y1".to_string()),
            TreemapTransformAsVariant0Item::Variant0("depth".to_string()),
            TreemapTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
}
impl From<[TreemapTransformAsVariant0Item; 6usize]> for TreemapTransformAs {
    fn from(value: [TreemapTransformAsVariant0Item; 6usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for TreemapTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformField"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformField {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for TreemapTransformField {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for TreemapTransformField {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for TreemapTransformField {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for TreemapTransformField {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "TreemapTransformMethod"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"squarify\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"squarify\","]
#[doc = "        \"resquarify\","]
#[doc = "        \"binary\","]
#[doc = "        \"dice\","]
#[doc = "        \"slice\","]
#[doc = "        \"slicedice\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformMethod {
    Variant0(TreemapTransformMethodVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformMethod {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformMethod {
    fn default() -> Self {
        Self::Variant0(TreemapTransformMethodVariant0::Squarify)
    }
}
impl From<TreemapTransformMethodVariant0> for TreemapTransformMethod {
    fn from(value: TreemapTransformMethodVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformMethod {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformMethodVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"squarify\","]
#[doc = "    \"resquarify\","]
#[doc = "    \"binary\","]
#[doc = "    \"dice\","]
#[doc = "    \"slice\","]
#[doc = "    \"slicedice\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreemapTransformMethodVariant0 {
    #[serde(rename = "squarify")]
    Squarify,
    #[serde(rename = "resquarify")]
    Resquarify,
    #[serde(rename = "binary")]
    Binary,
    #[serde(rename = "dice")]
    Dice,
    #[serde(rename = "slice")]
    Slice,
    #[serde(rename = "slicedice")]
    Slicedice,
}
impl From<&Self> for TreemapTransformMethodVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TreemapTransformMethodVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::Squarify => "squarify".to_string(),
            Self::Resquarify => "resquarify".to_string(),
            Self::Binary => "binary".to_string(),
            Self::Dice => "dice".to_string(),
            Self::Slice => "slice".to_string(),
            Self::Slicedice => "slicedice".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformMethodVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "squarify" => Ok(Self::Squarify),
            "resquarify" => Ok(Self::Resquarify),
            "binary" => Ok(Self::Binary),
            "dice" => Ok(Self::Dice),
            "slice" => Ok(Self::Slice),
            "slicedice" => Ok(Self::Slicedice),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreemapTransformMethodVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "TreemapTransformPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingBottom"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingBottom {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingBottom {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingBottom {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingBottom {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingInner"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingInner {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingInner {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingInner {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingInner {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingLeft"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingLeft {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingLeft {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingLeft {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingLeft {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingOuter"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingOuter {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingOuter {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingOuter {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingOuter {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingRight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingRight {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingRight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingRight {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingRight {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformPaddingTop"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformPaddingTop {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformPaddingTop {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformPaddingTop {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformPaddingTop {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformRatio"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 1.618033988749895,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformRatio {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformRatio {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for TreemapTransformRatio {
    fn default() -> Self {
        Self::Variant0(1.618033988749895_f64)
    }
}
impl From<f64> for TreemapTransformRatio {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformRatio {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformRound"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformRound {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformRound {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for TreemapTransformRound {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformRound {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformSize {
    Variant0([TreemapTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[TreemapTransformSizeVariant0Item; 2usize]> for TreemapTransformSize {
    fn from(value: [TreemapTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum TreemapTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for TreemapTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for TreemapTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for TreemapTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "TreemapTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"treemap\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum TreemapTransformType {
    #[serde(rename = "treemap")]
    Treemap,
}
impl From<&Self> for TreemapTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for TreemapTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Treemap => "treemap".to_string(),
        }
    }
}
impl std::str::FromStr for TreemapTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "treemap" => Ok(Self::Treemap),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for TreemapTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "VoronoiTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\","]
#[doc = "    \"x\","]
#[doc = "    \"y\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": \"path\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"extent\": {"]
#[doc = "      \"default\": ["]
#[doc = "        ["]
#[doc = "          -100000,"]
#[doc = "          -100000"]
#[doc = "        ],"]
#[doc = "        ["]
#[doc = "          100000,"]
#[doc = "          100000"]
#[doc = "        ]"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {},"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"voronoi\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"x\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"y\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VoronoiTransform {
    #[serde(rename = "as", default = "defaults::voronoi_transform_as")]
    pub as_: VoronoiTransformAs,
    #[serde(default = "defaults::voronoi_transform_extent")]
    pub extent: VoronoiTransformExtent,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<VoronoiTransformSize>,
    #[serde(rename = "type")]
    pub type_: VoronoiTransformType,
    pub x: VoronoiTransformX,
    pub y: VoronoiTransformY,
}
impl From<&Self> for VoronoiTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "VoronoiTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"path\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformAs {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for VoronoiTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for VoronoiTransformAs {
    fn default() -> Self {
        Self::Variant0("path".to_string())
    }
}
impl From<SignalRef> for VoronoiTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "VoronoiTransformExtent"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    ["]
#[doc = "      -100000,"]
#[doc = "      -100000"]
#[doc = "    ],"]
#[doc = "    ["]
#[doc = "      100000,"]
#[doc = "      100000"]
#[doc = "    ]"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {},"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformExtent {
    Variant0([serde_json::Value; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for VoronoiTransformExtent {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for VoronoiTransformExtent {
    fn default() -> Self {
        Self::Variant0([
            serde_json::from_str::<serde_json::Value>("[-100000,-100000]").unwrap(),
            serde_json::from_str::<serde_json::Value>("[100000,100000]").unwrap(),
        ])
    }
}
impl From<[serde_json::Value; 2usize]> for VoronoiTransformExtent {
    fn from(value: [serde_json::Value; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for VoronoiTransformExtent {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "VoronoiTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformSize {
    Variant0([VoronoiTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for VoronoiTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[VoronoiTransformSizeVariant0Item; 2usize]> for VoronoiTransformSize {
    fn from(value: [VoronoiTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for VoronoiTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "VoronoiTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for VoronoiTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for VoronoiTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for VoronoiTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "VoronoiTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"voronoi\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum VoronoiTransformType {
    #[serde(rename = "voronoi")]
    Voronoi,
}
impl From<&Self> for VoronoiTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for VoronoiTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Voronoi => "voronoi".to_string(),
        }
    }
}
impl std::str::FromStr for VoronoiTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "voronoi" => Ok(Self::Voronoi),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for VoronoiTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "VoronoiTransformX"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformX {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for VoronoiTransformX {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for VoronoiTransformX {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for VoronoiTransformX {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for VoronoiTransformX {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "VoronoiTransformY"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum VoronoiTransformY {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for VoronoiTransformY {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for VoronoiTransformY {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for VoronoiTransformY {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for VoronoiTransformY {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "WindowTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fields\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"frame\": {"]
#[doc = "      \"default\": ["]
#[doc = "        null,"]
#[doc = "        0"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"groupby\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"oneOf\": ["]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/scaleField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/paramField\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/expr\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ignorePeers\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"ops\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"enum\": ["]
#[doc = "                  \"row_number\","]
#[doc = "                  \"rank\","]
#[doc = "                  \"dense_rank\","]
#[doc = "                  \"percent_rank\","]
#[doc = "                  \"cume_dist\","]
#[doc = "                  \"ntile\","]
#[doc = "                  \"lag\","]
#[doc = "                  \"lead\","]
#[doc = "                  \"first_value\","]
#[doc = "                  \"last_value\","]
#[doc = "                  \"nth_value\","]
#[doc = "                  \"prev_value\","]
#[doc = "                  \"next_value\","]
#[doc = "                  \"values\","]
#[doc = "                  \"count\","]
#[doc = "                  \"__count__\","]
#[doc = "                  \"missing\","]
#[doc = "                  \"valid\","]
#[doc = "                  \"sum\","]
#[doc = "                  \"product\","]
#[doc = "                  \"mean\","]
#[doc = "                  \"average\","]
#[doc = "                  \"variance\","]
#[doc = "                  \"variancep\","]
#[doc = "                  \"stdev\","]
#[doc = "                  \"stdevp\","]
#[doc = "                  \"stderr\","]
#[doc = "                  \"distinct\","]
#[doc = "                  \"ci0\","]
#[doc = "                  \"ci1\","]
#[doc = "                  \"median\","]
#[doc = "                  \"q1\","]
#[doc = "                  \"q3\","]
#[doc = "                  \"min\","]
#[doc = "                  \"max\","]
#[doc = "                  \"argmin\","]
#[doc = "                  \"argmax\""]
#[doc = "                ]"]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"type\": \"null\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"sort\": {"]
#[doc = "      \"$ref\": \"#/definitions/compare\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"window\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WindowTransform {
    #[serde(rename = "as", default, skip_serializing_if = "Option::is_none")]
    pub as_: Option<WindowTransformAs>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub fields: Option<WindowTransformFields>,
    #[serde(default = "defaults::window_transform_frame")]
    pub frame: WindowTransformFrame,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub groupby: Option<WindowTransformGroupby>,
    #[serde(
        rename = "ignorePeers",
        default,
        skip_serializing_if = "Option::is_none"
    )]
    pub ignore_peers: Option<WindowTransformIgnorePeers>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub ops: Option<WindowTransformOps>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub params: Option<WindowTransformParams>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub sort: Option<Compare>,
    #[serde(rename = "type")]
    pub type_: WindowTransformType,
}
impl From<&Self> for WindowTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "WindowTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformAs {
    Variant0(Vec<WindowTransformAsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<WindowTransformAsVariant0Item>> for WindowTransformAs {
    fn from(value: Vec<WindowTransformAsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for WindowTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for WindowTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformFields"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFields {
    Variant0(Vec<WindowTransformFieldsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformFields {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<WindowTransformFieldsVariant0Item>> for WindowTransformFields {
    fn from(value: Vec<WindowTransformFieldsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformFields {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformFieldsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFieldsVariant0Item {
    Variant0(ScaleField),
    Variant1(ParamField),
    Variant2(Expr),
    Variant3,
}
impl From<&Self> for WindowTransformFieldsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for WindowTransformFieldsVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::Variant0(value)
    }
}
impl From<ParamField> for WindowTransformFieldsVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WindowTransformFieldsVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
#[doc = "WindowTransformFrame"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    null,"]
#[doc = "    0"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFrame {
    Variant0([WindowTransformFrameVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformFrame {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WindowTransformFrame {
    fn default() -> Self {
        Self::Variant0([
            WindowTransformFrameVariant0Item::Variant2,
            WindowTransformFrameVariant0Item::Variant0(0_f64),
        ])
    }
}
impl From<[WindowTransformFrameVariant0Item; 2usize]> for WindowTransformFrame {
    fn from(value: [WindowTransformFrameVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformFrame {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformFrameVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformFrameVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for WindowTransformFrameVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WindowTransformFrameVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformFrameVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformGroupby"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"oneOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/scaleField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/paramField\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/expr\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformGroupby {
    Variant0(Vec<WindowTransformGroupbyVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformGroupby {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<WindowTransformGroupbyVariant0Item>> for WindowTransformGroupby {
    fn from(value: Vec<WindowTransformGroupbyVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformGroupby {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformGroupbyVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformGroupbyVariant0Item {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for WindowTransformGroupbyVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for WindowTransformGroupbyVariant0Item {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for WindowTransformGroupbyVariant0Item {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for WindowTransformGroupbyVariant0Item {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "WindowTransformIgnorePeers"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformIgnorePeers {
    Variant0(bool),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformIgnorePeers {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<bool> for WindowTransformIgnorePeers {
    fn from(value: bool) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformIgnorePeers {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformOps"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"row_number\","]
#[doc = "              \"rank\","]
#[doc = "              \"dense_rank\","]
#[doc = "              \"percent_rank\","]
#[doc = "              \"cume_dist\","]
#[doc = "              \"ntile\","]
#[doc = "              \"lag\","]
#[doc = "              \"lead\","]
#[doc = "              \"first_value\","]
#[doc = "              \"last_value\","]
#[doc = "              \"nth_value\","]
#[doc = "              \"prev_value\","]
#[doc = "              \"next_value\","]
#[doc = "              \"values\","]
#[doc = "              \"count\","]
#[doc = "              \"__count__\","]
#[doc = "              \"missing\","]
#[doc = "              \"valid\","]
#[doc = "              \"sum\","]
#[doc = "              \"product\","]
#[doc = "              \"mean\","]
#[doc = "              \"average\","]
#[doc = "              \"variance\","]
#[doc = "              \"variancep\","]
#[doc = "              \"stdev\","]
#[doc = "              \"stdevp\","]
#[doc = "              \"stderr\","]
#[doc = "              \"distinct\","]
#[doc = "              \"ci0\","]
#[doc = "              \"ci1\","]
#[doc = "              \"median\","]
#[doc = "              \"q1\","]
#[doc = "              \"q3\","]
#[doc = "              \"min\","]
#[doc = "              \"max\","]
#[doc = "              \"argmin\","]
#[doc = "              \"argmax\""]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformOps {
    Variant0(Vec<WindowTransformOpsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformOps {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<WindowTransformOpsVariant0Item>> for WindowTransformOps {
    fn from(value: Vec<WindowTransformOpsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformOps {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformOpsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"row_number\","]
#[doc = "        \"rank\","]
#[doc = "        \"dense_rank\","]
#[doc = "        \"percent_rank\","]
#[doc = "        \"cume_dist\","]
#[doc = "        \"ntile\","]
#[doc = "        \"lag\","]
#[doc = "        \"lead\","]
#[doc = "        \"first_value\","]
#[doc = "        \"last_value\","]
#[doc = "        \"nth_value\","]
#[doc = "        \"prev_value\","]
#[doc = "        \"next_value\","]
#[doc = "        \"values\","]
#[doc = "        \"count\","]
#[doc = "        \"__count__\","]
#[doc = "        \"missing\","]
#[doc = "        \"valid\","]
#[doc = "        \"sum\","]
#[doc = "        \"product\","]
#[doc = "        \"mean\","]
#[doc = "        \"average\","]
#[doc = "        \"variance\","]
#[doc = "        \"variancep\","]
#[doc = "        \"stdev\","]
#[doc = "        \"stdevp\","]
#[doc = "        \"stderr\","]
#[doc = "        \"distinct\","]
#[doc = "        \"ci0\","]
#[doc = "        \"ci1\","]
#[doc = "        \"median\","]
#[doc = "        \"q1\","]
#[doc = "        \"q3\","]
#[doc = "        \"min\","]
#[doc = "        \"max\","]
#[doc = "        \"argmin\","]
#[doc = "        \"argmax\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformOpsVariant0Item {
    Variant0(WindowTransformOpsVariant0ItemVariant0),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformOpsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<WindowTransformOpsVariant0ItemVariant0> for WindowTransformOpsVariant0Item {
    fn from(value: WindowTransformOpsVariant0ItemVariant0) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformOpsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformOpsVariant0ItemVariant0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"row_number\","]
#[doc = "    \"rank\","]
#[doc = "    \"dense_rank\","]
#[doc = "    \"percent_rank\","]
#[doc = "    \"cume_dist\","]
#[doc = "    \"ntile\","]
#[doc = "    \"lag\","]
#[doc = "    \"lead\","]
#[doc = "    \"first_value\","]
#[doc = "    \"last_value\","]
#[doc = "    \"nth_value\","]
#[doc = "    \"prev_value\","]
#[doc = "    \"next_value\","]
#[doc = "    \"values\","]
#[doc = "    \"count\","]
#[doc = "    \"__count__\","]
#[doc = "    \"missing\","]
#[doc = "    \"valid\","]
#[doc = "    \"sum\","]
#[doc = "    \"product\","]
#[doc = "    \"mean\","]
#[doc = "    \"average\","]
#[doc = "    \"variance\","]
#[doc = "    \"variancep\","]
#[doc = "    \"stdev\","]
#[doc = "    \"stdevp\","]
#[doc = "    \"stderr\","]
#[doc = "    \"distinct\","]
#[doc = "    \"ci0\","]
#[doc = "    \"ci1\","]
#[doc = "    \"median\","]
#[doc = "    \"q1\","]
#[doc = "    \"q3\","]
#[doc = "    \"min\","]
#[doc = "    \"max\","]
#[doc = "    \"argmin\","]
#[doc = "    \"argmax\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WindowTransformOpsVariant0ItemVariant0 {
    #[serde(rename = "row_number")]
    RowNumber,
    #[serde(rename = "rank")]
    Rank,
    #[serde(rename = "dense_rank")]
    DenseRank,
    #[serde(rename = "percent_rank")]
    PercentRank,
    #[serde(rename = "cume_dist")]
    CumeDist,
    #[serde(rename = "ntile")]
    Ntile,
    #[serde(rename = "lag")]
    Lag,
    #[serde(rename = "lead")]
    Lead,
    #[serde(rename = "first_value")]
    FirstValue,
    #[serde(rename = "last_value")]
    LastValue,
    #[serde(rename = "nth_value")]
    NthValue,
    #[serde(rename = "prev_value")]
    PrevValue,
    #[serde(rename = "next_value")]
    NextValue,
    #[serde(rename = "values")]
    Values,
    #[serde(rename = "count")]
    Count,
    #[serde(rename = "__count__")]
    Count,
    #[serde(rename = "missing")]
    Missing,
    #[serde(rename = "valid")]
    Valid,
    #[serde(rename = "sum")]
    Sum,
    #[serde(rename = "product")]
    Product,
    #[serde(rename = "mean")]
    Mean,
    #[serde(rename = "average")]
    Average,
    #[serde(rename = "variance")]
    Variance,
    #[serde(rename = "variancep")]
    Variancep,
    #[serde(rename = "stdev")]
    Stdev,
    #[serde(rename = "stdevp")]
    Stdevp,
    #[serde(rename = "stderr")]
    Stderr,
    #[serde(rename = "distinct")]
    Distinct,
    #[serde(rename = "ci0")]
    Ci0,
    #[serde(rename = "ci1")]
    Ci1,
    #[serde(rename = "median")]
    Median,
    #[serde(rename = "q1")]
    Q1,
    #[serde(rename = "q3")]
    Q3,
    #[serde(rename = "min")]
    Min,
    #[serde(rename = "max")]
    Max,
    #[serde(rename = "argmin")]
    Argmin,
    #[serde(rename = "argmax")]
    Argmax,
}
impl From<&Self> for WindowTransformOpsVariant0ItemVariant0 {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for WindowTransformOpsVariant0ItemVariant0 {
    fn to_string(&self) -> String {
        match *self {
            Self::RowNumber => "row_number".to_string(),
            Self::Rank => "rank".to_string(),
            Self::DenseRank => "dense_rank".to_string(),
            Self::PercentRank => "percent_rank".to_string(),
            Self::CumeDist => "cume_dist".to_string(),
            Self::Ntile => "ntile".to_string(),
            Self::Lag => "lag".to_string(),
            Self::Lead => "lead".to_string(),
            Self::FirstValue => "first_value".to_string(),
            Self::LastValue => "last_value".to_string(),
            Self::NthValue => "nth_value".to_string(),
            Self::PrevValue => "prev_value".to_string(),
            Self::NextValue => "next_value".to_string(),
            Self::Values => "values".to_string(),
            Self::Count => "count".to_string(),
            Self::Count => "__count__".to_string(),
            Self::Missing => "missing".to_string(),
            Self::Valid => "valid".to_string(),
            Self::Sum => "sum".to_string(),
            Self::Product => "product".to_string(),
            Self::Mean => "mean".to_string(),
            Self::Average => "average".to_string(),
            Self::Variance => "variance".to_string(),
            Self::Variancep => "variancep".to_string(),
            Self::Stdev => "stdev".to_string(),
            Self::Stdevp => "stdevp".to_string(),
            Self::Stderr => "stderr".to_string(),
            Self::Distinct => "distinct".to_string(),
            Self::Ci0 => "ci0".to_string(),
            Self::Ci1 => "ci1".to_string(),
            Self::Median => "median".to_string(),
            Self::Q1 => "q1".to_string(),
            Self::Q3 => "q3".to_string(),
            Self::Min => "min".to_string(),
            Self::Max => "max".to_string(),
            Self::Argmin => "argmin".to_string(),
            Self::Argmax => "argmax".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformOpsVariant0ItemVariant0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "row_number" => Ok(Self::RowNumber),
            "rank" => Ok(Self::Rank),
            "dense_rank" => Ok(Self::DenseRank),
            "percent_rank" => Ok(Self::PercentRank),
            "cume_dist" => Ok(Self::CumeDist),
            "ntile" => Ok(Self::Ntile),
            "lag" => Ok(Self::Lag),
            "lead" => Ok(Self::Lead),
            "first_value" => Ok(Self::FirstValue),
            "last_value" => Ok(Self::LastValue),
            "nth_value" => Ok(Self::NthValue),
            "prev_value" => Ok(Self::PrevValue),
            "next_value" => Ok(Self::NextValue),
            "values" => Ok(Self::Values),
            "count" => Ok(Self::Count),
            "__count__" => Ok(Self::Count),
            "missing" => Ok(Self::Missing),
            "valid" => Ok(Self::Valid),
            "sum" => Ok(Self::Sum),
            "product" => Ok(Self::Product),
            "mean" => Ok(Self::Mean),
            "average" => Ok(Self::Average),
            "variance" => Ok(Self::Variance),
            "variancep" => Ok(Self::Variancep),
            "stdev" => Ok(Self::Stdev),
            "stdevp" => Ok(Self::Stdevp),
            "stderr" => Ok(Self::Stderr),
            "distinct" => Ok(Self::Distinct),
            "ci0" => Ok(Self::Ci0),
            "ci1" => Ok(Self::Ci1),
            "median" => Ok(Self::Median),
            "q1" => Ok(Self::Q1),
            "q3" => Ok(Self::Q3),
            "min" => Ok(Self::Min),
            "max" => Ok(Self::Max),
            "argmin" => Ok(Self::Argmin),
            "argmax" => Ok(Self::Argmax),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WindowTransformOpsVariant0ItemVariant0 {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "WindowTransformParams"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformParams {
    Variant0(Vec<WindowTransformParamsVariant0Item>),
    Variant1(SignalRef),
}
impl From<&Self> for WindowTransformParams {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<Vec<WindowTransformParamsVariant0Item>> for WindowTransformParams {
    fn from(value: Vec<WindowTransformParamsVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformParams {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformParamsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WindowTransformParamsVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for WindowTransformParamsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WindowTransformParamsVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WindowTransformParamsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WindowTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"window\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WindowTransformType {
    #[serde(rename = "window")]
    Window,
}
impl From<&Self> for WindowTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for WindowTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Window => "window".to_string(),
        }
    }
}
impl std::str::FromStr for WindowTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "window" => Ok(Self::Window),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WindowTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "WordcloudTransform"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"default\": ["]
#[doc = "        \"x\","]
#[doc = "        \"y\","]
#[doc = "        \"font\","]
#[doc = "        \"fontSize\","]
#[doc = "        \"fontStyle\","]
#[doc = "        \"fontWeight\","]
#[doc = "        \"angle\""]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 7,"]
#[doc = "          \"minItems\": 7"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"font\": {"]
#[doc = "      \"default\": \"sans-serif\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontSize\": {"]
#[doc = "      \"default\": 14,"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontSizeRange\": {"]
#[doc = "      \"default\": ["]
#[doc = "        10,"]
#[doc = "        50"]
#[doc = "      ],"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontStyle\": {"]
#[doc = "      \"default\": \"normal\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fontWeight\": {"]
#[doc = "      \"default\": \"normal\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"padding\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"rotate\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"number\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"signal\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"size\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"anyOf\": ["]
#[doc = "              {"]
#[doc = "                \"type\": \"number\""]
#[doc = "              },"]
#[doc = "              {"]
#[doc = "                \"$ref\": \"#/definitions/signalRef\""]
#[doc = "              }"]
#[doc = "            ]"]
#[doc = "          },"]
#[doc = "          \"maxItems\": 2,"]
#[doc = "          \"minItems\": 2"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"spiral\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/signalRef\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"text\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/scaleField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/paramField\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/definitions/expr\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"enum\": ["]
#[doc = "        \"wordcloud\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct WordcloudTransform {
    #[serde(rename = "as", default = "defaults::wordcloud_transform_as")]
    pub as_: WordcloudTransformAs,
    #[serde(default = "defaults::wordcloud_transform_font")]
    pub font: WordcloudTransformFont,
    #[serde(
        rename = "fontSize",
        default = "defaults::wordcloud_transform_font_size"
    )]
    pub font_size: WordcloudTransformFontSize,
    #[serde(
        rename = "fontSizeRange",
        default = "defaults::wordcloud_transform_font_size_range"
    )]
    pub font_size_range: WordcloudTransformFontSizeRange,
    #[serde(
        rename = "fontStyle",
        default = "defaults::wordcloud_transform_font_style"
    )]
    pub font_style: WordcloudTransformFontStyle,
    #[serde(
        rename = "fontWeight",
        default = "defaults::wordcloud_transform_font_weight"
    )]
    pub font_weight: WordcloudTransformFontWeight,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub padding: Option<WordcloudTransformPadding>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub rotate: Option<WordcloudTransformRotate>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub signal: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub size: Option<WordcloudTransformSize>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub spiral: Option<WordcloudTransformSpiral>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub text: Option<WordcloudTransformText>,
    #[serde(rename = "type")]
    pub type_: WordcloudTransformType,
}
impl From<&Self> for WordcloudTransform {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
#[doc = "WordcloudTransformAs"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    \"x\","]
#[doc = "    \"y\","]
#[doc = "    \"font\","]
#[doc = "    \"fontSize\","]
#[doc = "    \"fontStyle\","]
#[doc = "    \"fontWeight\","]
#[doc = "    \"angle\""]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 7,"]
#[doc = "      \"minItems\": 7"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformAs {
    Variant0([WordcloudTransformAsVariant0Item; 7usize]),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformAs {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformAs {
    fn default() -> Self {
        Self::Variant0([
            WordcloudTransformAsVariant0Item::Variant0("x".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("y".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("font".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontSize".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontStyle".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("fontWeight".to_string()),
            WordcloudTransformAsVariant0Item::Variant0("angle".to_string()),
        ])
    }
}
impl From<[WordcloudTransformAsVariant0Item; 7usize]> for WordcloudTransformAs {
    fn from(value: [WordcloudTransformAsVariant0Item; 7usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformAs {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformAsVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformAsVariant0Item {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformAsVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for WordcloudTransformAsVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformFont"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"sans-serif\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFont {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformFont {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFont {
    fn default() -> Self {
        Self::Variant0("sans-serif".to_string())
    }
}
impl From<SignalRef> for WordcloudTransformFont {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformFont {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformFont {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformFontSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": 14,"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSize {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformFontSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontSize {
    fn default() -> Self {
        Self::Variant0(14_f64)
    }
}
impl From<f64> for WordcloudTransformFontSize {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformFontSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformFontSize {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformFontSize {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformFontSizeRange"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": ["]
#[doc = "    10,"]
#[doc = "    50"]
#[doc = "  ],"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"null\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRange {
    Variant0(Vec<WordcloudTransformFontSizeRangeVariant0Item>),
    Variant1(SignalRef),
    Variant2,
}
impl From<&Self> for WordcloudTransformFontSizeRange {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontSizeRange {
    fn default() -> Self {
        Self::Variant0(vec![
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
}
impl From<Vec<WordcloudTransformFontSizeRangeVariant0Item>> for WordcloudTransformFontSizeRange {
    fn from(value: Vec<WordcloudTransformFontSizeRangeVariant0Item>) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformFontSizeRange {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformFontSizeRangeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontSizeRangeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformFontSizeRangeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformFontStyle"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"normal\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontStyle {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformFontStyle {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontStyle {
    fn default() -> Self {
        Self::Variant0("normal".to_string())
    }
}
impl From<SignalRef> for WordcloudTransformFontStyle {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformFontStyle {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformFontStyle {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformFontWeight"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"normal\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformFontWeight {
    Variant0(String),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformFontWeight {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl Default for WordcloudTransformFontWeight {
    fn default() -> Self {
        Self::Variant0("normal".to_string())
    }
}
impl From<SignalRef> for WordcloudTransformFontWeight {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformFontWeight {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformFontWeight {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformPadding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformPadding {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformPadding {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WordcloudTransformPadding {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformPadding {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformPadding {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformPadding {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformRotate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformRotate {
    Variant0(f64),
    Variant1(SignalRef),
    Variant2(Expr),
    Variant3(ParamField),
}
impl From<&Self> for WordcloudTransformRotate {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WordcloudTransformRotate {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformRotate {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
impl From<Expr> for WordcloudTransformRotate {
    fn from(value: Expr) -> Self {
        Self::Variant2(value)
    }
}
impl From<ParamField> for WordcloudTransformRotate {
    fn from(value: ParamField) -> Self {
        Self::Variant3(value)
    }
}
#[doc = "WordcloudTransformSize"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"type\": \"number\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/definitions/signalRef\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSize {
    Variant0([WordcloudTransformSizeVariant0Item; 2usize]),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformSize {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<[WordcloudTransformSizeVariant0Item; 2usize]> for WordcloudTransformSize {
    fn from(value: [WordcloudTransformSizeVariant0Item; 2usize]) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformSize {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformSizeVariant0Item"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"number\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSizeVariant0Item {
    Variant0(f64),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformSizeVariant0Item {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<f64> for WordcloudTransformSizeVariant0Item {
    fn from(value: f64) -> Self {
        Self::Variant0(value)
    }
}
impl From<SignalRef> for WordcloudTransformSizeVariant0Item {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformSpiral"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/signalRef\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformSpiral {
    Variant0(String),
    Variant1(SignalRef),
}
impl From<&Self> for WordcloudTransformSpiral {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<SignalRef> for WordcloudTransformSpiral {
    fn from(value: SignalRef) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "WordcloudTransformText"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/scaleField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/paramField\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/definitions/expr\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(untagged)]
pub enum WordcloudTransformText {
    ScaleField(ScaleField),
    ParamField(ParamField),
    Expr(Expr),
}
impl From<&Self> for WordcloudTransformText {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl From<ScaleField> for WordcloudTransformText {
    fn from(value: ScaleField) -> Self {
        Self::ScaleField(value)
    }
}
impl From<ParamField> for WordcloudTransformText {
    fn from(value: ParamField) -> Self {
        Self::ParamField(value)
    }
}
impl From<Expr> for WordcloudTransformText {
    fn from(value: Expr) -> Self {
        Self::Expr(value)
    }
}
#[doc = "WordcloudTransformType"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"enum\": ["]
#[doc = "    \"wordcloud\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub enum WordcloudTransformType {
    #[serde(rename = "wordcloud")]
    Wordcloud,
}
impl From<&Self> for WordcloudTransformType {
    fn from(value: &Self) -> Self {
        value.clone()
    }
}
impl ToString for WordcloudTransformType {
    fn to_string(&self) -> String {
        match *self {
            Self::Wordcloud => "wordcloud".to_string(),
        }
    }
}
impl std::str::FromStr for WordcloudTransformType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> Result<Self, self::error::ConversionError> {
        match value {
            "wordcloud" => Ok(Self::Wordcloud),
            _ => Err("invalid value".into()),
        }
    }
}
impl std::convert::TryFrom<&str> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<&String> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: &String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl std::convert::TryFrom<String> for WordcloudTransformType {
    type Error = self::error::ConversionError;
    fn try_from(value: String) -> Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = r" Generation of default values for serde."]
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn default_i64<T, const V: i64>() -> T
    where
        T: std::convert::TryFrom<i64>,
        <T as std::convert::TryFrom<i64>>::Error: std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
    pub(super) fn aggregate_transform_drop() -> super::AggregateTransformDrop {
        super::AggregateTransformDrop::Variant0(true)
    }
    pub(super) fn bin_transform_as() -> super::BinTransformAs {
        super::BinTransformAs::Variant0([
            super::BinTransformAsVariant0Item::Variant0("bin0".to_string()),
            super::BinTransformAsVariant0Item::Variant0("bin1".to_string()),
        ])
    }
    pub(super) fn bin_transform_base() -> super::BinTransformBase {
        super::BinTransformBase::Variant0(10_f64)
    }
    pub(super) fn bin_transform_divide() -> super::BinTransformDivide {
        super::BinTransformDivide::Variant0(vec![
            super::BinTransformDivideVariant0Item::Variant0(5_f64),
            super::BinTransformDivideVariant0Item::Variant0(2_f64),
        ])
    }
    pub(super) fn bin_transform_interval() -> super::BinTransformInterval {
        super::BinTransformInterval::Variant0(true)
    }
    pub(super) fn bin_transform_maxbins() -> super::BinTransformMaxbins {
        super::BinTransformMaxbins::Variant0(20_f64)
    }
    pub(super) fn bin_transform_nice() -> super::BinTransformNice {
        super::BinTransformNice::Variant0(true)
    }
    pub(super) fn contour_transform_smooth() -> super::ContourTransformSmooth {
        super::ContourTransformSmooth::Variant0(true)
    }
    pub(super) fn countpattern_transform_as() -> super::CountpatternTransformAs {
        super::CountpatternTransformAs::Variant0([
            super::CountpatternTransformAsVariant0Item::Variant0("text".to_string()),
            super::CountpatternTransformAsVariant0Item::Variant0("count".to_string()),
        ])
    }
    pub(super) fn countpattern_transform_case() -> super::CountpatternTransformCase {
        super::CountpatternTransformCase::Variant0(super::CountpatternTransformCaseVariant0::Mixed)
    }
    pub(super) fn countpattern_transform_pattern() -> super::CountpatternTransformPattern {
        super::CountpatternTransformPattern::Variant0("[\\w\"]+".to_string())
    }
    pub(super) fn cross_transform_as() -> super::CrossTransformAs {
        super::CrossTransformAs::Variant0([
            super::CrossTransformAsVariant0Item::Variant0("a".to_string()),
            super::CrossTransformAsVariant0Item::Variant0("b".to_string()),
        ])
    }
    pub(super) fn density_transform_as() -> super::DensityTransformAs {
        super::DensityTransformAs::Variant0(vec![
            super::DensityTransformAsVariant0Item::Variant0("value".to_string()),
            super::DensityTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn density_transform_maxsteps() -> super::DensityTransformMaxsteps {
        super::DensityTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn density_transform_method() -> super::DensityTransformMethod {
        super::DensityTransformMethod::Variant0("pdf".to_string())
    }
    pub(super) fn density_transform_minsteps() -> super::DensityTransformMinsteps {
        super::DensityTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn density_transform_distribution_lognormal_stdev(
    ) -> super::DensityTransformDistributionStdev {
        super::DensityTransformDistributionStdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_normal_stdev(
    ) -> super::DensityTransformDistributionStdev {
        super::DensityTransformDistributionStdev::Variant0(1_f64)
    }
    pub(super) fn density_transform_distribution_uniform_max(
    ) -> super::DensityTransformDistributionMax {
        super::DensityTransformDistributionMax::Variant0(1_f64)
    }
    pub(super) fn dotbin_transform_as() -> super::DotbinTransformAs {
        super::DotbinTransformAs::Variant0("bin".to_string())
    }
    pub(super) fn fold_transform_as() -> super::FoldTransformAs {
        super::FoldTransformAs::Variant0([
            super::FoldTransformAsVariant0Item::Variant0("key".to_string()),
            super::FoldTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn force_transform_alpha() -> super::ForceTransformAlpha {
        super::ForceTransformAlpha::Variant0(1_f64)
    }
    pub(super) fn force_transform_alpha_min() -> super::ForceTransformAlphaMin {
        super::ForceTransformAlphaMin::Variant0(0.001_f64)
    }
    pub(super) fn force_transform_as() -> super::ForceTransformAs {
        super::ForceTransformAs::Variant0(vec![
            super::ForceTransformAsVariant0Item::Variant0("x".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("y".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vx".to_string()),
            super::ForceTransformAsVariant0Item::Variant0("vy".to_string()),
        ])
    }
    pub(super) fn force_transform_iterations() -> super::ForceTransformIterations {
        super::ForceTransformIterations::Variant0(300_f64)
    }
    pub(super) fn force_transform_velocity_decay() -> super::ForceTransformVelocityDecay {
        super::ForceTransformVelocityDecay::Variant0(0.4_f64)
    }
    pub(super) fn force_transform_forces_item_collide_iterations(
    ) -> super::ForceTransformForcesItemIterations {
        super::ForceTransformForcesItemIterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_collide_strength(
    ) -> super::ForceTransformForcesItemStrength {
        super::ForceTransformForcesItemStrength::Variant0(0.7_f64)
    }
    pub(super) fn force_transform_forces_item_link_distance(
    ) -> super::ForceTransformForcesItemDistance {
        super::ForceTransformForcesItemDistance::Variant0(30_f64)
    }
    pub(super) fn force_transform_forces_item_link_iterations(
    ) -> super::ForceTransformForcesItemIterations {
        super::ForceTransformForcesItemIterations::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_distance_min(
    ) -> super::ForceTransformForcesItemDistanceMin {
        super::ForceTransformForcesItemDistanceMin::Variant0(1_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_strength(
    ) -> super::ForceTransformForcesItemStrength {
        super::ForceTransformForcesItemStrength::Variant0(-30_f64)
    }
    pub(super) fn force_transform_forces_item_nbody_theta() -> super::ForceTransformForcesItemTheta
    {
        super::ForceTransformForcesItemTheta::Variant0(0.9_f64)
    }
    pub(super) fn force_transform_forces_item_x_strength() -> super::ForceTransformForcesItemStrength
    {
        super::ForceTransformForcesItemStrength::Variant0(0.1_f64)
    }
    pub(super) fn force_transform_forces_item_y_strength() -> super::ForceTransformForcesItemStrength
    {
        super::ForceTransformForcesItemStrength::Variant0(0.1_f64)
    }
    pub(super) fn geopath_transform_as() -> super::GeopathTransformAs {
        super::GeopathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn geopoint_transform_as() -> super::GeopointTransformAs {
        super::GeopointTransformAs::Variant0([
            super::GeopointTransformAsVariant0Item::Variant0("x".to_string()),
            super::GeopointTransformAsVariant0Item::Variant0("y".to_string()),
        ])
    }
    pub(super) fn geoshape_transform_as() -> super::GeoshapeTransformAs {
        super::GeoshapeTransformAs::Variant0("shape".to_string())
    }
    pub(super) fn geoshape_transform_field() -> super::GeoshapeTransformField {
        super::GeoshapeTransformField::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("datum".to_string()),
        ))
    }
    pub(super) fn graticule_transform_precision() -> super::GraticuleTransformPrecision {
        super::GraticuleTransformPrecision::Variant0(2.5_f64)
    }
    pub(super) fn graticule_transform_step_major() -> super::GraticuleTransformStepMajor {
        super::GraticuleTransformStepMajor::Variant0([
            super::GraticuleTransformStepMajorVariant0Item::Variant0(90_f64),
            super::GraticuleTransformStepMajorVariant0Item::Variant0(360_f64),
        ])
    }
    pub(super) fn graticule_transform_step_minor() -> super::GraticuleTransformStepMinor {
        super::GraticuleTransformStepMinor::Variant0([
            super::GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
            super::GraticuleTransformStepMinorVariant0Item::Variant0(10_f64),
        ])
    }
    pub(super) fn heatmap_transform_as() -> super::HeatmapTransformAs {
        super::HeatmapTransformAs::Variant0("image".to_string())
    }
    pub(super) fn heatmap_transform_resolve() -> super::HeatmapTransformResolve {
        super::HeatmapTransformResolve::Variant0(
            super::HeatmapTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn impute_transform_method() -> super::ImputeTransformMethod {
        super::ImputeTransformMethod::Variant0(super::ImputeTransformMethodVariant0::Value)
    }
    pub(super) fn isocontour_transform_as() -> super::IsocontourTransformAs {
        super::IsocontourTransformAs::Variant0("contour".to_string())
    }
    pub(super) fn isocontour_transform_resolve() -> super::IsocontourTransformResolve {
        super::IsocontourTransformResolve::Variant0(
            super::IsocontourTransformResolveVariant0::Independent,
        )
    }
    pub(super) fn isocontour_transform_smooth() -> super::IsocontourTransformSmooth {
        super::IsocontourTransformSmooth::Variant0(true)
    }
    pub(super) fn isocontour_transform_zero() -> super::IsocontourTransformZero {
        super::IsocontourTransformZero::Variant0(true)
    }
    pub(super) fn kde2d_transform_as() -> super::Kde2dTransformAs {
        super::Kde2dTransformAs::Variant0("grid".to_string())
    }
    pub(super) fn kde_transform_as() -> super::KdeTransformAs {
        super::KdeTransformAs::Variant0(vec![
            super::KdeTransformAsVariant0Item::Variant0("value".to_string()),
            super::KdeTransformAsVariant0Item::Variant0("density".to_string()),
        ])
    }
    pub(super) fn kde_transform_maxsteps() -> super::KdeTransformMaxsteps {
        super::KdeTransformMaxsteps::Variant0(200_f64)
    }
    pub(super) fn kde_transform_minsteps() -> super::KdeTransformMinsteps {
        super::KdeTransformMinsteps::Variant0(25_f64)
    }
    pub(super) fn kde_transform_resolve() -> super::KdeTransformResolve {
        super::KdeTransformResolve::Variant0(super::KdeTransformResolveVariant0::Independent)
    }
    pub(super) fn label_transform_anchor() -> super::LabelTransformAnchor {
        super::LabelTransformAnchor::Variant0(vec![
            super::LabelTransformAnchorVariant0Item::Variant0("top-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-left".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("top-right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("right".to_string()),
            super::LabelTransformAnchorVariant0Item::Variant0("bottom-right".to_string()),
        ])
    }
    pub(super) fn label_transform_as() -> super::LabelTransformAs {
        super::LabelTransformAs::Variant0([
            super::LabelTransformAsVariant0Item::Variant0("x".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("y".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("opacity".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("align".to_string()),
            super::LabelTransformAsVariant0Item::Variant0("baseline".to_string()),
        ])
    }
    pub(super) fn label_transform_avoid_base_mark() -> super::LabelTransformAvoidBaseMark {
        super::LabelTransformAvoidBaseMark::Variant0(true)
    }
    pub(super) fn label_transform_line_anchor() -> super::LabelTransformLineAnchor {
        super::LabelTransformLineAnchor::Variant0("end".to_string())
    }
    pub(super) fn label_transform_method() -> super::LabelTransformMethod {
        super::LabelTransformMethod::Variant0("naive".to_string())
    }
    pub(super) fn label_transform_offset() -> super::LabelTransformOffset {
        super::LabelTransformOffset::Variant0(vec![
            super::LabelTransformOffsetVariant0Item::Variant0(1_f64),
        ])
    }
    pub(super) fn linkpath_transform_as() -> super::LinkpathTransformAs {
        super::LinkpathTransformAs::Variant0("path".to_string())
    }
    pub(super) fn linkpath_transform_orient() -> super::LinkpathTransformOrient {
        super::LinkpathTransformOrient::Variant0(super::LinkpathTransformOrientVariant0::Vertical)
    }
    pub(super) fn linkpath_transform_shape() -> super::LinkpathTransformShape {
        super::LinkpathTransformShape::Variant0(super::LinkpathTransformShapeVariant0::Line)
    }
    pub(super) fn linkpath_transform_source_x() -> super::LinkpathTransformSourceX {
        super::LinkpathTransformSourceX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_source_y() -> super::LinkpathTransformSourceY {
        super::LinkpathTransformSourceY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("source.y".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_x() -> super::LinkpathTransformTargetX {
        super::LinkpathTransformTargetX::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.x".to_string()),
        ))
    }
    pub(super) fn linkpath_transform_target_y() -> super::LinkpathTransformTargetY {
        super::LinkpathTransformTargetY::ScaleField(super::ScaleField(
            super::StringOrSignal::Variant0("target.y".to_string()),
        ))
    }
    pub(super) fn loess_transform_bandwidth() -> super::LoessTransformBandwidth {
        super::LoessTransformBandwidth::Variant0(0.3_f64)
    }
    pub(super) fn pack_transform_as() -> super::PackTransformAs {
        super::PackTransformAs::Variant0([
            super::PackTransformAsVariant0Item::Variant0("x".to_string()),
            super::PackTransformAsVariant0Item::Variant0("y".to_string()),
            super::PackTransformAsVariant0Item::Variant0("r".to_string()),
            super::PackTransformAsVariant0Item::Variant0("depth".to_string()),
            super::PackTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn partition_transform_as() -> super::PartitionTransformAs {
        super::PartitionTransformAs::Variant0([
            super::PartitionTransformAsVariant0Item::Variant0("x0".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("y0".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("x1".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("y1".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("depth".to_string()),
            super::PartitionTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn pie_transform_as() -> super::PieTransformAs {
        super::PieTransformAs::Variant0([
            super::PieTransformAsVariant0Item::Variant0("startAngle".to_string()),
            super::PieTransformAsVariant0Item::Variant0("endAngle".to_string()),
        ])
    }
    pub(super) fn pie_transform_end_angle() -> super::PieTransformEndAngle {
        super::PieTransformEndAngle::Variant0(6.283185307179586_f64)
    }
    pub(super) fn pivot_transform_op() -> super::PivotTransformOp {
        super::PivotTransformOp::Variant0(super::PivotTransformOpVariant0::Sum)
    }
    pub(super) fn quantile_transform_as() -> super::QuantileTransformAs {
        super::QuantileTransformAs::Variant0(vec![
            super::QuantileTransformAsVariant0Item::Variant0("prob".to_string()),
            super::QuantileTransformAsVariant0Item::Variant0("value".to_string()),
        ])
    }
    pub(super) fn quantile_transform_step() -> super::QuantileTransformStep {
        super::QuantileTransformStep::Variant0(0.01_f64)
    }
    pub(super) fn regression_transform_method() -> super::RegressionTransformMethod {
        super::RegressionTransformMethod::Variant0("linear".to_string())
    }
    pub(super) fn regression_transform_order() -> super::RegressionTransformOrder {
        super::RegressionTransformOrder::Variant0(3_f64)
    }
    pub(super) fn sample_transform_size() -> super::SampleTransformSize {
        super::SampleTransformSize::Variant0(1000_f64)
    }
    pub(super) fn sequence_transform_as() -> super::SequenceTransformAs {
        super::SequenceTransformAs::Variant0("data".to_string())
    }
    pub(super) fn sequence_transform_step() -> super::SequenceTransformStep {
        super::SequenceTransformStep::Variant0(1_f64)
    }
    pub(super) fn stack_transform_as() -> super::StackTransformAs {
        super::StackTransformAs::Variant0([
            super::StackTransformAsVariant0Item::Variant0("y0".to_string()),
            super::StackTransformAsVariant0Item::Variant0("y1".to_string()),
        ])
    }
    pub(super) fn stack_transform_offset() -> super::StackTransformOffset {
        super::StackTransformOffset::Variant0(super::StackTransformOffsetVariant0::Zero)
    }
    pub(super) fn timeunit_transform_as() -> super::TimeunitTransformAs {
        super::TimeunitTransformAs::Variant0([
            super::TimeunitTransformAsVariant0Item::Variant0("unit0".to_string()),
            super::TimeunitTransformAsVariant0Item::Variant0("unit1".to_string()),
        ])
    }
    pub(super) fn timeunit_transform_interval() -> super::TimeunitTransformInterval {
        super::TimeunitTransformInterval::Variant0(true)
    }
    pub(super) fn timeunit_transform_maxbins() -> super::TimeunitTransformMaxbins {
        super::TimeunitTransformMaxbins::Variant0(40_f64)
    }
    pub(super) fn timeunit_transform_step() -> super::TimeunitTransformStep {
        super::TimeunitTransformStep::Variant0(1_f64)
    }
    pub(super) fn timeunit_transform_timezone() -> super::TimeunitTransformTimezone {
        super::TimeunitTransformTimezone::Variant0(super::TimeunitTransformTimezoneVariant0::Local)
    }
    pub(super) fn tree_transform_as() -> super::TreeTransformAs {
        super::TreeTransformAs::Variant0([
            super::TreeTransformAsVariant0Item::Variant0("x".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("y".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("depth".to_string()),
            super::TreeTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn tree_transform_method() -> super::TreeTransformMethod {
        super::TreeTransformMethod::Variant0(super::TreeTransformMethodVariant0::Tidy)
    }
    pub(super) fn tree_transform_separation() -> super::TreeTransformSeparation {
        super::TreeTransformSeparation::Variant0(true)
    }
    pub(super) fn treemap_transform_as() -> super::TreemapTransformAs {
        super::TreemapTransformAs::Variant0([
            super::TreemapTransformAsVariant0Item::Variant0("x0".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("y0".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("x1".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("y1".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("depth".to_string()),
            super::TreemapTransformAsVariant0Item::Variant0("children".to_string()),
        ])
    }
    pub(super) fn treemap_transform_method() -> super::TreemapTransformMethod {
        super::TreemapTransformMethod::Variant0(super::TreemapTransformMethodVariant0::Squarify)
    }
    pub(super) fn treemap_transform_ratio() -> super::TreemapTransformRatio {
        super::TreemapTransformRatio::Variant0(1.618033988749895_f64)
    }
    pub(super) fn voronoi_transform_as() -> super::VoronoiTransformAs {
        super::VoronoiTransformAs::Variant0("path".to_string())
    }
    pub(super) fn voronoi_transform_extent() -> super::VoronoiTransformExtent {
        super::VoronoiTransformExtent::Variant0([
            serde_json::from_str::<serde_json::Value>("[-100000,-100000]").unwrap(),
            serde_json::from_str::<serde_json::Value>("[100000,100000]").unwrap(),
        ])
    }
    pub(super) fn window_transform_frame() -> super::WindowTransformFrame {
        super::WindowTransformFrame::Variant0([
            super::WindowTransformFrameVariant0Item::Variant2,
            super::WindowTransformFrameVariant0Item::Variant0(0_f64),
        ])
    }
    pub(super) fn wordcloud_transform_as() -> super::WordcloudTransformAs {
        super::WordcloudTransformAs::Variant0([
            super::WordcloudTransformAsVariant0Item::Variant0("x".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("y".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("font".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontSize".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontStyle".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("fontWeight".to_string()),
            super::WordcloudTransformAsVariant0Item::Variant0("angle".to_string()),
        ])
    }
    pub(super) fn wordcloud_transform_font() -> super::WordcloudTransformFont {
        super::WordcloudTransformFont::Variant0("sans-serif".to_string())
    }
    pub(super) fn wordcloud_transform_font_size() -> super::WordcloudTransformFontSize {
        super::WordcloudTransformFontSize::Variant0(14_f64)
    }
    pub(super) fn wordcloud_transform_font_size_range() -> super::WordcloudTransformFontSizeRange {
        super::WordcloudTransformFontSizeRange::Variant0(vec![
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(10_f64),
            super::WordcloudTransformFontSizeRangeVariant0Item::Variant0(50_f64),
        ])
    }
    pub(super) fn wordcloud_transform_font_style() -> super::WordcloudTransformFontStyle {
        super::WordcloudTransformFontStyle::Variant0("normal".to_string())
    }
    pub(super) fn wordcloud_transform_font_weight() -> super::WordcloudTransformFontWeight {
        super::WordcloudTransformFontWeight::Variant0("normal".to_string())
    }
}
