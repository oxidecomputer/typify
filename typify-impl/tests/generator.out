mod types {
    #[derive(Clone, Debug, Deserialize, Serialize, JsonSchema)]
    pub struct CompoundType {
        pub value1: String,
        pub value2: u64,
    }
    #[derive(
        Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, JsonSchema,
    )]
    pub enum StringEnum {
        One,
        Two,
        BuckleMyShoe,
    }
    impl ToString for StringEnum {
        fn to_string(&self) -> String {
            match *self {
                Self::One => "One".to_string(),
                Self::Two => "Two".to_string(),
                Self::BuckleMyShoe => "BuckleMyShoe".to_string(),
            }
        }
    }
    impl std::str::FromStr for StringEnum {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            match value {
                "One" => Ok(Self::One),
                "Two" => Ok(Self::Two),
                "BuckleMyShoe" => Ok(Self::BuckleMyShoe),
                _ => Err("invalid value"),
            }
        }
    }
    #[derive(Clone, Debug, Deserialize, Serialize, JsonSchema)]
    pub struct Pair {
        #[serde(default = "pair_a")]
        pub a: String,
        #[serde(default = "pair_b")]
        pub b: String,
    }
    fn pair_a() -> String {
        "A".to_string()
    }
    fn pair_b() -> String {
        "B".to_string()
    }
}
pub fn do_stuff(
    body: &types::CompoundType,
    string: &str,
    opt_int: Option<u32>,
    strenum: types::StringEnum,
) -> types::CompoundType {
    todo!()
}
